#lang racket/base
(require
  "syntax.rkt"
  )

;; TODO:
;; syntax-error for more convenient source-info reporting.
;; match-syntax for more convenient parsing and validation.

(define (b-keyword? b) (eqv? 'keyword (car b)))
(define (b-keyword-transformer bv) (cdr bv))
(define (b-variable? b) (eqv? 'variable (car b)))
(define (b-variable-address bv) (cdr bv))

(define env-empty (hash))
(define (env-set env label type value)
  (if label (hash-set env label (cons type value)) env))
(define (env-set-variable env label address)
  (env-set env label 'variable address))
(define (env-set-keyword env label trans) (env-set env label 'keyword trans))
(define (env-ref env label) (hash-ref env label #f))
(define (env-ref-bound env label)
  (define binding (env-ref env label))
  ;; TODO: provide better information than just label.
  (when (not binding) (error "unbound variable:" label))
  binding)
(define (env-ref-identifier env id) (env-ref-bound env (identifier->label id)))
(define (env-alias env alias-label aliased-label)
  (hash-set env alias-label (env-ref-bound env aliased-label)))
(define (env-extend* env tb*)
  (foldl (lambda (tb env) (env-set env (cadr tb) (car tb) (cadr tb))) env tb*))
(define (env-extend*/type env type b*)
  (foldl (lambda (b env) (env-set env (car b) type (cdr b))) env b*))
(define (env-extend-variable* env b*) (env-extend*/type env 'variable b*))
(define (env-extend-keyword* env b*) (env-extend*/type env 'keyword b*))

(define (form->transformer env form)
  (and (identifier? form)
       (let ((b (env-ref-identifier env form)))
         (and (b-keyword? b) (b-keyword-transformer b)))))

(define (datum-self-evaluating? datum)
  (or (boolean? datum) (number? datum) (char? datum) (string? datum)))
(define (datum-atom? datum)
  (or (datum-self-evaluating? datum) (symbol? datum) (null? datum)))
(define (datum-valid-literal? datum)
  (cond ((vector? datum) (andmap datum-valid-literal? (vector->list datum)))
        ((pair? datum) (and (datum-valid-literal? (car datum))
                            (datum-valid-literal? (cdr datum))))
        (else (datum-atom? datum))))

(define (syntax-self-evaluating? stx)
  (and (not (syntax-pair? stx)) (not (syntax-vector? stx))
       (datum-self-evaluating? (syntax->datum stx))))

(define (bound-identifier-unique? i i*)
  (or (null? i*) (syntax-false? i)
      (and (not (bound-identifier=? i (car i*)))
           (bound-identifier-unique? i (cdr i*)))))
(define (bound-identifier-unique* i*)
  (or (null? i*) (and (or (bound-identifier-unique? (car i*) (cdr i*))
                          (error "duplicate parameter:" (car i*)))
                      (bound-identifier-unique* (cdr i*)))))
(define (syntax->~list stx)
  (cond ((syntax-null? stx) '())
        ((syntax-pair? stx)
         (cons (syntax-car stx) (syntax->~list (syntax-cdr stx))))
        (else (list stx))))
(define (formal-param* stx)
  (define s* (syntax->~list stx))
  (bound-identifier-unique* s*)
  s*)
(define (variadic-formal-param*? stx)
  (or (syntax-false? stx) (identifier? stx)
      (and (syntax-pair? stx) (variadic-formal-param*? (syntax-cdr stx)))))
(define (formal-param*->maybe-renaming* p*)
  (if (null? p*) '()
    (cons (and (not (syntax-false? (car p*)))
               (identifier->fresh-renaming (car p*)))
          (formal-param*->maybe-renaming* (cdr p*)))))

(define (build-literal datum)
  (when (not (datum-valid-literal? datum))
    (error "invalid literal datum:" datum))
  `#(quote ,datum))
(define (build-variable address) `#(var ,address))
(define (build-apply proc arg*) `#(apply ,proc ,(list->vector arg*)))

(define (build-lambda env variadic? param* trv*->body)
  (define r?* (formal-param*->maybe-renaming* param*))
  (define r* (filter renaming? r?*))
  (define label?* (map (lambda (r) (and r (renaming-label r))) r?*))
  ;; TODO: just use labels as addresses for now, but this may change.
  (define trv* (map (lambda (r) (define l (renaming-label r))
                      `(variable . (,r . ,l))) r*))
  `#(lambda ,variadic? ,(list->vector label?*) ,(trv*->body trv*)))

(define (trv*->expanded-body env form)
  (lambda (trv*)
    (define t* (map (lambda (trv) (car trv)) trv*))
    (define r* (map (lambda (trv) (cadr trv)) trv*))
    (define v* (map (lambda (trv) (cddr trv)) trv*))
    (define l* (map renaming-label r*))
    (define renamed-form (syntax-rename* form r*))
    (define tb* (map (lambda (t l v) `(,t . (,l . ,v))) t* l* v*))
      (expand (env-extend* env tb*) renamed-form)))

(define (expand env form)
  (cond ((syntax-self-evaluating? form) (build-literal (syntax->datum form)))
        ((identifier? form)
         (define b (env-ref-identifier env form))
         (cond ((b-variable? b) (build-variable (b-variable-address b)))
               ((b-keyword? b) ((b-keyword-transformer b) env form))
               (else (error "unknown binding:" b))))
        ((syntax-pair? form)
         (define head (syntax-car form))
         (define transformer (form->transformer env head))
         (if transformer (transformer env form)
           (build-apply (expand env head) (expand* env (syntax-cdr form)))))
        (else (error "invalid syntax:" form))))
(define (expand* env form*)
  (map (lambda (form) (expand env form)) (syntax->list form*)))
(define (procedure->hygienic-syntax-transformer proc)
  (lambda (env stx) (expand env (syntax-mark (proc (syntax-mark stx))))))

(define (expand-quote env form)
  ;; TODO: something more like this:
  ;; (match form (#`(,_ ,literal) (build-literal (syntax->datum literal))))
  (define sd (syntax-cdr form))
  (when (not (syntax-null? (syntax-cdr sd))) (error "invalid quote:" form))
  (build-literal (syntax->datum (syntax-car sd))))

(define (expand-lambda env form)
  (define sd (syntax-cdr form))
  (define sdd (syntax-cdr sd))
  (define sad (syntax-car sd))
  (define param* (formal-param* sad))
  (define variadic? (variadic-formal-param*? sad))
  ;; TODO: support body sequence.
  ;(define body (syntax->list sdd))
  (define body (syntax-car sdd))
  (when (not (syntax-null? (syntax-cdr sdd)))
    (error "only one body expression is currently supported:" sdd))
  (build-lambda env variadic? param* (trv*->expanded-body env body)))

(define env-initial
  (env-extend-keyword*
    env-empty
    `((quote . ,expand-quote)
      (lambda . ,expand-lambda)
      ;; TODO: (Some of these expanders can be implemented as transformers.)
      ;(if . ,expand-if)
      ;(letrec . ,expand-letrec)
      ;(letrec* . ,expand-letrec)
      ;(let . ,expand-let)
      ;(let* . ,expand-let*)
      ;(quasiquote . ,expand-quasiquote)
      ;(syntax . ,expand-syntax)
      ;(quasisyntax . ,expand-quasisyntax)
      ;(begin . ,expand-begin)
      ;(cond . ,expand-cond)
      ;(case . ,expand-case)
      ;(match . ,expand-match)
      ;(and . ,expand-and)
      ;(or . ,expand-or)
      ;(when . ,expand-when)
      ;(unless . ,expand-unless)
      ;(set! . ,expand-set!)
      ;(reset . ,expand-reset)
      ;(shift . ,expand-shift)
      ;(let-syntax . ,expand-let-syntax)
      ;(letrec-syntax . ,expand-letrec-syntax)
      ;(letrec*-syntax+values . ,expand-letrec*-syntax+values)
      ;splicing variants...
      )))
