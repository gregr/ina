;; See: https://themonadreader.files.wordpress.com/2014/04/super-final.pdf

;; P ::= ((C1 arity1) ... (Cn arityn)) d1 ... dn
;; d ::= (define (f v1 ... vn) e)
;;     | (define (g p1 v1 ... vn) e1)
;;       ...
;;       (define (g pm v1 ... vn) em)
;; e ::= v
;;     | (C e1 ... en)
;;     | (f e1 ... en)
;; p ::= (C v1 ... vn)

(define (tagged? t v) (and (pair? v) (eq? t (car v))))

(define (env prog pa*) `(env ,prog ,pa*))
(define (env-prog e) (cadr e))
(define (env-ctor* e) (program-ctor* (env-prog e)))
(define (env-fn* e) (program-def* (env-prog e)))
(define (env-pa* e) (caddr e))
(define (env-apply e param* arg*) (env (env-prog e) (bind-param* param* arg*)))
(define (env-lookup e name)
  (or (let ((arg (env-pa e name))) (and arg (list 'pa name arg)))
      (env-fn e name)
      (let ((ctor (env-ctor e name))) (and ctor (list 'ctor ctor)))))
(define (env-ctor e name)
  (let loop ((ctor* (env-ctor* e)))
    (and (pair? ctor*)
         (if (eq? name (caar ctor*)) (car ctor*) (loop (cdr ctor*))))))
(define (env-fn e name)
  (let loop ((fn* (env-fn* e)))
    (and (pair? fn*)
         (if (eq? name (fn-name (car fn*))) (car fn*) (loop (cdr fn*))))))
(define (env-pa e name)
  (let loop ((pa* (env-pa* e)))
    (and (pair? pa*)
         (if (eq? name (caar pa*)) (cadar pa*) (loop (cdr pa*))))))

(define (bind-param* param* arg*)
  (cond
    ((and (null? param*) (null? arg*)) '())
    ((and (pair? param*) (pair? arg*))
     (cons `(,(car param*) ,(car arg*)) (bind-param* (cdr param*) (cdr arg*))))
    (else (error 'bind-param* (format "invalid binding: ~s ~s" param* arg*)))))

(define (program ctor* def*) `(program ,ctor* ,def*))
(define (program? v) (tagged? 'program v))
(define (program-ctor* p) (cadr p))
(define (program-def* p) (caddr p))

(define (fn-indifferent name param* body) `(fn-i ,name ,param* ,body))
(define (fn-indifferent? v) (tagged? 'fn-i v))
(define (fn-indifferent-name fn) (cadr fn))
(define (fn-indifferent-param* fn) (caddr fn))
(define (fn-indifferent-body fn) (cadddr fn))

(define (fn-curious name clause*) `(fn-c ,name ,clause*))
(define (fn-curious? v) (tagged? 'fn-c v))
(define (fn-curious-name fn) (cadr fn))
(define (fn-curious-clause* fn) (caddr fn))
(define (fn-curious-extend fn clause*)
  (fn-curious (fn-curious-name fn) (append clause* (fn-curious-clause* fn))))

(define (fn-name fn)
  (or (and (fn-indifferent? fn) (fn-indifferent-name fn))
      (and (fn-curious? fn) (fn-curious-name fn))))

(define (p-clause pattern param* body) `(p-clause ,pattern ,param* ,body))
(define (p-clause? v) (tagged? 'p-clause v))
(define (p-clause-pattern c) (cadr c))
(define (p-clause-param* c) (caddr c))
(define (p-clause-body c) (cadddr c))

(define (e-cons c ea*) `(e-cons ,c ,ea*))
(define (e-cons? v) (tagged? 'e-cons v))
(define (e-cons-c e) (cadr e))
(define (e-cons-ea* e) (caddr e))
(define (e-app f ea*) `(e-app ,f ,ea*))
(define (e-app? v) (tagged? 'e-app v))
(define (e-app-f e) (cadr e))
(define (e-app-ea* e) (caddr e))
(define (e-var name) `(e-var ,name))
(define (e-var? v) (tagged? 'e-var v))
(define (e-var-name e) (cadr e))

(define (pattern c n*) `(pattern ,c ,n*))
(define (pattern? v) (tagged? 'pattern v))
(define (pattern-ctor p) (cadr p))
(define (pattern-param* p) (caddr p))
