(load "eval-k.scm")
(load "js.scm")

;; TODO: strings and other types, once supported by evalo-fo.
(define (compile-atom atom)
  (cond ((null? atom) 'null)
        ((symbol? atom) (symbol->string atom))
        ((or (boolean? atom) (number? atom)) atom)))

(define js-false (compile-atom #f))
(define js-nil (compile-atom '()))
(define js-t-pair (compile-atom 'pair))
(define js-t-vector (compile-atom 'vector))
(define js-t-closure (compile-atom 'closure))
(define (js-cons h t) `(array ,js-t-pair (array ,h ,t)))
(define (js-car ref) `(get (get ,ref 1) 0))
(define (js-cdr ref) `(get (get ,ref 1) 1))
(define (js-vector-from-array arr) `(array ,js-t-vector ,arr))
(define (js-vector args) (js-vector-from-array `(array ,@args)))
(define (js-vector-ref ref idx) `(get (get ,ref 1) ,idx))
(define (js-vector-length ref) `(get (get ,ref 1) "length"))
(define (js-closure env k) `(array ,js-t-closure ,env ,k))
(define (js-closure-env ref) `(get ,ref 1))
(define (js-closure-k ref) `(get ,ref 2))
(define (js-null? v) `(=== ,js-nil ,v))
(define (js-pair? v)
  `(land (land (=== "object" (typeof ,v)) (!== ,js-nil ,v))
         (=== ,js-t-pair (get ,v 0))))
(define (js-vector? v)
  `(land (land (=== "object" (typeof ,v)) (!== ,js-nil ,v))
         (=== ,js-t-vector (get ,v 0))))
(define (js-procedure? v)
  `(land (land (=== "object" (typeof ,v)) (!== ,js-nil ,v))
         (=== ,js-t-closure (get ,v 0))))
(define (js-symbol? v) `(=== "string" (typeof ,v)))
(define (js-number? v) `(=== "number" (typeof ,v)))

(define (js-context env)
  `(object ("result" ,js-false) ("regs" ,js-false)
           ("args" ,js-nil) ("env" ,env) ("returns" (array))))
(define js-context-empty (js-context js-nil))
(define (js-context-result c) `(get ,c "result"))
(define (js-context-result-set c v) `((put (get ,c "result") ,v)))
(define (js-context-reg c i) `(get (get ,c "regs") ,i))
(define (js-context-reg-set c i v) `((put (get (get ,c "regs") ,i) ,v)))
(define (js-context-regs-clear c n)
  `((vars (regs (array)))
    (put (get regs "length") ,n)
    (put (get ,c "regs") regs)))
(define (js-context-args c) `(get ,c "args"))
(define (js-context-args-set c args) `((put (get ,c "args") ,args)))
(define (js-context-env c) `(get ,c "env"))
(define (js-context-return-pop c)
  `((vars (rs (get ,c "returns"))
          (i (get rs "length"))
          (k (get rs (prefix-- i)))
          (regs (get rs (prefix-- i)))
          (args (get rs (prefix-- i)))
          (env (get rs (prefix-- i))))
    (put (get rs "length") i)
    (put (get ,c "regs") regs)
    (put (get ,c "args") args)
    (put (get ,c "env") env)
    (return k)))
(define (js-context-returns-push c k)
  `((vars (rs (get ,c "returns")))
    (put+ (get rs "length") 4)
    (vars (i (get rs "length")))
    (put (get rs (prefix-- i)) ,k)
    (put (get rs (prefix-- i)) (get ,c "regs"))
    (put (get rs (prefix-- i)) (get ,c "args"))
    (put (get rs (prefix-- i)) (get ,c "env"))))
(define (js-context-apply context proc)
  `((vars (proc ,proc))
    (put (get ,context "env")
         ,(js-cons (js-context-args context) (js-closure-env 'proc)))
    (return ,(js-closure-k 'proc))))

(define (js-let bindings body)
  `(app (function ,(map car bindings) ,body) ,(map cadr bindings)))
(define (list->js-list xs) (list-foldr js-cons js-nil xs))

(define (compile-pair h t) (js-cons (compile-literal h) (compile-literal t)))
(define (compile-vector vec)
  (js-vector (map compile-literal (vector->list vec))))
(define (compile-closure clo)
  (js-closure (compile-env (cadr clo)) (compile-k (cadddr clo))))
(define (compile-env env)
  (list->js-list
    (map (lambda (frame)
           (list->js-list (map compile-literal (frame-value* frame)))) env)))
(define (compile-literal datum)
  (cond ((pair? datum) (compile-pair (car datum) (cdr datum)))
        ((vector-fo? datum) (compile-vector (tagged-payload datum)))
        ((procedure-fo? datum) (compile-closure (tagged-payload datum)))
        ((or (null? datum) (symbol? datum) (boolean? datum) (number? datum))
         (compile-atom datum))
        (else (error 'compile-literal (format "invalid literal ~s" datum)))))

(define (compile-env-ref address context)
  (define fi (address-fi address))
  (let loop ((ref (js-context-env context)) (ei (address-eidx address)))
    (if (= 0 ei)
      (let floop ((ref (js-car ref)) (fpos (frame-info-idx fi)))
        (if (= 0 fpos)
          (if (frame-info-single? fi) (js-car ref) ref)
          (floop (js-cdr ref) (- fpos 1))))
      (loop (js-cdr ref) (- ei 1)))))

(define (compile-primitive name args)
  (define (check-argc n)
    (when (not (= n (length args)))
      (error 'compile-primitive
             (format "invalid number of arguments to ~s: expected ~s, given ~s"
                     name n (length args)))))
  (case name
    ((cons) (check-argc 2) (js-cons (car args) (cadr args)))
    ((car) (check-argc 1) (js-car (car args)))
    ((cdr) (check-argc 1) (js-cdr (car args)))
    ((list->vector)
     (check-argc 1)
     (js-vector-from-array
       (js-let '() `((vars (result (array)) (xs ,(car args)))
                     (while (!== ,js-nil xs)
                            ((app (get result "push") (,(js-car 'xs)))
                             (put xs ,(js-cdr 'xs))))
                     (return result)))))
    ((vector) (js-vector args))
    ((vector-length) (check-argc 1) (js-vector-length (car args)))
    ((vector-ref) (check-argc 2) (js-vector-ref (car args) (cadr args)))
    ((vector?) (check-argc 1) (js-vector? (car args)))
    ((null?) (check-argc 1) (js-null? (car args)))
    ((pair?) (check-argc 1) (js-pair? (car args)))
    ((symbol?) (check-argc 1) (js-symbol? (car args)))
    ((number?) (check-argc 1) (js-number? (car args)))
    ((procedure?) (check-argc 1) (js-procedure? (car args)))
    ((= boolean=? symbol=?) (check-argc 2) `(=== ,(car args) ,(cadr args)))
    (else (error 'compile-primitive (format "invalid primitive ~s" name)))))

(define (compile-immediate expr context)
  (case (car expr)
    ((literal) (compile-literal (cadr expr)))
    ((reference) (compile-env-ref (cadr expr) context))
    ((register) (js-context-reg context (cadr expr)))
    ((lambda) (js-closure (js-context-env context) (compile-k (caddr expr))))
    ((primitive) (compile-primitive
                   (cadr expr) (map (lambda (e) (compile-immediate e context))
                                    (caddr expr))))
    (else (error 'compile-immediate
                 (format "invalid immediate exression ~s" expr)))))

(define (compile-k k) `(function (context) ,(compile-k* k 'context)))
(define (compile-k* k context)
  (case (car k)
    ((k-immediate)
     (append (js-context-result-set
               context (compile-immediate (cadr k) context))
             (compile-k* (caddr k) context)))
    ((k-register-put)
     (append (js-context-reg-set context (cadr k) (js-context-result context))
             (compile-k* (caddr k) context)))
    ((k-registers-clear) (append (js-context-regs-clear context (cadr k))
                                 (compile-k* (caddr k) context)))
    ((k-args-push)
     (append (js-context-args-set context (js-cons (js-context-result context)
                                                   (js-context-args context)))
             (compile-k* (cadr k) context)))
    ((k-args-push*)
     (append (js-context-args-set context (js-context-result context))
             (compile-k* (cadr k) context)))
    ((k-args-clear) (append (js-context-args-set context js-nil)
                            (compile-k* (cadr k) context)))
    ((k-return-push)
     (append (js-context-returns-push context (compile-k (caddr k)))
             (compile-k* (cadr k) context)))
    ((k-return-pop) (js-context-return-pop context))
    ((k-apply) (js-context-apply context (js-context-result context)))
    ((k-branch) `((if/else (!== ,js-false ,(js-context-result context))
                           ,(compile-k* (cadr k) context)
                           ,(compile-k* (caddr k) context))))
    ;; TODO: fix exponential blowup with k sharing.
    ((k-join) (compile-k* (cadr k) context))
    ((k-halt) `((return ,js-false)))
    (else (error 'compile-k* (format "invalid k ~s" k)))))

(define (js-run context jsk)
  (js-let '() `((vars (context ,context) (k ,jsk))
                (while (!== ,js-false k) ((put k (app k (context)))))
                (return ,(js-context-result 'context)))))

(define (expr->jsk expr env) (compile-k (direct->k k-halt (denote expr env))))
(define (compile expr env)
  (js-run (js-context (compile-env env)) (expr->jsk expr env)))
(define (compile-js expr env) (js-expr (compile expr env)))
