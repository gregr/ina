#lang racket/base
(provide
  ;; TODO:
  )
(require
  "syntax-new.rkt"
  "type.rkt"
  racket/match
  )

(define-variant-type
  pat?
  (pat-exist pat-exist? pat-exist-ids pat-exist-p)
  (pat-any pat-any?)
  (pat-var pat-var? pat-var-id)
  (pat-literal pat-literal? pat-literal-datum)

  (pat-cons pat-cons? pat-cons-car pat-cons-cdr)
  (pat-segment
    pat-segment? pat-segment-min-length pat-segment-p pat-segment-cdr)
  (pat-vector pat-vector? pat-vector-lp)
  (pat-syntax pat-syntax? pat-syntax-vlp)

  (pat-and pat-and? pat-and-c1 pat-and-c2)
  (pat-or pat-or? pat-or-d1 pat-or-d2)
  (pat-not pat-not? pat-not-p)

  (pat-? pat-?? pat-?-predicate)
  (pat-app pat-app? pat-app-transformer pat-app-p)
  )

(define id-set-empty '())
(define (set x) (list x))
(define (id-set-empty? s) (null? s))
(define (id-set-member? ys x) (ormap (lambda (y) (free-identifier=? x y)) ys))
(define (id-set-union a b)
  (define (id-set-add x ys) (if (id-set-member? ys x) ys (cons x ys)))
  (foldl id-set-add b a))
(define (id-set-subtract a b)
  (define (id-set-add x ys) (if (id-set-member? b x) ys (cons x ys)))
  (foldl id-set-add '() a))
(define (list->set xs) (id-set-union xs '()))

(define (bound-pattern-ids pat)
  (cond
    ((pat-exist? pat)
     (id-set-subtract (bound-pattern-ids (pat-exist-p pat)) (pat-exist-ids pat)))
    ((pat-var? pat) (set (pat-var-id pat)))
    ((pat-and? pat)     (id-set-union (bound-pattern-ids (pat-and-c1 pat))
                                   (bound-pattern-ids (pat-and-c2 pat))))
    ((pat-or? pat)      (id-set-union (bound-pattern-ids (pat-or-d1 pat))
                                   (bound-pattern-ids (pat-or-d2 pat))))
    ((pat-cons? pat)    (id-set-union (bound-pattern-ids (pat-cons-car pat))
                                   (bound-pattern-ids (pat-cons-cdr pat))))
    ((pat-segment? pat) (id-set-union (bound-pattern-ids (pat-segment-p pat))
                                   (bound-pattern-ids (pat-segment-cdr pat))))
    ((pat-vector? pat)  (bound-pattern-ids (pat-vector-lp pat)))
    ((pat-syntax? pat)  (bound-pattern-ids (pat-syntax-vlp pat)))
    ((pat-app? pat)     (bound-pattern-ids (pat-app-p pat)))
    (else id-set-empty)))

(define (leaky-pattern-ids pat)
  (cond
    ((pat-exist? pat)
     (id-set-subtract (leaky-pattern-ids (pat-exist-p pat)) (pat-exist-ids pat)))
    ((pat-and? pat)
     (define l1 (leaky-pattern-ids (pat-and-c1 pat)))
     (define l2 (leaky-pattern-ids (pat-and-c2 pat)))
     (define g1 (id-set-subtract (bound-pattern-ids (pat-and-c1 pat)) l1))
     (define g2 (id-set-subtract (bound-pattern-ids (pat-and-c2 pat)) l2))
     (id-set-union (id-set-subtract l1 g2) (id-set-subtract l2 g1)))
    ((pat-or? pat)
     (define l1 (leaky-pattern-ids (pat-or-d1 pat)))
     (define l2 (leaky-pattern-ids (pat-or-d2 pat)))
     (define b1 (bound-pattern-ids (pat-or-d1 pat)))
     (define b2 (bound-pattern-ids (pat-or-d2 pat)))
     (id-set-union l1 (id-set-union l2 (id-set-union (id-set-subtract b1 b2)
                                            (id-set-subtract b2 b1)))))
    ((pat-cons? pat)
     (define l1 (leaky-pattern-ids (pat-cons-car pat)))
     (define l2 (leaky-pattern-ids (pat-cons-cdr pat)))
     (define g1 (id-set-subtract (bound-pattern-ids (pat-cons-car pat)) l1))
     (define g2 (id-set-subtract (bound-pattern-ids (pat-cons-cdr pat)) l2))
     (id-set-union (id-set-subtract l1 g2) (id-set-subtract l2 g1)))
    ((pat-segment? pat)
     (define l1 (leaky-pattern-ids (pat-segment-p pat)))
     (define l2 (leaky-pattern-ids (pat-segment-cdr pat)))
     (define g1 (id-set-subtract (bound-pattern-ids (pat-segment-p pat)) l1))
     (define g2 (id-set-subtract (bound-pattern-ids (pat-segment-cdr pat)) l2))
     (id-set-union (id-set-subtract l1 g2) (id-set-subtract l2 g1)))
    ((pat-vector? pat) (leaky-pattern-ids (pat-vector-lp pat)))
    ((pat-syntax? pat) (leaky-pattern-ids (pat-syntax-vlp pat)))
    ((pat-app? pat)    (leaky-pattern-ids (pat-app-p pat)))
    (else id-set-empty)))

(define (scopify-pat pat)
  (define (scopify pat bound)
    (cond
      ((pat-exist? pat)
       (pat-exist (pat-exist-ids pat)
                  (scopify (pat-exist-p pat)
                           (id-set-union bound (pat-exist-ids pat)))))
      ((pat-not? pat)
       (define nbound (id-set-subtract (bound-pattern-ids (pat-not-p pat)) bound))
       (define inner (scopify (pat-not-p pat) (id-set-union nbound bound)))
       (pat-not (if (id-set-empty? nbound) inner (pat-exist nbound inner))))
      ((pat-and? pat)    (pat-and (scopify (pat-and-c1 pat) bound)
                                  (scopify (pat-and-c2 pat) bound)))
      ((pat-or? pat)     (pat-or (scopify (pat-or-d1 pat) bound)
                                 (scopify (pat-or-d2 pat) bound)))
      ((pat-cons? pat)   (pat-cons (scopify (pat-cons-car pat) bound)
                                   (scopify (pat-cons-cdr pat) bound)))
      ((pat-cons? pat)   (pat-segment (pat-segment-min-length pat)
                                      (scopify (pat-segment-p pat) bound)
                                      (scopify (pat-segment-cdr pat) bound)))
      ((pat-vector? pat) (pat-vector (scopify (pat-vector-lp pat) bound)))
      ((pat-syntax? pat) (pat-syntax (scopify (pat-syntax-vlp pat) bound)))
      ((pat-app? pat)    (pat-app (pat-app-transformer pat)
                                  (scopify (pat-app-p pat) bound)))
      (else pat)))
  (scopify pat (bound-pattern-ids pat)))

(define (simplify-pat pat)
  (cond
    ((pat-exist? pat)
     (pat-exist (pat-exist-ids pat) (simplify-pat (pat-exist-p pat))))
    ((pat-and? pat)
     (pat-and (simplify-pat (pat-and-c1 pat)) (simplify-pat (pat-and-c2 pat))))
    ((pat-or? pat)
     (pat-or (simplify-pat (pat-or-d1 pat)) (simplify-pat (pat-or-d2 pat))))
    ((pat-not? pat) (pat-not (simplify-pat (pat-not-p pat))))
    ((pat-cons? pat)
     (define pcar (simplify-pat (pat-cons-car pat)))
     (define pcdr (simplify-pat (pat-cons-cdr pat)))
     (if (and (pat-literal? pcar) (pat-literal? pcdr))
       (pat-literal (cons (pat-literal-datum pcar) (pat-literal-datum pcdr)))
       (pat-cons pcar pcdr)))
    ((pat-segment? pat) (pat-segment (pat-segment-min-length pat)
                                     (simplify-pat (pat-segment-p pat))
                                     (simplify-pat (pat-segment-cdr pat))))
    ((pat-vector? pat)
     (define lp (simplify-pat (pat-vector-lp pat)))
     (if (pat-literal? lp)
       (pat-literal (list->vector (pat-literal-datum lp)))
       (pat-vector lp)))
    ((pat-syntax? pat)
     (define vlp (simplify-pat (pat-syntax-vlp pat)))
     (if (pat-literal? vlp)
       (let ((datum (pat-literal-datum vlp)))
         (pat-literal
           (if (syntax-new? datum) datum (datum->syntax-new #f datum))))
       (pat-syntax vlp)))
    ((pat-app? pat)
     (pat-app (pat-app-transformer pat) (simplify-pat (pat-app-p pat))))
    (else pat)))

(define (syntax->pat stx)
  (define (non-null-atom? datum)
    (or (eq? #t datum)
        (not datum)
        (char? datum)
        (string? datum)
        (number? datum)))

  (define (k-or-more? id)
    (define (valid-k? k-chars)
      (define k (and (andmap char-numeric? k-chars)
                     (string->number (list->string k-chars))))
      (and (integer? k) (<= 0 k) k))
    (and (identifier? id)
         (match (string->list (symbol->string (syntax->datum id)))
           ((list #\. #\. k ...) #:when (valid-k? k) (valid-k? k))
           ((list #\_ #\_ k ...) #:when (valid-k? k) (valid-k? k))
           (_ #f))))

  (define-syntax define-quasi->pat
    (syntax-rules ()
      ((_ qq-syntax->pat quasiqu qu unqu unqu-splicing)
       (define (qq-syntax->pat stx)
         (syntax-case stx (list qu unqu unqu-splicing)
           ((unqu p) (syntax->pat #'p))
           (((unqu-splicing (list p (... ...))) . qq)
            (syntax->pat #'(list* p (... ...) (quasiqu qq))))
           (((unqu-splicing (qu (d (... ...)))) . qq)
            (syntax->pat #'((unqu-splicing (list (qu d) (... ...))) . qq)))
           (((unqu-splicing p) . qq)
            (identifier? #'p)
            (syntax->pat #'(list* p ___ (quasiqu qq))))
           ((a . d)
            (not (and (identifier? #'a)
                      (or (free-identifier=? #'unqu #'a)
                          (free-identifier=? #'unqu-splicing #'a))))
            (syntax->pat #'(list* (quasiqu a) (quasiqu d))))
           (#(p (... ...)) (pat-vector (qq-syntax->pat #'(p (... ...)))))
           (datum (syntax->pat #'(qu datum))))))))

  (define-quasi->pat
    qq-syntax->pat quasiquote quote unquote unquote-splicing)
  (define-quasi->pat
    qs-syntax->pat quasisyntax syntax unsyntax unsyntax-splicing)

  (syntax-case stx (var exist ___
                        and or not ? app
                        cons list list* vector
                        quote quasiquote syntax quasisyntax)
    (_ (and (identifier? stx) (free-identifier=? #'_ stx)) pat-any)
    (id (identifier? #'id) (pat-var #'id))
    ((var id) (identifier? #'id) (pat-var #'id))
    ((exist (id ...) pat ...)
     (andmap identifier? (syntax->list #'(id ...)))
     (pat-exist (list->set (syntax->list #'(id ...)))
                (syntax->pat #'(and pat ...))))

    ((list* p) (syntax->pat #'p))
    ((list* p0 ooo p ...)
     (and (identifier? #'ooo) (or (free-identifier=? #'ooo #'___)
                                  (free-identifier=? #'ooo #'(... ...))))
     (pat-segment 0 (syntax->pat #'p0) (syntax->pat #'(list* p ...))))
    ((list* p0 __k p ...)
     (k-or-more? #'__k)
     (pat-segment (k-or-more? #'__k) (syntax->pat #'p0)
                  (syntax->pat #'(list* p ...))))
    ((list* p0 p ...) (pat-cons (syntax->pat #'p0) (syntax->pat #'(list* p ...))))

    ((cons a d) (syntax->pat #'(list* a d)))
    ((list p ...) (syntax->pat #'(list* p ... '())))
    ((vector p ...) (pat-vector (syntax->pat #'(list p ...))))

    ((and p) (syntax->pat #'p))
    ((and p0 p ...) (pat-and (syntax->pat #'p0) (syntax->pat #'(and p ...))))
    ((or p) (syntax->pat #'p))
    ((or p0 p ...) (pat-or (syntax->pat #'p0) (syntax->pat #'(or p ...))))

    ((not p) (pat-not (syntax->pat #'p)))
    ((not p ...) (syntax->pat #'(not (or p ...))))

    ((? predicate) (pat-? #'predicate))
    ((? predicate p ...) (syntax->pat #'(and (? predicate) p ...)))
    ((app transformer p ...)
     (pat-app #'transformer (syntax->pat #'(and p ...))))

    ((quasiquote qq) (qq-syntax->pat #'qq))
    ((quasisyntax qs) (pat-syntax (qs-syntax->pat #'qs)))

    ((syntax datum) (pat-literal (racket-syntax->syntax-new #'datum)))
    ((quote datum) (pat-literal (syntax->datum #'datum)))
    (atom (non-null-atom? (syntax->datum #'atom))
          (pat-literal (syntax->datum #'atom)))))

;; TODO: named match for simple catamorphisms
