(load "common.scm")

(define (tagged tag datum) (vector tag datum))
(define (tagged? tag datum)
  (and (vector? datum)
       (= 2 (vector-length datum))
       (eqv? tag (vector-ref datum 0))))
(define (tagged-payload datum) (vector-ref datum 1))

(define procedure-tag 'procedure)
(define (procedure-fo proc) (tagged procedure-tag proc))
(define (procedure-fo? datum) (tagged? procedure-tag datum))

(define (primitive name) (procedure-fo name))

(define (denote-reference env addr name) `(reference ,addr ,name))
(define (denote-literal value) `(literal ,value))
(define (denote-pair da dd)
  `(application ,(denote-literal (primitive 'cons)) (,da ,dd)))
(define (denote-procedure body params env)
  (let ((dbody (denote body (env-extend* env params params))))
    `(lambda ,params ,dbody)))
(define (denote-application dproc dargs)
  `(application ,dproc ,dargs))
(define (denote-if dc tdt tdf) `(if ,dc ,(tdt) ,(tdf)))

(define (apply-fo proc args)
  (define (err) (error 'apply-fo (format "invalid procedure ~s" proc)))
  (if (procedure-fo? proc)
    (let ((proc (tagged-payload proc)))
      (cond
        ((symbol? proc)
         (case proc
           ((cons) (apply cons args))
           ((car)
            (if (= 1 (length args))
              (if (pair? (car args))
                (caar args)
                (error 'apply-fo-car (format "car expects a pair ~s" (car args))))
              (error 'apply-fo-car (format "car expects 1 argument ~s" args))))
           ((cdr)
            (if (= 1 (length args))
              (if (pair? (car args))
                (cdar args)
                (error 'apply-fo-cdr (format "cdr expects a pair ~s" (car args))))
              (error 'apply-fo-cdr (format "cdr expects 1 argument ~s" args))))
           ((not) (apply not args))
           ((equal?) (apply equal? args))
           ((pair?)
            (if (= 1 (length args))
              (pair? (car args))
              (error 'apply-fo-pair?
                     (format "pair? expects 1 argument ~s" args))))
           ((symbol?) (apply symbol? args))
           ((number?) (apply number? args))
           ((procedure?)
            (if (= 1 (length args))
              (procedure-fo? (car args))
              (error 'apply-procedure-fo?
                     (format "procedure? expects 1 argument ~s" args))))
           ((apply) (apply apply-fo args))
           (else (err))))
        ((and (pair? proc) (eq? 'closure (car proc)))
         (evaluate-fo (caddr (cdr proc))
                      (env-extend* (cadr proc) (caddr proc) args)))
        (else (err))))
    (err)))

(define (evaluate-fo expr env)
  (case (car expr)
    ((literal) (cadr expr))
    ((reference) (env-ref env (cadr expr)))
    ((application)
     (apply-fo
       (evaluate-fo (cadr expr) env)
       (map (lambda (arg) (evaluate-fo arg env)) (caddr expr))))
    ((if)
     (if (evaluate-fo (cadr expr) env)
       (evaluate-fo (caddr expr) env)
       (evaluate-fo (cadddr expr) env)))
    ((lambda) (procedure-fo `(closure ,env ,(cadr expr) ,(caddr expr))))
    (else (error 'evaluate-fo (format "invalid expression ~s" expr)))))

(define env-initial
  (env-extend-bindings
    env-empty
    `((cons . ,(primitive 'cons))
      (car . ,(primitive 'car))
      (cdr . ,(primitive 'cdr))
      (not . ,(primitive 'not))
      (equal? . ,(primitive 'equal?))
      (pair? . ,(primitive 'pair?))
      (symbol? . ,(primitive 'symbol?))
      (number? . ,(primitive 'number?))
      (procedure? . ,(primitive 'procedure?))
      (apply . ,(primitive 'apply)))))

(define (evaluate expr env) (evaluate-fo (denote expr env) env))
