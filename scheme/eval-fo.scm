(load "common.scm")

(define (tagged tag datum) (vector tag datum))
(define (tagged? tag datum)
  (and (vector? datum)
       (= 2 (vector-length datum))
       (eqv? tag (vector-ref datum 0))))
(define (tagged-payload datum) (vector-ref datum 1))

(define procedure-tag 'procedure)
(define (procedure-fo proc) (tagged procedure-tag proc))
(define (procedure-fo? datum) (tagged? procedure-tag datum))

(define (primitive name) (procedure-fo name))

(define (denote-reference env addr name) `(reference ,addr ,name))
(define (denote-literal value) `(literal ,value))
(define (denote-pair da dd)
  `(application ,(denote-literal (primitive 'cons)) (,da ,dd)))
(define (denote-procedure body params env)
  (let ((dbody (denote body (env-extend* env params params))))
    `(lambda ,params ,dbody)))
(define (denote-application dproc dargs)
  `(application ,dproc ,dargs))
(define (denote-if dc tdt tdf) `(if ,dc ,(tdt) ,(tdf)))

(define (apply-primitive pname args)
  (case pname
    ((cons) (apply cons args))
    ((car) (apply car args))
    ((cdr) (apply cdr args))
    ((not) (apply not args))
    ((equal?) (apply equal? args))
    ((pair?) (apply pair? args))
    ((symbol?) (apply symbol? args))
    ((number?) (apply number? args))
    ((procedure?)
     (if (= 1 (length args))
       (procedure-fo? (car args))
       (error 'apply-procedure-fo?
              (format "procedure? expects 1 argument ~s" args))))
    ((apply) (apply apply-fo args))
    (else (error 'apply-primitive (format "invalid primitive ~s" proc)))))

(define (apply-fo proc args)
  (define (err) (error 'apply-fo (format "invalid procedure ~s" proc)))
  (if (procedure-fo? proc)
    (let ((proc (tagged-payload proc)))
      (cond
        ((symbol? proc) (apply-primitive proc args))
        ((and (pair? proc) (eq? 'closure (car proc)))
         (evaluate-fo (caddr (cdr proc))
                      (env-extend* (cadr proc) (caddr proc) args)))
        (else (err))))
    (err)))

(define (evaluate-fo expr env)
  (case (car expr)
    ((literal) (cadr expr))
    ((reference) (env-ref env (cadr expr)))
    ((application)
     (apply-fo
       (evaluate-fo (cadr expr) env)
       (map (lambda (arg) (evaluate-fo arg env)) (caddr expr))))
    ((if)
     (if (evaluate-fo (cadr expr) env)
       (evaluate-fo (caddr expr) env)
       (evaluate-fo (cadddr expr) env)))
    ((lambda) (procedure-fo `(closure ,env ,(cadr expr) ,(caddr expr))))
    (else (error 'evaluate-fo (format "invalid expression ~s" expr)))))

(define env-initial
  (env-extend-bindings
    env-empty
    `((cons . ,(primitive 'cons))
      (car . ,(primitive 'car))
      (cdr . ,(primitive 'cdr))
      (not . ,(primitive 'not))
      (equal? . ,(primitive 'equal?))
      (pair? . ,(primitive 'pair?))
      (symbol? . ,(primitive 'symbol?))
      (number? . ,(primitive 'number?))
      (procedure? . ,(primitive 'procedure?))
      (apply . ,(primitive 'apply)))))

(define (evaluate expr env) (evaluate-fo (denote expr env) env))
