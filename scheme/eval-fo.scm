(load "common.scm")

(define (tagged tag datum) (vector tag datum))
(define (tagged? tag datum)
  (and (vector? datum)
       (= 2 (vector-length datum))
       (eqv? tag (vector-ref datum 0))))
(define (tagged-payload datum) (vector-ref datum 1))

(define procedure-tag 'procedure)
(define (procedure-fo proc) (tagged procedure-tag proc))
(define (procedure-fo? datum) (tagged? procedure-tag datum))

(define (closure env param* body) `(closure ,env ,param* ,body))
(define (closure? datum) (and (pair? datum) (eq? 'closure (car datum))))

(define (primitive name a*) `(primitive ,name ,a*))
(define (primitive-closure name param* arg*)
  (define penv (env-extend-param* env-empty param*))
  (procedure-fo
    (closure env-empty param*
             (primitive name (map (lambda (a) (denote a penv)) arg*)))))

(define vector-tag 'vector)
(define (vector-fo vec) (tagged vector-tag vec))
(define (vector-fo? datum) (tagged? vector-tag datum))
(define (vector-fo-length v)
  (if (vector-fo? v)
    (vector-length (tagged-payload v))
    (error 'vector-fo-length
           (format "expected a vector ~s" v))))
(define (vector-fo-ref v i)
  (if (vector-fo? v)
    (vector-ref (tagged-payload v) i)
    (error 'vector-fo-ref
           (format "expected first argument to be a vector ~s" v))))
(define (vector-reify vfo)
  (if (vector-fo? vfo)
    (tagged-payload vfo)
    (error 'vector-reify (format "invalid vector ~s" vfo))))

(define (denote-reference env addr name) `(reference ,addr ,name))
(define (denote-literal value) `(literal ,value))
(define (denote-vector ds) `(primitive vector ,ds))
(define (denote-pair da dd) `(primitive cons (,da ,dd)))
(define (denote-procedure pdbody params env)
  (let ((dbody (pdbody (env-extend-param* env params))))
    `(lambda ,params ,dbody)))
(define (denote-application dproc dargs)
  `(application ,dproc ,dargs))
(define (denote-if dc tdt tdf) `(if ,dc ,(tdt) ,(tdf)))

(define (apply-primitive-fo pname args)
  (case pname
    ((cons) (apply cons args))
    ((car) (apply car args))
    ((cdr) (apply cdr args))
    ((=) (apply = args))
    ((boolean=?) (apply boolean=? args))
    ((symbol=?) (apply symbol=? args))
    ((null?) (apply null? args))
    ((pair?) (apply pair? args))
    ((symbol?) (apply symbol? args))
    ((number?) (apply number? args))
    ((procedure?)
     (if (= 1 (length args))
       (procedure-fo? (car args))
       (error 'apply-procedure-fo?
              (format "procedure? expects 1 argument ~s" args))))
    ((apply) (apply apply-fo args))
    ((list->vector) (vector-fo (apply list->vector args)))
    ((vector) (vector-fo (apply vector args)))
    ((vector?) (apply vector-fo? args))
    ((vector-length) (apply vector-fo-length args))
    ((vector-ref) (apply vector-fo-ref args))
    (else (error 'apply-primitive (format "invalid primitive ~s" pname)))))

(define (apply-fo proc args)
  (define (err) (error 'apply-fo (format "invalid procedure ~s" proc)))
  (if (procedure-fo? proc)
    (let ((proc (tagged-payload proc)))
      (if (closure? proc)
        (evaluate-fo (caddr (cdr proc))
                     (env-extend* (cadr proc) (caddr proc) args))
        (err)))
    (err)))

(define (evaluate-fo expr env)
  (case (car expr)
    ((literal) (cadr expr))
    ((reference) (env-ref env (cadr expr)))
    ((primitive)
     (apply-primitive-fo
       (cadr expr) (map (lambda (arg) (evaluate-fo arg env)) (caddr expr))))
    ((application)
     (apply-fo
       (evaluate-fo (cadr expr) env)
       (map (lambda (arg) (evaluate-fo arg env)) (caddr expr))))
    ((if)
     (if (evaluate-fo (cadr expr) env)
       (evaluate-fo (caddr expr) env)
       (evaluate-fo (cadddr expr) env)))
    ((lambda) (procedure-fo (closure env (cadr expr) (caddr expr))))
    (else (error 'evaluate-fo (format "invalid expression ~s" expr)))))

(define (evaluate expr env) (evaluate-fo (denote expr env) env))

(define env-initial
  (env-extend-bindings
    env-empty
    `((cons . ,(primitive-closure 'cons '(a d) '(a d)))
      (car . ,(primitive-closure 'car '(p) '(p)))
      (cdr . ,(primitive-closure 'cdr '(p) '(p)))
      (= . ,(primitive-closure '= '(x y) '(x y)))
      (boolean=? . ,(primitive-closure 'boolean=? '(x y) '(x y)))
      (symbol=? . ,(primitive-closure 'symbol=? '(x y) '(x y)))
      (null? . ,(primitive-closure 'null? '(v) '(v)))
      (pair? . ,(primitive-closure 'pair? '(v) '(v)))
      (symbol? . ,(primitive-closure 'symbol? '(v) '(v)))
      (number? . ,(primitive-closure 'number? '(v) '(v)))
      (procedure? . ,(primitive-closure 'procedure? '(v) '(v)))
      (vector? . ,(primitive-closure 'vector? '(v) '(v)))
      (list->vector . ,(primitive-closure 'list->vector '(x*) '(x*)))
      (vector . ,(primitive-closure 'list->vector 'x* '(x*)))
      (vector-length . ,(primitive-closure 'vector-length '(v) '(v)))
      (vector-ref . ,(primitive-closure 'vector-ref '(v i) '(v i)))
      (apply . ,(primitive-closure 'apply '(p a*) '(p a*))))))
