(load "common.scm")

(define (denote-reference env idx name) `(reference ,idx ,name))
(define (denote-literal value) `(literal ,value))
(define (denote-pair da dd)
  `(application ,(denote-literal `(,procedure-tag cons)) (,da ,dd)))
(define (denote-procedure body params env)
  (let ((dbody (denote body (env-extend* env params params))))
    `(lambda ,params ,dbody)))
(define (denote-application dproc args env)
  (let ((dargs (map (lambda (arg) (denote arg env)) args)))
    `(application ,dproc ,dargs)))
(define (denote-if dc tdt tdf) `(if ,dc ,(tdt) ,(tdf)))

(define procedure-tag (gensym "#%procedure"))

(define (apply-fo proc args)
  (define (real-pair? datum)
    (and (pair? datum) (not (eq? procedure-tag (car datum)))))
  (define (real-procedure? datum)
    (and (pair? datum) (eq? procedure-tag (car datum))))
  (if (real-procedure? proc)
    (case (cadr proc)
      ((cons) (apply cons args))
      ((car)
       (if (= 1 (length args))
         (if (real-pair? (car args))
           (caar args)
           (error 'apply-fo-car (format "car expects a pair ~s" (car args))))
         (error 'apply-fo-car (format "car expects 1 argument ~s" args))))
      ((cdr)
       (if (= 1 (length args))
         (if (real-pair? (car args))
           (cdar args)
           (error 'apply-fo-cdr (format "cdr expects a pair ~s" (car args))))
         (error 'apply-fo-cdr (format "cdr expects 1 argument ~s" args))))
      ((not) (apply not args))
      ((equal?) (apply equal? args))
      ((pair?)
       (if (= 1 (length args))
         (real-pair? (car args))
         (error 'apply-fo-pair?
                (format "pair? expects 1 argument ~s" args))))
      ((symbol?) (apply symbol? args))
      ((number?) (apply number? args))
      ((procedure?)
       (if (= 1 (length args))
         (real-procedure? (car args))
         (error 'apply-fo-procedure?
                (format "procedure? expects 1 argument ~s" args))))
      ((apply) (apply apply-fo args))
      ((closure)
       (evaluate-fo (cadddr (cdr proc))
                    (env-extend* (caddr proc) (cadddr proc) args)))
      (else (error 'apply-fo (format "invalid procedure ~s" proc))))
    (error 'apply-fo (format "invalid procedure ~s" proc))))

(define (evaluate-fo expr env)
  (case (car expr)
    ((literal) (cadr expr))
    ((reference) (env-ref env (cadr expr)))
    ((application)
     (apply-fo
       (evaluate-fo (cadr expr) env)
       (map (lambda (arg) (evaluate-fo arg env)) (caddr expr))))
    ((if)
     (if (evaluate-fo (cadr expr) env)
       (evaluate-fo (caddr expr) env)
       (evaluate-fo (cadddr expr) env)))
    ((lambda) `(,procedure-tag closure ,env ,(cadr expr) ,(caddr expr)))
    (else (error 'evaluate-fo (format "invalid expression ~s" expr)))))

(define env-initial
  `((cons . (,procedure-tag cons))
    (car . (,procedure-tag car))
    (cdr . (,procedure-tag cdr))
    (not . (,procedure-tag not))
    (equal? . (,procedure-tag equal?))
    (pair? . (,procedure-tag pair?))
    (symbol? . (,procedure-tag symbol?))
    (number? . (,procedure-tag number?))
    (procedure? . (,procedure-tag procedure?))
    (apply . (,procedure-tag apply))
    . ,env-empty))

(define (evaluate expr env) (evaluate-fo (denote expr env) env))
