text-based bootstrap
  unsafe2: to bootstrap safe languages
    provides:
      cond, match, quasiquote/unquote/unquote-splicing(new!)
      and-map?, or-map?, datum->tag (tag as a symbol)
      match versions of let[rec][$][*], lambda[$]

  records/modules

  self-hosted semantics
    term
    denotation
    substitution
    operation
    parsing
      unsafe0
      unsafe1
    linking

  support non-primitive (user-extensible) tagged data in std0-module
  extended numeric literals (rational, floating point, complex), characters as ascii/utf8 bit encodings, symbols as strings with alternative tagging rather than injected binaries
  CPS transform to support system interaction (aka produce)

  automated optimization ideas (in case bootstrapped system is unusably slow):
    make sure to check terms for size explosion after using any of these

    simply-typed termination-checking normalization
      naively repeat simple-typing during normalization until/unless occurs-check fails
      could also be applied bottom-up with rank-1 intersections/unions

    well-quasi-order termination-checking normalization
      repeating program-point patterns
        tag-bags as in http://research.microsoft.com/en-us/um/people/simonpj/papers/supercompilation/termination-combinators.pdf)
          subsumes homeomorphic embeddings
      lexicographic order measure-tracking across cyclic application paths

    supercompilation
      not exactly low-hanging fruit, so would prefer to save this until later
      the above solutions already correspond to driving, so this would add splitting,
      context injection, and cyclic memoization (extraction of recursive state machines)

  restore monolithic eval (it's simpler than seval) once it's clearly affordable
    monolithic eval benchmark:
      pre-processing: cpu time: 220 real time: 214 gc time: 60
      cpu time: 284 real time: 283 gc time: 0
      cpu time: 1804 real time: 1809 gc time: 0
      user    0m5.884s
    seval benchmark:
      pre-processing: cpu time: 728 real time: 727 gc time: 136
      cpu time: 88 real time: 90 gc time: 4
      cpu time: 432 real time: 430 gc time: 28
      user    0m4.452s


high-level language design
  should serve as an example of creating an ina backend for a HLL

  basic concepts
    syntactic fexprs, procedures, unit, booleans (if0, if), pairs (head, tail), nil, bitstrings/numbers/chars/strings, arrays, tagging (private injected symbols) and case-analysis (in terms of record dispatch?), records/modules (private injected symbols for internal field names, mapped to public symbols), injected symbols, bare vs. value-coupled symbols (for convenient empty-env eval implementation)

  required effects
    produce/ffi, errors, ports/input/output (preferably high-level versions in addition to bit-level streams), mutable cells/arrays (possibly single-assignable to represent late-bound immutables), generated symbols, delimited continuations, random number generation, time, other system utilities

  more ambitious effects
    actual concurrency, CAS, channels, thread-local mutable data

  optional type system
    simple programmer-supplied annotations of what to reduce at "typecheck-time" for more precise analysis
      dynamic-lambda parameter annotations:
        no-preference: polymorphic preference determined by dependencies
        prefer-monomorphic
        prefer-polymorphic: provides something like let-polymorphism by inferring intersection types
      typechecking will attempt normalization where necessary to resolve/eliminate intersection types
    fall back on ML(x)-like inference
    interoperate with untyped program components


simple compilation to racket


attempt high-level machine model/repr for improved compilation
  potentially-related references:
    http://repository.readscheme.org/ftp/papers/vlisp-lasc/prescheme.pdf
    https://cakeml.org/


database/repository system


compile to javascript


effectful calculus with a compatible step relation (fully Church-Rosser as in Shutt's vau calculi, not just satisfying Felleisen's diamond property)
  shift/reset, constant, mutable ref


annotated evaluation
  lam and subst-binding annotations to remember parameter/variable names
  for early subst cleanup, annotate terms/values with free vars
  what does a high level debugger/ide need, annotation-wise?
    mark primitive operations that should be reduced in one step from user's perspective
    elaboration layer support
      track dependency flow during elaboration (small-step evaluation)
      re-tag programs to formally indicate a new reference layer
    enough information to contextually pretty-print the current program
      at the very least, pretty-print high level values (symbols, ints, booleans, lists)
  dependency flow analysis
    information to track
      immediate value (e.g. pair component extracted by unpair operation)
      contributor values (e.g. bit and pair during unpair operation)
      direct term path
      predecessor term path (strictness analysis: term never gets evaluated if predecessor never terminates)
    path representation determines precision: lists vs. sets vs. counted sets? unlimited vs. LRU truncated?
  notation/pretty-printing
    meta nodes for choosing pre-defined behaviors; avoids becoming too dependent on host language
    of embedded languages: denotational (kernel-like) and operational (AST-based) encodings
      operational: can leverage meta nodes directly
      denotational: requires a smarter analysis
        component "holes" indicated by usage of "eval" from within syntax transformer
          holes positions can be interacted with directly and are pretty-printed independently
          original syntactic application/form will be statically pretty-printed, except for holes
            e.g. (let ((a <hole0>) (b <hole1>)) <hole2>)
            until skeleton of transformation is disturbed (indicated by foreign annotations?)
              at which point resultant subcomponents are also pretty-printed independently
    unsafe1 in unsafe0 in unsafe1 ...


self-extensible browser-based editor
  text-like editor mode
    present an AST-editing interface that feels like text editing
    how to move subterms to remote locations?
      name-based contexts
      how to close terms? is it even necessary anymore? probably only upon extraction, which shouldn't be a problem
    left/right arrow keys navigate per-char; up/down quickly jump parent/child expressions, remembering last-visited child?
      shift+arrow for larger movements
      some way to toggle/reorder siblings, sort of like reversing a subrange of widgets
    unit acts like a typing context, space opens a new such context
    typing the first character in a new context should clearly indicate its syntactic category
    numeric characters do the usual
    alphabetic characters start a new variable
      only prefixes for in-scope vars will work (open up an auto-complete list)
      should have some way to start variable for non-alpha chars
    { opens new pair; } leaves it
    ( opens a new application; ) in the final context leaves it
    \ begins a lambda, moving into the arg list (while showing "(lambda (")
      ) leaves arg list; ) again leaves lam body
      new contexts inside the arg list are like lam-wrapping
      removing var applies that lam to unit


logic
  proof-checking decision procedure: (proof? proposition candidate-proof) : Boolean
  basic props and inference rules include some minimal mix of: ->, ->*, |->, |->*, ~=, term induction
    bracketing (see Boyer-Moore translations) needs reformulation as a meta-level operator
      requires everything to be quoted another level
      decision procedures all the way down until term induction
    term induction
      a special case of universal quantifier proof (all t:Term. P(t))
        doesn't require decision procedure for quantifier bounds checking
        inference rule requires a way to hypothesize smaller induction proofs
    can BHK interpretation ideas be used to manipulate Boyer-Moore style proofs?
      BHK versions shown for comparison below are not the same structures as the Boyer-Moore proofs
    Boyer-Moore style proofs
      p. proof of #"A and B" where
        (proof? #"(and (proof? A ...) (proof? B ...)) ->* #t" p)
        BHK: p = (pair a b) where #"(proof? A a) ->* #t" and #"(proof? B b) ->* #t"
      p. proof of #"A or B" where
        (proof? #"(or (proof? A ...) (proof? B ...)) ->* #t" p)
        BHK: p = (pair 0 a) where #"(proof? A a) ->* #t"
               | (pair 1 b) where #"(proof? B b) ->* #t"
      p. proof of #"all x : S. P(x)" where
        (proof? #"(lam (x)
                    (if (equal? (bracket #t)
                                (step-complete #"(S #,(bracket x))"))
                      (proof? #"P(#,(bracket x))" ... x ...)
                      #t)) ->* (lam (x) #t)"
                p)
        note the bracket operation, which can only exist as a meta-level operation
        extra level of quotation/bracketing necessary to verify well-definedness via step-complete
          if checking "x is an S" gets stuck or infinite loops then all bets are off
            so S pretty much has to be a decision procedure because step-complete is *not*
            bounds checking analogous to type/kind checking
        BHK: p is a dependent product of the same form as described by the proven formula
      p. proof of #"A -> B" where
        (proof? #"(lam (a)
                    (if (equal? (bracket #t)
                                (step-complete #"(proof? A #,(bracket a))"))
                      (proof? B ... a ...)
                      #t)) ->* (lam (a) #t)"
                p)
        It can be seen that #"A -> B" = #"all a:(proof? A). B"
          implies the right BHK interpretation
      p. proof of #"not A" where
        (proof? #"(lam (x)
                    (if (equal? (bracket #t)
                                (step-complete #"(proof? A #,(bracket x))"))
                      'False'
                      #t)) ->* (lam (x) #t)"
                p)
        can be seen as: all x:(proof? A). 'False'
        BHK: substitute any prop 'False' you'd like; if handed a (proof? A), suddenly you've proven 'False'


================
long-term vision
================

smart editors
  non-textual
    directly manipulate program structure
      syntactically-correct programs by construction
      non-textual modes of input and presentation possible
    removes bias towards monolithic text files
      many independently-developed code fragments grouped and combined in multiple ways
  context-aware editing and exploration
    code completion/suggestions
    "time-traveling" symbolic evaluation and debugging; better than a REPL
    programmable state/output visualization and dependency/correlation tracing
      which portions of the program determine a given component of the output?
    generalization from examples
    allows more intelligent version control
  layered program views and elaboration
    infer lower levels from higher levels
      specifications -> high-level implementations -> low-level representations
    semi-manually intervene/optimize at any level
  programmable visualization and interaction
    produce specialized WYSIWYG "editors" for creative tasks
  collaboration tools
    simultaneous manipulation of shared spaces with other users
    remote space/repository/DB publish/subscribe
  conveniently ubiquitous programming via html-embedded editor widgets
    widget allows page-local manipulation/execution
    can be rendered chrome-less (for seamless appearance) or expanded into the full editor in-page
    can connect to externally hosted DBs to import/export additional programs/content
      browsing a page with embedded code widgets and want to ...
        ... interact with the embedded code later?
          export a reference/copy to your personal DB
        ... interact with the embedded code while incorporating some of your own code?
          immediately import it from your personal DB
      on top of serendipitous programming, enables working on personal projects from anywhere
        assumes you trust the machine you run the browser on, or provide some other security mechanism
          such as accessing revoke-able and/or read-only DB capabilities
    editor can support more than just "code" editing
      symbol manipulation (typical programming), graphics, sound, arbitrary html, other domain-specific editing
        arbitrary html would mean you can run the editor in the editor...
        similar ideas? http://blog.duangle.com/2015/01/conspire-programming-environment-for.html

certified programming
  entirely optional and available at any sub-program granularity
    no obligation to statically analyze or type-check programs before running
    selectively analyze/certify/transform important parts of your program later on
  general framework for building reasoning/transformation tools
    dictates inference rules describing operational semantics
    everything else should be derivable
  analyses
    memory safety
    termination checking
    effect analysis
    information flow analysis
    control flow analysis
    type checking
    model checking
  correctness-preserving transformations
    refactoring
    optimization, e.g. supercompilation
    model concrete machines and operate abstract machines
      simulation
      compilation
      analysis and optimization
        resource analysis and management
          e.g. region-based memory management: like compile-time garbage collection
        symbolic profiling
  automated program elaboration
    inference of types, terms, even tests
  proof-carrying code
