text-based bootstrap
  annotation tree manipulations
    step-continuation to find path before applying step
    visit same path in annotation tree
    manipulate tree in a way that corresponds to step-execute

  applicative syntax
    term/value annotator, re-annotator + annotation-mapping

  unsafe2: to bootstrap safe languages
    syntax
      (combiner operand ...), literals (boolean, integer), ()
    primitive operatives:
      lambda, lambda$, bit, pair, unpair, quote, quasiquote/unquote,
    provides:
      fix*, if, cond, let[*], let$, letrec, match, quasiquote/unquote/unquote-splicing(new!), $, @, list, list*, apply*,
      filter, reverse, not?, and?, or?, and-map?, or-map?, datum->tag (tag as a symbol)

  statically-generated unique symbols
  non-primitive tagged data

  self-hosted semantics
    term
    denotation
    substitution
    operation
    parsing
      unsafe0
      unsafe1
    linking

  future bootstrap goals:
    where do records/modules fit?
    extended numeric literals (rational, floating point, complex), characters as ascii/utf8 bit encodings, symbols as strings with alternative tagging rather than injected binaries
    CPS transform to support system interaction (aka produce)
    use annotation manipulations for debug/editor support
      track variable names, comments and other source metadata
      trace data flow and dependencies, even through applications of eval to quoted data
        when navigating/editing a program that has been partially reduced
          editor should be able to map residual program locations to original program locations
          only reduced terms that interact with edited portions need to be updated

  goals after bootstrap:
    effectful calculus with a compatible step relation (fully Church-Rosser as in Shutt's vau calculi, not just satisfying Felleisen's diamond property)
      shift/reset, constant, mutable ref


high-level language design
  should serve as an example of creating an ina backend for a HLL

  basic concepts
    syntactic fexprs, procedures, unit, booleans (if0, if), pairs (head, tail), nil, bitstrings/numbers/chars/strings, arrays, tagging (private injected symbols) and case-analysis (in terms of record dispatch?), records/modules (private injected symbols for internal field names, mapped to public symbols), injected symbols, bare vs. value-coupled symbols (for convenient empty-env eval implementation)

  required effects
    produce/ffi, errors, ports/input/output (preferably high-level versions in addition to bit-level streams), mutable cells/arrays (possibly single-assignable to represent late-bound immutables), generated symbols, delimited continuations, random number generation, time, other system utilities

  more ambitious effects
    actual concurrency, CAS, channels, thread-local mutable data


simple compilation to racket


attempt high-level machine model/repr for improved compilation
  potentially-related references:
    http://repository.readscheme.org/ftp/papers/vlisp-lasc/prescheme.pdf
    https://cakeml.org/


database/repository system


compile to javascript


self-extensible browser-based editor
  text-like editor mode
    present an AST-editing interface that feels like text editing
    how to move subterms to remote locations?
      name-based contexts
      how to close terms? is it even necessary anymore? probably only upon extraction, which shouldn't be a problem
    left/right arrow keys navigate per-char; up/down quickly jump parent/child expressions, remembering last-visited child?
      shift+arrow for larger movements
      some way to toggle/reorder siblings, sort of like reversing a subrange of widgets
    unit acts like a typing context, space opens a new such context
    typing the first character in a new context should clearly indicate its syntactic category
    numeric characters do the usual
    alphabetic characters start a new variable
      only prefixes for in-scope vars will work (open up an auto-complete list)
      should have some way to start variable for non-alpha chars
    { opens new pair; } leaves it
    ( opens a new application; ) in the final context leaves it
    \ begins a lambda, moving into the arg list (while showing "(lambda (")
      ) leaves arg list; ) again leaves lam body
      new contexts inside the arg list are like lam-wrapping
      removing var applies that lam to unit
