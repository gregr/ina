#lang racket/base
(provide (all-from-out 'interop) interop-eval racket-eval)

(module interop racket/base
  (provide (all-from-out "prim.rkt")
           s->ns ns->s writeable?! read* read*/file write/file
           racket-datum lift lower lower-arg0 $apply
           nscm-quote nscm-quasiquote nscm-equal? nscm-member nscm-assoc)

  (require
    "prim.rkt" racket/path racket/port racket/vector (for-syntax racket/base))

  (define (s->ns d)
    (cond ((symbol? d) (symbol->string d))
          ((pair? d) (cons (s->ns (car d)) (s->ns (cdr d))))
          ((vector? d) (vector-map s->ns d))
          ((or (boolean? d) (null? d) (number? d) (string? d) (procedure? d)
               (mvector? d)) d)
          (else (error "invalid nscheme datum:" d))))

  (define (ns->s d)
    (cond ((string? d) (string->symbol d))
          ((pair? d) (cons (ns->s (car d)) (ns->s (cdr d))))
          ((vector? d) (vector-map ns->s d))
          (else d)))

  (define (writeable?! d)
    (cond ((pair? d) (writeable?! (car d)) (writeable?! (cdr d)))
          ((vector? d) (writeable?! (vector->list d)))
          ((or (boolean? d) (null? d) (number? d) (string? d)
               (symbol? d) (char? d) (keyword? d)) #t)
          (else (error "cannot write:" d))))

  (define (read* in)
    (let loop ((rbody '()))
      (define datum (read in))
      (if (eof-object? datum) (reverse rbody) (loop (cons datum rbody)))))
  (define (read*/file path)   (call-with-input-file path read*))
  (define (write/file path d)
    (call-with-output-file path (lambda (out) (writeable?! d) (write d out))))

  (define (racket-datum form)
    (define (@ i) (vector-ref form i)) (define (? tag) (nscm-equal? (@ 0) tag))
    (cond ((pair? form)         (cons (racket-datum (car form))
                                      (racket-datum (cdr form))))
          ((string? form)       (string->symbol form))
          ((not (vector? form)) form)
          ((? "quote")   (@ 1))
          ((? "vector")  (vector-map racket-datum (@ 1)))
          ((? "symbol")  (string->symbol (@ 1)))
          ((? "keyword") (string->keyword (@ 1)))
          ((? "char")    (call-with-input-string (string-append "#\\" (@ 1))
                                                 (lambda (in) (read in))))
          ((? "string")  (if (string? (@ 1)) (@ 1)
                           (error "invalid string:" (@ 1))))
          (#t (error "invalid racket-datum form:" form))))

  (define (lift racket-proc)   (lambda (a) (apply racket-proc a)))
  (define (lower nscheme-proc) (lambda a   (nscheme-proc a)))
  (define (lower-arg0 proc)    (lambda (f . args) (apply proc (lower f) args)))
  (define ($apply proc arg . args)
    (define (cons* x xs) (if (null? xs) x (cons x (cons* (car xs) (cdr xs)))))
    (proc (cons* arg args)))

  ;; For safe interop, provided definitions must not override Racket names.
  (define (nscm-equal? a b)
    (or (eqv? a b)
        (and (string? a) (string? b) (string=? a b))
        (and (pair? a) (pair? b)
             (nscm-equal? (car a) (car b))
             (nscm-equal? (cdr a) (cdr b)))
        (and (vector? a) (vector? b)
             (nscm-equal? (vector->list a) (vector->list b)))))
  (define (nscm-member v xs) (memf (lambda (x) (nscm-equal? x v)) xs))
  (define (nscm-assoc k xs) (cond ((null? xs) #f)
                                  ((nscm-equal? k (caar xs)) (car xs))
                                  (else (nscm-assoc k (cdr xs)))))

  (define-syntax (nscm-quote stx)
    (syntax-case stx ()
      ((_ id)       (identifier? #'id)
                    #`(nscm-quote #,(symbol->string (syntax->datum #'id))))
      ((_ (a . d))  #'(cons (nscm-quote a) (nscm-quote d)))
      ((_ #(d ...)) #'(vector (nscm-quote d) ...))
      ((_ d)        #'(quote d))))
  (define-syntax nscm-quasiquote (syntax-rules () ((_ d) (nscm-qq () d))))
  (define-syntax nscm-qq
    (syntax-rules (nscm-quasiquote unquote unquote-splicing)
      ((_ lvl (nscm-quasiquote d))
       (list (nscm-quote quasiquote)       (nscm-qq (s . lvl) d)))
      ((_ (s . p) (unquote e))
       (list (nscm-quote unquote)          (nscm-qq p e)))
      ((_ (s . p) (unquote-splicing e))
       (list (nscm-quote unquote-splicing) (nscm-qq p (unquote-splicing e))))
      ((_ () (unquote e))                e)
      ((_ () ((unquote-splicing e) . d)) (append e (nscm-qq () d)))
      ((_ lvl unquote)          (error "invalid unquote"))
      ((_ lvl unquote-splicing) (error "invalid unquote-splicing"))
      ((_ lvl (a . d))          (cons (nscm-qq lvl a) (nscm-qq lvl d)))
      ((_ lvl #(d ...))         (list->vector (nscm-qq lvl (d ...))))
      ((_ lvl d)                (nscm-quote d)))))

(require racket/runtime-path 'interop)
(define-runtime-module-path interop-mod (submod "." interop))

(define (interop-eval form)
  (define local-ns (current-namespace))
  (parameterize ((current-namespace (make-base-namespace)))
    (namespace-attach-module local-ns interop-mod)
    (namespace-require/constant interop-mod)
    (eval form)))

(define (racket-eval rkt-datum) (interop-eval (racket-datum rkt-datum)))
