;; Public:
;; name-uid, name-symbol
;; scope, scope-closed?, scope-close, scope-name!
;; syntax?, syntax-metadata, (maybe?) syntax-expr, syntax->datum, datum->syntax
;; syntax/metadata, syntax/mark, syntax/antimark, syntax/scope
;; identifier?, free-identifier=?, bound-identifier=?, identifier->name

(define (uid-generator) (let ((id 0)) (lambda () (set! id (+ id 1)) id)))
(define fresh-label (uid-generator))
(define fresh-mark  (uid-generator))
(define (mark? h)        (or (number? h) (not h)))
(define (antimark? m h)  (not h))
(define (fresh-name sym) (cons (fresh-label) sym))
(define (name-uid n)     (car n))
(define (name-symbol n)  (cdr n))

(define (binding sym m* n) (cons sym (cons m* n)))
(define (binding-marks b)  (cadr b))
(define (binding-name b)   (cddr b))

(define (scope)            (mvector #f '()))
(define (scope-closed? s)  (mvector-ref s 0))
(define (scope-close! s)   (mvector-set! s 0 #t))
(define (scope-ref s sym)  (assoc sym (mvector-ref s 1)))
(define (scope-name! s i*)
  (when (scope-closed? s) (error "naming in closed scope:" i* s))
  (define (fresh-binding i)
    (identifier?! i)
    (define sym (syntax-expr i))
    (binding sym (hygiene->marks (syntax-hygiene i)) (fresh-name sym)))
  (define b* (map fresh-binding i*))
  (mvector-set! s 1 (append b* (mvector-ref s 1)))
  (map binding-name b*))

(define (hygiene-append outer inner)
  (define (hygiene-cons o inner)
    (if (and (pair? inner) (mark? o) (antimark? o (car inner))) (cdr inner)
      (cons o inner)))
  (if (null? outer) inner
    (hygiene-cons (car outer) (hygiene-append (cdr outer) inner))))
(define (hygiene->marks h*) (filter mark? h*))
(define (hygiene-marks=? h1 h2)
  (define (prefix/marks h)
    (if (or (null? h) (mark? (car h))) h (prefix/marks (cdr h))))
  (let ((h1 (prefix/marks h1)) (h2 (prefix/marks h2)))
    (if (null? h1) (null? h2)
      (and (not (null? h2))
           (equal? (car h1) (car h2))
           (hygiene-marks=? (cdr h1) (cdr h2))))))
(define (hygiene->name h* sym)
  (cond ((null? h*)       sym)
        ((mark? (car h*)) (hygiene->name (cdr h*) sym))
        ((scope-ref (car h*) sym)
         => (lambda (b) (if (hygiene-marks=? (binding-marks b) (cdr h*))
                          (binding-name b)
                          (hygiene->name (cdr h*) sym))))
        (else (hygiene->name (cdr h*) sym))))

(define (syntax? d) (and (mvector? d)
                         (= 4 (mvector-length d))
                         (equal? 'syntax (mvector-ref d 0))))
(define (syntax?! d) (unless (syntax? s) (error "invalid syntax:" s)))
(define (make-syntax hygiene meta d)
  (define e (if (syntax? d) (syntax-expr d) d))
  (define h (if (syntax? d) (syntax-hygiene d) '()))
  (define m (if (syntax? d) (syntax-meta d) '()))
  (mvector 'syntax (hygiene-append hygiene h) (append meta m) e))
(define (syntax-hygiene s)    (syntax?! s) (mvector-ref s 1))
(define (syntax-expr s)       (syntax?! s) (mvector-ref s 3))
(define (syntax-metadata s)   (syntax?! s) (mvector-ref s 2))
(define (syntax/metadata m d) (make-syntax '()                   m d))
(define (syntax/mark d)       (make-syntax (list (fresh-mark)) '() d))
(define (syntax/antimark d)   (make-syntax (list #f)           '() d))
(define (syntax/scope s d)    (make-syntax (list s)            '() d))

(define (datum->syntax s d) (make-syntax (syntax-hygiene s) '() d))
(define (syntax->datum d)
  (cond ((pair? d)   (cons (syntax->datum (car d)) (syntax->datum (cdr d))))
        ((vector? d) (vector-map syntax->datum d))
        ((syntax? d) (syntax->datum (syntax-expr d)))
        (else        d)))

(define (identifier? d) (and (syntax? d) (symbol? (syntax-expr d))))
(define (identifier?! d)
  (unless (identifier? d) (error "invalid identifier:" d)))
(define (identifier->name d)
  (identifier?! d)
  (hygiene->name (syntax-hygiene d) (syntax-expr d)))
(define (free-identifier=? a b)
  (identifier?! a) (identifier?! b)
  (equal? (identifier->label a) (identifier->label a)))
(define (bound-identifier=? a b)
  (identifier?! a) (identifier?! b)
  (and (equal? (syntax-expr a) (syntax-expr b))
       (hygiene-marks=? (syntax-hygiene a) (syntax-hygiene b))))

;; Public utilities:
(define (self-evaluating? d)
  (or (boolean? d) (number? d) (char? d) (string? d)))
(define (syntax-error s message)
  (error message (syntax-metadata s) (syntax->datum s)))
;(define (syntax-pair? d)   (pair? (syntax-expr d)))
;(define (syntax-car d)     (datum->syntax d (car (syntax-expr d))))
;(define (syntax-cdr d)     (datum->syntax d (cdr (syntax-expr d))))
;(define (syntax-vector? d) (vector? (syntax-expr d)))
;(define (syntax->vector d) (vector-map (lambda (e) (datum->syntax d e))
                                       ;(syntax-expr d)))
