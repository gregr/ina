;; TODO: optional formatting styles?
;; quote/abbreviations, padding, packing, numeric formats/radixes/rounding
;; fine-grained writing styles? express write in terms of richer documents?

(define (write v out (format-policy? #f))
  (define (pr s) (port-put* out s))
  (define (wr+:default x pos _ __) (pr " ") (wr x (+ pos 1) 0))
  (define format-policy
    (match format-policy?
      (#f      #f)
      ('pretty `(pretty 80))
      ('bulky  `(bulky  80))
      (policy  policy)))
  (define wr+
    (match format-policy
      (#f               wr+:default)
      (`(pretty ,width) (lambda (x pos indent s.indent)
                          (pr "\n") (pr s.indent)
                          (wr x indent indent)))
      (`(bulky  ,width) (lambda (x pos indent s.indent)
                          (define pos.after (+ pos (wunit-width x)))
                          (define pos.1
                            (cond ((< width pos.after) (pr "\n") (pr s.indent) indent)
                                  (else                (pr " ")                (+ pos 1))))
                          (wr x pos.1 indent)))))
  (define width
    (match format-policy
      (#f               #f)
      (`(pretty ,width) width)
      (`(bulky  ,width) width)))
  (define (wunit-width x)
    (match x
      ;; TODO: do not use strings, use (byte)vectors
      ;; TODO: do not use string-length
      ((? string?)      (string-length x))
      ((vector w _ _ _) w)))
  (define (datum->wunit v)
    (define (bracket l r vs)
      (define xs
        (let loop ((vs vs))
          (match vs
            ('()         '())
            (`(,v . ,vs) (cons (datum->wunit v) (loop vs)))
            (v (list "."       (datum->wunit v))))))
      (vector (+ (string-length l) (string-length r) (foldl + 0 (map wunit-width xs))
                 (max 0 (- (length xs) 1)))
              l r xs))
    (cond ((pair?      v) (bracket "(" ")" v))
          ((vector?    v) (cond ((eqv? (vector-length  v) 0) (pr "#()"))
                                (else (bracket "#(" ")"  (vector->list  v)))))
          ((mvector?   v) (cond ((eqv? (mvector-length v) 0) (pr "#m()"))
                                (else (bracket "#m(" ")" (mvector->list v)))))
          ((eq? #t     v) "#t")
          ((eq? #f     v) "#f")
          ((null?      v) "()")
          ((procedure? v) "#<procedure>")
          (else (call-with-output-string
                  (lambda (out)
                    (define (pr s) (port-put* out s))
                    (cond ((number? v) (write-number v out))
                          ((symbol? v) (write-symbol v out))
                          ((string? v) (write-string v out))
                          (else        (pr "#<unknown>"))))))))
  (define (wr x pos indent.0)
    (match x
      ((? string?) (pr x) (+ pos (string-length x)))
      ((vector w.full l r xs)
       (define w.l    (string-length l))
       (define w.r    (string-length r))
       (define pos.0  (+ pos      w.l))
       (define indent (+ indent.0 w.l))
       (pr l)
       (define pos.1
         (match xs
           ('()         pos.0)
           (`(,x . ,xs) (foldl (if (and width (<= (+ pos w.full) width))
                                 (lambda   (x pos) (wr+:default x pos 0      ""))
                                 (let ((s.indent (string-append* (make-list indent " "))))
                                   (lambda (x pos) (wr+         x pos indent s.indent))))
                               (wr x pos.0 indent) xs))))
       (pr r) (+ pos.1 w.r))))
  (wr (datum->wunit v) 0 0))

(define (write-string v out)
  (define (pr s) (port-put* out s))
  (pr "\"")
  (for-each
    (lambda (c)
      (pr (case/char c ("\"" "\\\"") ("\\" "\\\\") ("\a" "\\a")
            ("\b" "\\b") ("\e" "\\e") ("\f" "\\f") ("\n" "\\n")
            ("\r" "\\r") ("\t" "\\t") ("\v" "\\v")
            (else (if (or (unicode-control? c) (unicode-vspace? c))
                    (string-append "\\u" (number->string c) ";")
                    (list->string (list c)))))))
    (string->unicodes v))
  (pr "\""))

(define write-symbol
  (let* ((punc?       (cset "\\\"#'(),;[]`{}"))
         (bad-symbol? (lambda (c) (or (unicode-space? c) (punc? c)))))
    (lambda (v out)
      (define (pr s) (port-put* out s))
      (define s (symbol->string v))
      (cond ((eq? v '|.|)       (pr "|.|"))
            ((string->number s) (pr "|") (pr s) (pr "|"))
            (else (define cs   (string->unicodes s))
                  (define bad? (ormap bad-symbol? cs))
                  (when bad? (pr "|"))
                  (for-each
                    (lambda (c)
                      (cond ((eqv? c (char "|")) (when bad? (pr "|"))
                                                 (pr "\\|")
                                                 (when bad? (pr "|")))
                            (else (pr (list->string (unicode->utf8 c))))))
                    cs)
                  (when bad? (pr "|")))))))

;; TODO: reduce dependency on exact->inexact and inexact->exact
;; manipulate floating point representation directly via:
;;   (real->floating-point-bytes x 8)
;;   (floating-point-bytes->real bs)
(define (write-number n out)
  (define (pr s)       (port-put* out s))
  (define (pr-digit d) (port-put  out (+ d (char "0"))))
  (define (pr-nat n)
    (if (eqv? n 0) (pr "0")
      (let loop ((n n) (ds '()))
        (if (> n 0) (loop (quotient n 10) (cons (remainder n 10) ds))
          (for-each pr-digit ds)))))
  (define (pr-int n) (cond ((< n 0) (pr "-") (pr-nat (- n)))
                           (else             (pr-nat    n))))
  (define (larger-log10 n)
    (cond ((< n 1) 0)
          (else (define ~e (inexact->exact (truncate (log n 10))))
                (define ~p (expt 10 ~e))
                (cond ((< n (/ ~p 10)) (- ~e 1))
                      ((< n    ~p    )    ~e   )
                      (else            (+ ~e 1))))))
  (define (pr-float n.inexact)
    (define n (inexact->exact n.inexact))
    (define (finish rdigits e)
      (define ds (reverse rdigits))
      (if (and (eqv? 0 (car ds)) (< 0 e))
        (finish.1 (cdr ds) (- e 1))
        (finish.1      ds     e)))
    (define (finish.1 digits e)
      (define (pr-dec digits e?)
        (pr-digit (car digits))
        (cond ((null? (cdr digits)) (unless e? (pr ".") (pr-digit 0)))
              (else                 (pr ".") (for-each pr-digit (cdr digits)))))
      (define (pr-exp digits e) (pr-dec digits #t) (pr "e") (pr-int e))
      (cond ((<= #e1e10 n       ) (pr-exp digits e))
            ((<  0      n #e1e-3) (let loop ((digits digits) (e e))
                                    (if (eqv? 0 (car digits))
                                      (loop (cdr digits) (- e 1))
                                      (pr-exp digits e))))
            (else (let loop ((ds digits) (e e))
                    (define digits (if (null? ds) '(0) ds))
                    (cond ((<= e 0) (pr-dec digits #f))
                          (else     (pr-digit (car digits))
                                    (loop (cdr digits) (- e 1))))))))
    (define e   (larger-log10 n))
    (define e10 (expt 10 e))
    (define m   (/ n e10))
    (let loop ((m m) (approx 0) (scale e10) (rdigits '()))
      (define   d     (truncate m))
      (define a+d     (+ approx (*    d    scale)))
      (define a+d+1   (+ approx (* (+ d 1) scale)))
      (define a+d=?   (eqv? (exact->inexact a+d  ) n.inexact))
      (define a+d+1=? (eqv? (exact->inexact a+d+1) n.inexact))
      (cond ((and a+d=?
                  (or (not a+d+1=?)
                      (<= (- n a+d)
                          (-   a+d+1 n)))) (finish (cons    d    rdigits) e))
            (     a+d+1=?                  (finish (cons (+ d 1) rdigits) e))
            (else (loop (* (- m d) 10) a+d (/ scale 10) (cons d rdigits))))))
  (cond ((not (real? n)) (define i (imag-part n))
                         (write-number (real-part n) out)
                         (when (and (<= 0 i) (not (eqv? i +inf.0))) (pr "+"))
                         (write-number i out) (pr "i"))
        ((eqv? n +inf.0) (pr "+inf.0"))
        ((eqv? n -inf.0) (pr "-inf.0"))
        ((eqv? n +nan.0) (pr "+nan.0"))
        ((inexact? n)    (when (or (< n 0) (equal? n -0.0)) (pr "-"))
                         (pr-float     (abs n)))
        ((integer? n)    (pr-int            n))
        (else            (pr-int (numerator n)) (pr "/") (pr-nat (denominator n)))))

(define (number->string n) (call-with-output-string
                             (lambda (out) (write-number n out))))

;; TODO: format, fprintf
