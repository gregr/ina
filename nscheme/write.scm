;; recognize symbol characters that must be escaped when writing

;; TODO: indent? pretty printing? optional formatting styles?
;; quote/abbreviations, padding, packing, numeric formats/radixes/rounding
;; fine-grained writing styles? express write in terms of richer documents?

(define (write v out)
  (define punc? (cset "\\\"#'(),;[]`{}"))
  (define (bad-symbol? c) (or (unicode-space? c) (punc? c)))
  (define (pr s) (out 'put* s))
  (define (write* v)
    (write (car v) out)
    (cond ((pair? (cdr v))       (pr " ")   (write* (cdr v)))
          ((not (null? (cdr v))) (pr " . ") (write (cdr v) out))))
  (define (bracket l r v) (pr l) (write* v) (pr r))
  (cond ((eq? v #t)  (pr "#t"))
        ((eq? v #f)  (pr "#f"))
        ((null? v)   (pr "()"))
        ((number? v) (write-number v out))
        ((symbol? v)
         (define s (symbol->string v))
         (cond ((eq? v '|.|)       (pr "|.|"))
               ((string->number s) (pr "|") (pr s) (pr "|"))
               (else (define cs   (string->unicodes s))
                     (define bad? (ormap bad-symbol? cs))
                     (when bad? (pr "|"))
                     (for-each
                       (lambda (c)
                         (cond ((= c (char "|")) (when bad? (pr "|"))
                                                 (pr "\\|")
                                                 (when bad? (pr "|")))
                               (else (pr (list->string (unicode->utf8 c))))))
                       cs)
                     (when bad? (pr "|")))))
        ((string? v)
         (pr "\"")
         (for-each
           (lambda (c)
             (pr (case/char c ("\"" "\\\"") ("\\" "\\\\") ("\a" "\\a")
                   ("\b" "\\b") ("\e" "\\e") ("\f" "\\f") ("\n" "\\n")
                   ("\r" "\\r") ("\t" "\\t") ("\v" "\\v")
                   (else (if (or (unicode-control? c) (unicode-vspace? c))
                           (string-append "\\u" (number->string c) ";")
                           (list->string (list c)))))))
           (string->unicodes v))
         (pr "\""))
        ((pair?      v) (bracket "(" ")" v))
        ((vector?    v) (cond ((= (vector-length  v) 0) (pr "#()"))
                              (else (bracket "#(" ")"  (vector->list  v)))))
        ((mvector?   v) (cond ((= (mvector-length v) 0) (pr "#m()"))
                              (else (bracket "#m(" ")" (mvector->list v)))))
        ((procedure? v) (pr "#<procedure>"))))

(define (write-number n out)
  (define (pr s)       (out 'put* s))
  (define (pr-digit d) (out 'put (+ d (char "0"))))
  (define (pr-nat n)
    (if (= n 0) (pr "0")
      (let loop ((n n) (ds '()))
        (if (> n 0) (loop (quotient n 10) (cons (remainder n 10) ds))
          (for-each pr-digit ds)))))
  (define (pr-int n) (cond ((< n 0) (pr "-") (pr-nat (- n)))
                           (else             (pr-nat    n))))
  (define (pr-frac n)
    (pr ".") (if (= n 0) (pr "0")
               (let loop ((n n)) (when (> n 0)
                                   (let ((m (* n 10)))
                                     (pr-digit (truncate m))
                                     (loop (- m (truncate m))))))))
  (define (pr-nat/frac n)
    (define m (truncate n))
    (pr-nat m) (pr-frac (- n m)))
  (define (pr-exp n e) (pr-nat/frac n) (pr "e") (pr-int e))
  (cond ((not (real? n)) (define i (imag-part n))
                         (write-number (real-part n) out)
                         (when (and (<= 0 i) (not (= i +inf.0))) (pr "+"))
                         (write-number i out) (pr "i"))
        ((=    n +inf.0) (pr "+inf.0"))
        ((=    n -inf.0) (pr "-inf.0"))
        ((eqv? n +nan.0) (pr "+nan.0"))
        ((inexact? n)
         (when (or (< n 0) (equal? n -0.0)) (pr "-"))
         (let ((n (abs (inexact->exact n))))
           (cond ((>= n #e1e10)  (let loop ((n n) (e 0))
                                   (cond ((>= n 10) (loop (/ n 10) (+ e 1)))
                                         (else      (pr-exp n e)))))
                 ((< 0 n #e1e-3) (let loop ((n n) (e 0))
                                   (cond ((< n 1)   (loop (* n 10) (- e 1)))
                                         (else      (pr-exp n e)))))
                 (else           (pr-nat/frac n)))))
        ((integer? n) (pr-int            n))
        (else         (pr-int (numerator n)) (pr "/") (pr-nat (denominator n)))))

(define (number->string n) (let ((out (port:string:output)))
                             (write-number n out)
                             (out 'string)))

;; TODO: format, fprintf
