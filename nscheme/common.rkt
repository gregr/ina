#lang racket/base
(provide
  s->ns ns->s plift $apply procedure=? number=?
  mvector? make-mvector mvector=? mvector-length mvector-ref mvector-set!
  mvector->vector string->vector vector->string
  alist-ref alist-remove* alist-at list-at
  length=? length>=? bpair*?!
  ctx:var ctx:set! ctx:op ctx:def
  env:empty env-ref env-ref-prop
  ncons param-map param-names param-bind
  defstate:empty defstate-env defstate-names defstate-actions
  defstate-env-set defstate-names-add defstate-actions-add
  (rename-out
    (new-equal? equal?) (new-quote quote) (new-quasiquote quasiquote)))

(require racket/vector (for-syntax racket/base))

(define (new-equal? a b)
  (or (eqv? a b)
      (and (string? a) (string? b) (string=? a b))
      (and (pair? a) (pair? b)
           (new-equal? (car a) (car b))
           (new-equal? (cdr a) (cdr b)))
      (and (vector? a) (vector? b)
           (new-equal? (vector->list a) (vector->list b)))))
(define-syntax (new-quote stx)
  (syntax-case stx ()
    ((_ id)       (identifier? #'id)
                  #`(new-quote #,(symbol->string (syntax->datum #'id))))
    ((_ (a . d))  #'(cons (new-quote a) (new-quote d)))
    ((_ #(d ...)) #'(vector (new-quote d) ...))
    ((_ d)        #'(quote d))))
(define-syntax new-quasiquote (syntax-rules () ((_ d) (new-qq () d))))
(define-syntax new-qq
  (syntax-rules (new-quasiquote unquote unquote-splicing)
    ((_ lvl (new-quasiquote d))
     (list (new-quote quasiquote)       (new-qq (s . lvl) d)))
    ((_ (s . p) (unquote e))
     (list (new-quote unquote)          (new-qq p e)))
    ((_ (s . p) (unquote-splicing e))
     (list (new-quote unquote-splicing) (new-qq p (unquote-splicing e))))

    ((_ () (unquote e))                e)
    ((_ () ((unquote-splicing e) . d)) (append e (new-qq () d)))
    ((_ lvl unquote)                   (error "invalid unquote"))
    ((_ lvl unquote-splicing)          (error "invalid unquote-splicing"))
    ((_ lvl (a . d))                   (cons (new-qq lvl a) (new-qq lvl d)))
    ((_ lvl #(d ...))                  (list->vector (new-qq lvl (d ...))))
    ((_ lvl d)                         (new-quote d))))
(define (s->ns d)
  (cond ((symbol? d) (symbol->string d))
        ((pair? d)   (cons (s->ns (car d)) (s->ns (cdr d))))
        ((vector? d) (vector-map s->ns d))
        (else        d)))
(define (ns->s d)
  (cond ((string? d) (string->symbol d))
        ((pair? d)   (cons (ns->s (car d)) (ns->s (cdr d))))
        ((vector? d) (vector-map ns->s d))
        (else        d)))
(define (plift racket-proc) (lambda (a) (apply racket-proc a)))
(define (procedure=? m n)   (eq? m n))
(define (number=? m n)      (eqv? m n))
(struct mvector (v) #:transparent)
(define (make-mvector k d)          (mvector (make-vector k d)))
(define (mvector=? m n)             (eq? m n))
(define (mvector-length mv)         (vector-length (mvector-v mv)))
(define (mvector-ref mv i)          (vector-ref (mvector-v mv) i))
(define (mvector-set! mv i new)     (vector-set! (mvector-v mv) i new) #t)
;; TODO: update Racket to use this.
;(define (mvector-cas! mv i old new) (vector-cas! (mvector-v mv) i old new))
(define (mvector->vector mv)        (vector-copy (mvector-v mv)))
(define (string->vector s) (list->vector (map char->integer (string->list s))))
(define (vector->string v) (list->string (map integer->char (vector->list v))))
(define ($apply proc arg) (proc arg))

(define (alist-ref rs key default)
  (define rib (assoc key rs))
  (if rib (cdr rib) default))
(define (alist-remove* rs keys)
  (filter (lambda (rib) (not (member (car rib) keys))) rs))
(define (list-at xs ?)  ;; produce a zipper referencing the desired location
  (let loop ((suffix xs) (prefix '()))
    (if (or (null? suffix) (? (car suffix))) (cons suffix prefix)
      (loop (cdr suffix) (cons (car suffix) prefix)))))
(define (alist-at rs key) (list-at rs (lambda (kv) (equal? (car kv) key))))

(define (length=? n xs)  (and (list? xs) (= (length xs) n)))
(define (length>=? n xs) (and (list? xs) (>= (length xs) n)))
(define (bpair*?! b*)
  (define (? b) (and (length=? 2 b) (param-names (car b))))
  (unless (and (list? b*) (andmap ? b*)) (error '"invalid binding list:" b*)))
(define (ncons name names)
  (when (member name names) (error '"duplicate name:" name names))
  (cons name names))
(define (param-map f p)
  (cond ((pair? p)   (cons (param-map f (cdr p)) (param-map f (car p))))
        ((vector? p) (list->vector (param-map f (vector->list p))))
        ((string? p) (f p))
        ((null? p)   '())
        ((not p)     #f)
        (#t (error '"invalid parameter:" p))))
(define (param-names param)
  (let loop ((p param) (ns '()))
    (cond ((pair? p)   (loop (cdr p) (loop (car p) ns)))
          ((vector? p) (loop (vector->list p) ns))
          ((string? p) (ncons p ns))
          ((null? p)   ns)
          ((not p)     ns)
          (#t (error '"invalid parameter:" p param)))))
(define (param-bind param arg)
  (let loop ((p param) (a arg))
    (cond ((and (pair? p) (pair? a)) (append (loop (car p) (car a))
                                             (loop (cdr p) (cdr a))))
          ((and (vector? p) (vector? a))
           (loop (vector->list p) (vector->list a)))
          ((string? p)               (list (cons p a)))
          ((and (null? p) (null? a)) '())
          ((not p)                   '())
          (#t (error '"parameter/argument mismatch:" param arg p a)))))

(define ctx:var  '"ref")
(define ctx:set! '"set!")
(define ctx:op   '"syntax?")
(define ctx:def  '"define")
(define env:empty                      '())
(define (env-ref env n)                (alist-ref env n '()))
(define (env-ref-prop env n k default) (alist-ref (env-ref env n) k default))

(define (defstate:empty env)  (vector env '() '()))
(define (defstate-env st)     (vector-ref st 0))
(define (defstate-names st)   (vector-ref st 1))
(define (defstate-actions st) (vector-ref st 2))
(define (defstate-env-set st env)
  (vector env (defstate-names st) (defstate-actions st)))
(define (defstate-names-add st names)
  (define new (foldl ncons (defstate-names st) names))
  (vector (defstate-env st) new (defstate-actions st)))
(define (defstate-actions-add st act)
  (define new (cons act (defstate-actions st)))
  (vector (defstate-env st) (defstate-names st) new))
