#lang racket/base
(provide
  s->ns ns->s plift $apply procedure=? number=?
  mvector? make-mvector mvector=? mvector-length mvector-ref mvector-set!
  mvector->vector string->vector vector->string
  alist-ref alist-remove* alist-at list-at
  length=? length>=? param?! bpair*?!
  ctx:var ctx:set! ctx:op ctx:def
  env:empty env-ref env-ref-prop env-pre-extend* env-extend*
  ncons param-map param-names param-bind
  defstate:empty defstate-env defstate-names defstate-actions
  defstate-env-set defstate-names-add defstate-actions-add
  equal? assoc member
  (rename-out (new-quote quote) (new-quasiquote quasiquote)))

(require racket/vector (for-syntax racket/base))

(define (equal? a b)
  (or (eqv? a b)
      (and (string? a) (string? b) (string=? a b))
      (and (pair? a) (pair? b)
           (equal? (car a) (car b))
           (equal? (cdr a) (cdr b)))
      (and (vector? a) (vector? b)
           (equal? (vector->list a) (vector->list b)))))
(define (member v xs) (memf (lambda (x) (equal? x v)) xs))
(define (assoc k xs) (cond ((null? xs) #f)
                           ((equal? k (caar xs)) (car xs))
                           (else (assoc k (cdr xs)))))
(define-syntax (new-quote stx)
  (syntax-case stx ()
    ((_ id)       (identifier? #'id)
                  #`(new-quote #,(symbol->string (syntax->datum #'id))))
    ((_ (a . d))  #'(cons (new-quote a) (new-quote d)))
    ((_ #(d ...)) #'(vector (new-quote d) ...))
    ((_ d)        #'(quote d))))
(define-syntax new-quasiquote (syntax-rules () ((_ d) (new-qq () d))))
(define-syntax new-qq
  (syntax-rules (new-quasiquote unquote unquote-splicing)
    ((_ lvl (new-quasiquote d))
     (list (new-quote quasiquote)       (new-qq (s . lvl) d)))
    ((_ (s . p) (unquote e))
     (list (new-quote unquote)          (new-qq p e)))
    ((_ (s . p) (unquote-splicing e))
     (list (new-quote unquote-splicing) (new-qq p (unquote-splicing e))))

    ((_ () (unquote e))                e)
    ((_ () ((unquote-splicing e) . d)) (append e (new-qq () d)))
    ((_ lvl unquote)                   (error "invalid unquote"))
    ((_ lvl unquote-splicing)          (error "invalid unquote-splicing"))
    ((_ lvl (a . d))                   (cons (new-qq lvl a) (new-qq lvl d)))
    ((_ lvl #(d ...))                  (list->vector (new-qq lvl (d ...))))
    ((_ lvl d)                         (new-quote d))))
(define (s->ns d)
  (cond ((symbol? d) (symbol->string d))
        ((pair? d)   (cons (s->ns (car d)) (s->ns (cdr d))))
        ((vector? d) (vector-map s->ns d))
        (else        d)))
(define (ns->s d)
  (cond ((string? d) (string->symbol d))
        ((pair? d)   (cons (ns->s (car d)) (ns->s (cdr d))))
        ((vector? d) (vector-map ns->s d))
        (else        d)))
(define (plift racket-proc) (lambda (a) (apply racket-proc a)))
(define (procedure=? m n)   (eq? m n))
(define (number=? m n)      (eqv? m n))
(struct mvector (v) #:transparent)
(define (make-mvector k d)          (mvector (make-vector k d)))
(define (mvector=? m n)             (eq? m n))
(define (mvector-length mv)         (vector-length (mvector-v mv)))
(define (mvector-ref mv i)          (vector-ref (mvector-v mv) i))
(define (mvector-set! mv i new)     (vector-set! (mvector-v mv) i new) #t)
;; TODO: update Racket to use this.
;(define (mvector-cas! mv i old new) (vector-cas! (mvector-v mv) i old new))
(define (mvector->vector mv)        (vector-copy (mvector-v mv)))
(define (string->vector s) (list->vector (map char->integer (string->list s))))
(define (vector->string v) (list->string (map integer->char (vector->list v))))
(define ($apply proc arg) (proc arg))

(define (alist-ref rs key default)
  (define rib (assoc key rs))
  (if rib (cdr rib) default))
(define (alist-remove* rs keys)
  (filter (lambda (rib) (not (member (car rib) keys))) rs))
(define (list-at xs ?)  ;; produce a zipper referencing the desired location
  (let loop ((suffix xs) (prefix '()))
    (if (or (null? suffix) (? (car suffix))) (cons suffix prefix)
      (loop (cdr suffix) (cons (car suffix) prefix)))))
(define (alist-at rs key) (list-at rs (lambda (kv) (equal? (car kv) key))))

;; Pattern matching
(define (length=? n xs)  (and (list? xs) (= (length xs) n)))
(define (length>=? n xs) (and (list? xs) (>= (length xs) n)))
(define (param?! param) (unless (andmap string? (param-names param))
                          (error '"invalid parameters:" param)))
(define (bpair*?! b*)
  (define (? b) (and (length=? 2 b) (param?! (car b))))
  (unless (and (list? b*) (andmap ? b*)) (error '"invalid binding list:" b*)))

;; Formal parameters
(define (ncons name names)
  (when (member name names) (error '"duplicate name:" name names))
  (cons name names))
(define (param-map f p)
  (cond ((pair? p)   (cons (param-map f (car p)) (param-map f (cdr p))))
        ((vector? p) (list->vector (param-map f (vector->list p))))
        ((null? p)   '())
        ((not p)     #f)
        (#t          (f p))))
(define (param-names param)
  (let loop ((p param) (ns '()))
    (cond ((pair? p)   (loop (cdr p) (loop (car p) ns)))
          ((vector? p) (loop (vector->list p) ns))
          ((null? p)   ns)
          ((not p)     ns)
          (#t          (ncons p ns)))))
(define (param-bind param arg)
  (let loop ((p param) (a arg))
    (cond ((and (pair? p) (pair? a)) (append (loop (car p) (car a))
                                             (loop (cdr p) (cdr a))))
          ((and (vector? p) (vector? a))
           (loop (vector->list p) (vector->list a)))
          ((and (null? p) (null? a)) '())
          ((not p)                   '())
          ((not (or (pair? p) (vector? p) (null? p))) (list (cons p a)))
          (#t (error '"parameter/argument mismatch:" param arg p a)))))

(define ctx:var  '"ref")
(define ctx:set! '"set!")
(define ctx:op   '"syntax?")
(define ctx:def  '"define")
(define env:empty                      '())
(define (env-ref env n)                (alist-ref env n '()))
(define (env-ref-prop env n k default) (alist-ref (env-ref env n) k default))
(define (env-pre-extend* env n*)       (alist-remove* env n*))
(define (env-extend* env b*)           (append b* env))

(define (defstate:empty env)  (vector env '() '()))
(define (defstate-env st)     (vector-ref st 0))
(define (defstate-names st)   (vector-ref st 1))
(define (defstate-actions st) (vector-ref st 2))
(define (defstate-env-set st env)
  (vector env (defstate-names st) (defstate-actions st)))
(define (defstate-names-add st names)
  (define new (foldl ncons (defstate-names st) names))
  (vector (defstate-env st) new (defstate-actions st)))
(define (defstate-actions-add st act)
  (define new (cons act (defstate-actions st)))
  (vector (defstate-env st) (defstate-names st) new))
