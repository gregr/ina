(define (fresh-address name) (vector name))

(define (case-lambda-clause param body) (vector param body))
(define (case-lambda-clause-param cc)   (vector-ref cc 0))
(define (case-lambda-clause-body  cc)   (vector-ref cc 1))

;; TODO: support for lower-level language integration:
;; - E:unchecked-call, E:let with type info, E:case-lambda with type info, etc.
(define (E:annotated   pv E)           (vector 'E:annotated   pv E))
(define (E:prim        name)           (vector 'E:prim        name))
(define (E:quote       v)              (vector 'E:quote       v))
(define (E:ref         address)        (vector 'E:ref         address))
(define (E:if          c t f)          (vector 'E:if          c t f))
(define (E:call        proc args)      (vector 'E:call        proc args))
(define (E:case-lambda clause*)        (vector 'E:case-lambda clause*))
(define (E:letrec      lhs* rhs* body) (vector 'E:letrec      lhs* rhs* body))

(define (E-tag                   E)     (vector-ref E 0))
(define (E-tagged?               E tag) (eq? (E-tag E) tag))
(define (E:annotated?            E)     (E-tagged? E 'E:annotated))
(define (E:prim?                 E)     (E-tagged? E 'E:prim))
(define (E:quote?                E)     (E-tagged? E 'E:quote))
(define (E:ref?                  E)     (E-tagged? E 'E:ref))
(define (E:if?                   E)     (E-tagged? E 'E:if))
(define (E:call?                 E)     (E-tagged? E 'E:call))
(define (E:case-lambda?          E)     (E-tagged? E 'E:case-lambda))
(define (E:letrec?               E)     (E-tagged? E 'E:letrec))
(define (E:annotated-provenance  E)     (vector-ref E 1))
(define (E:annotated-E           E)     (vector-ref E 2))
(define (E:prim-name             E)     (vector-ref E 1))
(define (E:quote-value           E)     (vector-ref E 1))
(define (E:ref-address           E)     (vector-ref E 1))
(define (E:if-condition          E)     (vector-ref E 1))
(define (E:if-consequent         E)     (vector-ref E 2))
(define (E:if-alternative        E)     (vector-ref E 3))
(define (E:call-procedure        E)     (vector-ref E 1))
(define (E:call-argument*        E)     (vector-ref E 2))
(define (E:case-lambda-clause*   E)     (vector-ref E 1))
(define (E:letrec-binding-left*  E)     (vector-ref E 1))
(define (E:letrec-binding-right* E)     (vector-ref E 2))
(define (E:letrec-body           E)     (vector-ref E 3))

(define (E-provenance     E) (and (E:annotated? E) (E:annotated-provenance E)))
(define (E-provenance-add E pv)
  (E:annotated (let ((pv1 pv) (pv2 (E-provenance E)))
                 (cond ((not pv1)     pv2)
                       ((not pv2)     pv1)
                       ((eq? pv1 pv2) pv1)
                       (else          (cons pv1 pv2))))
               (if (E:annotated? E) (E:annotated-E E) E)))
