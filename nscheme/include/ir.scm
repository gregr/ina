(define (case-lambda-clause param body) (vector param body))
(define (case-lambda-clause-param cc)   (vector-ref cc 0))
(define (case-lambda-clause-body  cc)   (vector-ref cc 1))

(define (provenance-combine pv1 pv2)
  (cond ((not pv1)     pv2)
        ((not pv2)     pv1)
        ((eq? pv1 pv2) pv1)
        (else          (cons pv1 pv2))))

(define (E-tag            E)     (vector-ref E 0))
(define (E-provenance     E)     (vector-ref E 1))
(define (E-provenance-set E pv)  (let ((parts (vector->list E)))
                                   (list->vector (cons (car parts) (cons pv (cddr parts))))))
(define (E-provenance-add E pv)  (E-provenance-set E (provenance-combine pv (E-provenance E))))
(define (E-tagged?        E tag) (eq? (E-tag E) tag))

(define (fresh-address name) (vector name))

;; TODO: support for lower-level language integration:
;; - E:unchecked-call, E:let with type info, E:case-lambda with type info, etc.
(define (E:prim        pv name)           (vector 'E:prim        pv name))
(define (E:quote       pv v)              (vector 'E:quote       pv v))
(define (E:ref         pv address)        (vector 'E:ref         pv address))
(define (E:if          pv c t f)          (vector 'E:if          pv c t f))
(define (E:call        pv proc args)      (vector 'E:call        pv proc args))
(define (E:case-lambda pv clause*)        (vector 'E:case-lambda pv clause*))
(define (E:letrec      pv lhs* rhs* body) (vector 'E:letrec      pv lhs* rhs* body))

(define (E:prim?        E) (E-tagged? E 'E:prim))
(define (E:quote?       E) (E-tagged? E 'E:quote))
(define (E:ref?         E) (E-tagged? E 'E:ref))
(define (E:if?          E) (E-tagged? E 'E:if))
(define (E:call?        E) (E-tagged? E 'E:call))
(define (E:case-lambda? E) (E-tagged? E 'E:case-lambda))
(define (E:letrec?      E) (E-tagged? E 'E:letrec))

(define (E:prim-name             E) (vector-ref E 2))
(define (E:quote-value           E) (vector-ref E 2))
(define (E:ref-address           E) (vector-ref E 2))
(define (E:if-condition          E) (vector-ref E 2))
(define (E:if-consequent         E) (vector-ref E 3))
(define (E:if-alternative        E) (vector-ref E 4))
(define (E:call-procedure        E) (vector-ref E 2))
(define (E:call-argument*        E) (vector-ref E 3))
(define (E:case-lambda-clause*   E) (vector-ref E 2))
(define (E:letrec-binding-left*  E) (vector-ref E 2))
(define (E:letrec-binding-right* E) (vector-ref E 3))
(define (E:letrec-body           E) (vector-ref E 4))
