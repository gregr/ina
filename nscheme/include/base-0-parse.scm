;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Parsing expressions ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (parse-quote        env e)           (ast:quote (syntax-provenance e) (syntax->datum e)))
(define (parse-quote-syntax env e)           (ast:quote (syntax-provenance e) e))
(define (parse-if           env e.c e.t e.f) ($if (parse-expression env e.c)
                                                  (parse-expression env e.t)
                                                  (parse-expression env e.f)))
(define (parse-lambda       env param . e*)  (parse-case-lambda env (cons param e*)))

(define (parse-case-lambda env . e*.cc)
  (define (parse-case-lambda-clause e.cc)
    (let ((e* (syntax->list e.cc)))
      (when (or (null? e*) (null? (cdr e*))) (raise-syntax-error "not a case-lambda clause" e.cc))
      ($case-lambda-clause env (syntax->improper-list (car e*))
                           (lambda (env . _) (parse-body env (cdr e*))))))
  (ast:case-lambda #f (map parse-case-lambda-clause e*.cc)))

(define (parse-and    env . e*) (apply $and    (parse-expression* env e*)))
(define (parse-or     env . e*) (apply $or     (parse-expression* env e*)))
(define (parse-when   env . e*) (apply $when   (parse-expression* env e*)))
(define (parse-unless env . e*) (apply $unless (parse-expression* env e*)))

(define (parse-cond env clause . clause*)
  (let loop ((c* (cons clause clause*)))
    (cond ((null? c*) $void)
          (else (let* ((c (car c*)) (c* (cdr c*)) (e* (syntax->list c)))
                  (when (null? e*) (raise-syntax-error "empty clause" c))
                  (let ((e.test (car e*)) (e* (cdr e*)))
                    (cond ((expression-auxiliary? 'else env e.test)
                           (unless (null? e*)      (raise-syntax-error "empty else clause" c))
                           (unless (null? clause*) (raise-syntax-error "else clause is not last" c))
                           (parse-body env e*))
                          ((null? e*)
                           ($let env '(test) (list (parse-expression env e.test))
                                 (lambda (_ addr.test)
                                   ($if ($ref addr.test) ($ref addr.test) (loop c*)))))
                          ((expression-auxiliary? '=> env (car e*))
                           (unless (and (pair? (cdr e*)) (null? (cddr e*)))
                             (raise-syntax-error "=> is not followed by one procedure" c))
                           ($let env '(test) (list (parse-expression env e.test))
                                 (lambda (_ addr.test)
                                   ($if ($ref addr.test)
                                        ($call (parse-expression env (cadr e*)) ($ref addr.test))
                                        (loop c*)))))
                          (else ($if (parse-expression env e.test)
                                     (parse-body env e*)
                                     (loop c*))))))))))

(define ((parse-case/$= $=) env e clause . clause*)
  ($let
    env '(x) (list (parse-expression env e))
    (lambda (_ addr.x)
      (let (($x ($ref addr.x)))
        (let loop ((c* (cons clause clause*)))
          (cond
            ((null? c*) $void)
            (else (let* ((c (car c*)) (c* (cdr c*)) (e* (syntax->list c)))
                    (when (null? e*) (raise-syntax-error "empty clause" c))
                    (let ((e.data (car e*)) (e* (cdr e*)))
                      (cond
                        ((null? e*) (raise-syntax-error "empty clause body" c))
                        ((expression-auxiliary? 'else env e.data)
                         (unless (null? e*)      (raise-syntax-error "empty else clause" c))
                         (unless (null? clause*) (raise-syntax-error "else clause is not last" c))
                         (parse-body env e*))
                        ((expression-auxiliary? '=> env e.data)
                         (unless (null? (cdr e*))
                           (raise-syntax-error "=> is not followed by one procedure" c))
                         (unless (null? clause*) (raise-syntax-error "=> clause is not last" c))
                         ($call (parse-expression env (car e*)) $x))
                        (else ($if (apply $or (map (lambda (d) ($= $x ($quote d)))
                                                   (syntax->list e.data)))
                                   (parse-body env e*)
                                   (loop c*)))))))))))))

(define parse-caseq (parse-case/$= $eq?))
(define parse-casev (parse-case/$= $eqv?))

(define (parse-let env e0 e1 . e*)
  (if (identifier? e0)
      (let* ((bpair* (parse-binding-pairs e1)) (param* (map car bpair*)))
        (apply $call ($letrec env (list e0)
                              (lambda (env _)  (list ($lambda env param* (lambda (env . _)
                                                                           (parse-body env e*)))))
                              (lambda (_ addr) ($ref addr)))
               (parse-expression* env (map cdr bpair*))))
      (let* ((bpair* (parse-binding-pairs e0)) (param* (map car bpair*)))
        ($let env param* (parse-expression* env (map cdr bpair*))
              (lambda (env . _) (parse-body env (cons e1 e*)))))))

(define (parse-begin-expression env e . e*)
  (let loop ((e e) (e* e*))
    (cond ((null? e*) (parse-expression env e))
          (else       ($begin (parse-expression env e) (loop (car e*) (cdr e*)))))))

(splicing-local
  ((define (etc-splicing-expression-operator-parser $splicing stx*->^body)
     (expression-operator-parser
       (lambda (env stx.def* . stx*)
         ($body env (lambda (dst scope env) ($splicing dst scope env stx.def* (stx*->^body stx*)))))
       2 #f)))

  (define (nonsplicing-expression-operator-parser $splicing)
    (etc-splicing-expression-operator-parser
      $splicing (lambda (stx*) (lambda (dst scope env)
                                 (defstate-add-expression dst (lambda () (parse-body env stx*)))))))

  (define (splicing-expression-operator-parser $splicing)
    (etc-splicing-expression-operator-parser
      $splicing (lambda (stx*) (lambda (dst scope env)
                                 (defstate-add-expression
                                   dst (lambda () (parse-begin-expression env stx*))))))))

(define (parse-quasiquote env stx.qq)
  (define (finish quote? x) (if quote? (parse-quote env x) x))
  (define (operand qq) (car (syntax-unwrap (cdr qq))))
  (define (operation? qq tag)
    (and (pair? qq)
         (let ((qq.d (syntax-unwrap (cdr qq))))
           (and (pair? qq.d)
                (let ((qq.dd (syntax-unwrap (cdr qq.d))))
                  (and (null? qq.dd)
                       (identifier? (car qq))
                       (eq? (env-ref^ env (car qq) vocab.quasiquote) tag)))))))
  (define (tag tag-value P) ($list ($quote tag-value) P))
  (let-values
    (((quote? e)
      (let loop ((stx.qq stx.qq) (level 0))
        (let ((qq (syntax-unwrap stx.qq)))
          (cond ((and (= level 0) (pair? qq)
                      (let ((qq.a (syntax-unwrap (car qq))))
                        (operation? qq.a 'unquote-splicing)))
                 (let ((rand (operand (syntax-unwrap (car qq)))))
                   (let-values (((quote? rest) (loop (cdr qq) level)))
                     (let ((rest (finish quote? rest)))
                       (values #f ($append (parse-expression env rand) rest))))))
                ((and (< 0 level) (operation? qq 'unquote-splicing))
                 (let ((rand (operand qq)))
                   (let-values (((quote? e) (loop rand (- level 1))))
                     (if quote?
                         (values #t stx.qq)
                         (values #f (tag 'unquote-splicing e))))))
                ((operation? qq 'unquote)
                 (let ((rand (operand qq)))
                   (if (= level 0)
                       (values #f (parse-expression env rand))
                       (let-values (((quote? e) (loop rand (- level 1))))
                         (if quote?
                             (values #t stx.qq)
                             (values #f (tag 'unquote e)))))))
                ((operation? qq 'quasiquote)
                 (let ((rand (operand qq)))
                   (let-values (((quote? e) (loop rand (+ level 1))))
                     (if quote?
                         (values #t stx.qq)
                         (values #f (tag 'quasiquote e))))))
                ((pair? qq)
                 (let-values (((quote.a? a) (loop (car qq) level))
                              ((quote.b? b) (loop (cdr qq) level)))
                   (if (and quote.a? quote.b?)
                       (values #t stx.qq)
                       (values #f ($cons (finish quote.a? a) (finish quote.b? b))))))
                ((vector? qq)
                 (let-values (((quote? e) (loop (vector->list qq) level)))
                   (if quote?
                       (values #t stx.qq)
                       (values #f ($pcall 'apply ($prim 'vector) e)))))
                (else (when (and (identifier? stx.qq) (env-ref^ env stx.qq vocab.quasiquote))
                        (raise-syntax-error "misplaced quasiquote operator" stx.qq))
                      (values #t stx.qq)))))))
    (finish quote? e)))

(define (pattern:any             pv)           (vector 'any      pv))
(define (pattern:none            pv)           (vector 'none     pv))
(define (pattern:var             pv id)        (vector 'var      pv id))
(define (pattern:quote           pv stx.value) (vector 'quote    pv stx.value))
(define (pattern:?               pv $?)        (vector '?        pv $?))
(define (pattern:app             pv $proc P)   (vector 'app      pv $proc P))
(define (pattern:and             pv P1 P2)     (vector 'and      pv P1 P2))
(define (pattern:or              pv P1 P2)     (vector 'or       pv P1 P2))
(define (pattern:not             pv P)         (vector 'not      pv P))
(define (pattern:cons            pv P1 P2)     (vector 'cons     pv P1 P2))
(define (pattern:vector          pv P*)        (vector 'vector   pv P*))
(define (pattern:ellipsis        pv P)         (vector 'ellipsis pv P))
(define (pattern:ellipsis-append pv P.ellipsis P.suffix length.suffix)
  (vector 'ellipsis-append pv P.ellipsis P.suffix length.suffix))
(define (pattern:ellipsis-vector pv P*.prefix P.ellipsis P*.suffix)
  (vector 'ellipsis-vector pv P*.prefix P.ellipsis P*.suffix))

(define (pattern:any?             p) (ast-tagged? p 'any))
(define (pattern:none?            p) (ast-tagged? p 'none))
(define (pattern:var?             p) (ast-tagged? p 'var))
(define (pattern:quote?           p) (ast-tagged? p 'quote))
(define (pattern:??               p) (ast-tagged? p '?))
(define (pattern:app?             p) (ast-tagged? p 'app))
(define (pattern:and?             p) (ast-tagged? p 'and))
(define (pattern:or?              p) (ast-tagged? p 'or))
(define (pattern:not?             p) (ast-tagged? p 'not))
(define (pattern:cons?            p) (ast-tagged? p 'cons))
(define (pattern:vector?          p) (ast-tagged? p 'vector))
(define (pattern:ellipsis?        p) (ast-tagged? p 'ellipsis))
(define (pattern:ellipsis-append? p) (ast-tagged? p 'ellipsis-append))
(define (pattern:ellipsis-vector? p) (ast-tagged? p 'ellipsis-vector))

(define (pattern:var-identifier                p) (vector-ref p 2))
(define (pattern:quote-value-syntax            p) (vector-ref p 2))
(define (pattern:?-predicate                   p) (vector-ref p 2))
(define (pattern:app-procedure                 p) (vector-ref p 2))
(define (pattern:app-inner                     p) (vector-ref p 3))
(define (pattern:and-left                      p) (vector-ref p 2))
(define (pattern:and-right                     p) (vector-ref p 3))
(define (pattern:or-left                       p) (vector-ref p 2))
(define (pattern:or-right                      p) (vector-ref p 3))
(define (pattern:not-inner                     p) (vector-ref p 2))
(define (pattern:cons-car                      p) (vector-ref p 2))
(define (pattern:cons-cdr                      p) (vector-ref p 3))
(define (pattern:vector-element*               p) (vector-ref p 2))
(define (pattern:ellipsis-inner                p) (vector-ref p 2))
(define (pattern:ellipsis-append-ellipsis      p) (vector-ref p 2))
(define (pattern:ellipsis-append-suffix        p) (vector-ref p 3))
(define (pattern:ellipsis-append-suffix-length p) (vector-ref p 4))
(define (pattern:ellipsis-vector-prefix        p) (vector-ref p 2))
(define (pattern:ellipsis-vector-ellipsis      p) (vector-ref p 3))
(define (pattern:ellipsis-vector-suffix        p) (vector-ref p 4))

(define $p:any                       (pattern:any      #f))
(define $p:none                      (pattern:none     #f))
(define ($p:var             id)      (pattern:var      #f id))
(define ($p:quote           v)       (pattern:quote    #f v))
(define ($p:?               $?)      (pattern:?        #f $?))
(define ($p:app             $proc P) (pattern:app      #f $proc P))
(define ($p:and             a b)     (pattern:and      #f a b))
(define ($p:or              a b)     (pattern:or       #f a b))
(define ($p:not             P)       (pattern:not      #f P))
(define ($p:cons            a b)     (pattern:cons     #f a b))
(define ($p:vector          P*)      (pattern:vector   #f P*))
(define ($p:ellipsis        P)       (pattern:ellipsis #f P))
(define ($p:list            . P*)    (foldr $p:cons ($p:quote '()) P*))
(define ($p:ellipsis-append P.ellipsis P.suffix length.suffix)
  (pattern:ellipsis-append #f P.ellipsis P.suffix length.suffix))
(define ($p:ellipsis-vector P*.prefix P.ellipsis P*.suffix)
  (pattern:ellipsis-vector #f P*.prefix P.ellipsis P*.suffix))

(define (linear-pattern-compile P)
  (define (raise-pattern-error msg P)
    (raise-syntax-error msg (syntax-provenance-set (ast-provenance-set P #f) (ast-provenance P))))
  (define (pattern->linear-pattern&variable* P)
    (define id-set.empty            '())
    (define (id-set-add     id* id) (cons id id*))
    (define (id-set-member? id* id) (memp (lambda (x) (bound-identifier=? id x)) id*))
    (define ($$p:quote value) ($p:? (ast:lambda #f '(x) ($eqv? ($ref 'x) ($quote value)))))
    (define ($$p:cons  a b)   ($p:and ($p:? ($prim 'pair?)) ($p:and ($p:app ($prim 'car) a)
                                                                    ($p:app ($prim 'cdr) b))))
    (define ($$p:vector p*)
      (let loop ((i       0)
                 (p*      p*)
                 (current ($p:and ($p:? ($prim 'vector?))
                                  ($p:? (ast:lambda #f '(x) ($eqv? ($pcall 'vector-length ($ref 'x))
                                                                   ($quote (length p*))))))))
        (cond ((null? p*) current)
              (else (loop (+ i 1) (cdr p*)
                          ($p:and current ($p:app (ast:lambda
                                                    #f '(x) ($pcall 'vector-ref ($ref 'x) ($quote i)))
                                                  (car p*))))))))
    (let loop ((P P) (id* id-set.empty))
      (let ((pv (ast-provenance P)))
        (define (wrap P) (ast-provenance-add P pv))
        (cond
          ((or (pattern:any? P) (pattern:none? P) (pattern:?? P)) (values P id*))
          ((pattern:var? P)
           (let ((id (pattern:var-identifier P)))
             (unless id* (raise-syntax-error "disallowed pattern variable" id))
             (when (id-set-member? id* id)
               (raise-syntax-error "duplicate pattern variable" id))
             (values P (id-set-add id* id))))
          ((pattern:quote? P)
           (values (wrap (let loop ((stx.value (pattern:quote-value-syntax P)))
                           (let ((q (syntax-unwrap stx.value)))
                             ($provenance
                               (cond ((pair?   q) ($$p:cons (loop (car q)) (loop (cdr q))))
                                     ((vector? q) ($$p:vector (map loop (vector->list q))))
                                     (else        ($$p:quote q)))
                               stx.value))))
                   id*))
          ((pattern:cons? P)
           (let ((P.a (pattern:cons-car P)) (P.d (pattern:cons-cdr P)))
             (if (pattern:ellipsis? P.a)
                 (let ((P.a (pattern:ellipsis-inner P.a)))
                   (let ((len (let len+check ((P P.d) (len 0))
                                (cond ((pattern:cons? P)
                                       (when (pattern:ellipsis? (pattern:cons-car P))
                                         (raise-pattern-error "too many ellipses"
                                                              (pattern:cons-car P)))
                                       (len+check (pattern:cons-cdr P) (+ len 1)))
                                      (else len)))))
                     (let*-values (((P.a id*) (loop P.a id*))
                                   ((P.d id*) (loop P.d id*)))
                       (values (wrap ($p:ellipsis-append P.a P.d len)) id*))))
                 (let*-values (((P.a id*) (loop P.a id*))
                               ((P.d id*) (loop P.d id*)))
                   (values (wrap ($$p:cons P.a P.d)) id*)))))
          ((pattern:vector? P)
           (let* ((P*  (pattern:vector-element* P))
                  (Pe* (filter pattern:ellipsis? P*)))
             (cond ((pair? Pe*)
                    (when (pair? (cdr Pe*)) (raise-pattern-error "too many ellipses" P))
                    (let vloop ((P (car P*)) (P* (cdr P*)) (prefix* '()))
                      (cond ((pattern:ellipsis? P)
                             (let-values (((P id*) (loop (pattern:ellipsis-inner P) id*)))
                               (let vloop ((P* P*) (rP* '()) (id* id*))
                                 (cond ((null? P*)
                                        (values (wrap ($p:ellipsis-vector
                                                        (reverse prefix*) P (reverse rP*)))
                                                id*))
                                       (else (let-values (((P id*) (loop (car P*) id*)))
                                               (vloop (cdr P*) (cons P rP*) id*)))))))
                            (else (let-values (((P id*) (loop P id*)))
                                    (vloop (car P*) (cdr P*) (cons P prefix*)))))))
                   (else (let vloop ((P* P*) (rP* '()) (id* id*))
                           (cond ((null? P*) (values (wrap ($$p:vector (reverse rP*))) id*))
                                 (else (let-values (((P id*) (loop (car P*) id*)))
                                         (vloop (cdr P*) (cons P rP*) id*)))))))))
          ((pattern:app? P) (let-values (((P.inner id*) (loop (pattern:app-inner P) id*)))
                              (values (wrap ($p:app (pattern:app-procedure P) P.inner)) id*)))
          ((pattern:and? P) (let*-values (((P.l id*) (loop (pattern:and-left P) id*))
                                          ((P.r id*) (loop (pattern:and-right P) id*)))
                              (values (wrap ($p:and P.l P.r)) id*)))
          ((pattern:or?  P) (let*-values
                              (((P.l id*.l) (loop (pattern:or-left P) (and id* id-set.empty)))
                               ((P.r id*.r) (loop (pattern:or-right P) (and id* id-set.empty))))
                              (define (check id*.0 id*.1)
                                (for-each (lambda (id)
                                            (unless (id-set-member? id*.1 id)
                                              (raise-syntax-error
                                                "pattern variable not in both disjuncts" id))
                                            (when (id-set-member? id* id)
                                              (raise-syntax-error "duplicate pattern variable" id)))
                                          id*.0))
                              (when id* (check id*.l id*.r) (check id*.r id*.l))
                              (values (wrap ($p:or P.l P.r))
                                      (foldl (lambda (id id*) (id-set-add id* id)) id* id*.l))))
          ((pattern:not? P) (let-values (((P.inner _) (loop (pattern:not-inner P) #f)))
                              (values (wrap ($p:not P.inner)) id*)))
          (else             (raise-pattern-error "unsupported pattern" P))))))
  (define ((wrap pv ^ast) . args) (ast-provenance-add (apply ^ast args) pv))
  (define (($$?   $?)    succeed fail $x env) ($if ($call $? $x) (succeed env) (fail env)))
  (define (($$and ^a ^b) succeed fail $x env) (^a (lambda (env) (^b succeed fail $x env))
                                                  fail $x env))
  (define (($$or  ^a ^b) succeed fail $x env) (^a succeed (lambda (env) (^b succeed fail $x env))
                                                  $x env))
  (define (($$app $proc ^p) succeed fail $x env)
    (let* ((x.app.addr (fresh-address 'x.app)) ($x.app ($ref x.app.addr)))
      (ast:let #f (list x.app.addr) (list ($call $proc $x)) (^p succeed fail $x.app env))))
  (let-values (((P id*) (pattern->linear-pattern&variable* P)))
    (values
      (let loop ((P P))
        (wrap
          (ast-provenance P)
          (cond
            ((pattern:any?  P) (lambda (succeed fail $x env) (succeed env)))
            ((pattern:none? P) (lambda (succeed fail $x env) (fail    env)))
            ((pattern:var?  P) (let ((id (pattern:var-identifier P)))
                                 (lambda (succeed fail $x env)
                                   ($let env (list id) (list $x) (lambda (env $x) (succeed env))))))
            ((pattern:??    P) ($$? (pattern:?-predicate P)))
            ((pattern:app?  P) ($$app (pattern:app-procedure P) (loop (pattern:app-inner P))))
            ((pattern:and?  P) ($$and (loop (pattern:and-left P)) (loop (pattern:and-right P))))
            ((pattern:or?   P) ($$or (loop (pattern:or-left P)) (loop (pattern:or-right P))))
            ((pattern:not?  P) (let ((^p (loop (pattern:not-inner P))))
                                 (lambda (succeed fail $x env) (^p fail succeed $x env))))
            ;((pattern:ellipsis-vector? p)
            ; ;; TODO: vector-length must be at least (+ (length P*.prefix) (length P*.suffix))
            ; ;; and (vector-ref v (- len i)) for each i in (length P*.suffix)
            ; ;; then match (length P*.prefix) through (- len (length P*.suffix)) against
            ; ;; P.ellipsis to build up a list of results.
            ; )
            ;((pattern:ellipsis-append? p)
            ; ;; TODO: improper-reverse $x, match P.tail, then rP*.suffix,
            ; ;; then match the rest against P.ellipsis to build up a list of results.
            ; )
            (else              (raise-pattern-error "unsupported pattern" P)))))
      id*)))

(define (parse-pattern-any    _ __)                $p:any)
(define (parse-pattern-var    _ stx.id)            ($p:var stx.id))
(define (parse-pattern-quote  _ stx.value)         ($p:quote stx.value))
(define (parse-pattern-vector env . stx*)          ($p:vector (parse-pattern* env stx*)))
(define (parse-pattern-list   env . stx*)          (apply $p:list (parse-pattern* env stx*)))
(define (parse-pattern-cons   env stx.car stx.cdr) ($p:cons (parse-pattern env stx.car)
                                                            (parse-pattern env stx.cdr)))
(define (parse-pattern-cons* env stx . stx*)
  (let loop ((stx stx) (stx* stx*))
    (let ((P (parse-pattern env stx)))
      (cond ((null? stx*) P)
            ((pattern-auxiliary? '... env (car stx*))
             (let ((stx* (cdr stx*))
                   (P    (pattern:ellipsis (syntax-provenance (car stx*)) P)))
               (if (null? stx*)
                   P
                   ($p:cons P (loop (car stx*) (cdr stx*))))))
            (else ($p:cons P (loop (car stx*) (cdr stx*))))))))
(define ((parse-pattern/connective $p:connect $p:null) env . stx*)
  (if (null? stx*)
      $p:null
      (let loop ((stx (car stx*)) (stx* (cdr stx*)))
        (let ((P (parse-pattern env stx)))
          (cond ((null? stx*) P)
                (else         ($p:connect P (loop (car stx*) (cdr stx*)))))))))
(define parse-pattern-and (parse-pattern/connective $p:and $p:any))
(define parse-pattern-or  (parse-pattern/connective $p:or  $p:none))
(define (parse-pattern-not env stx) ($p:not (parse-pattern env stx)))
(define (parse-pattern-? env stx.? . stx*)
  (let ((P.? ($p:? (parse-expression env stx.?))))
    (if (null? stx*) P.? ($p:and P.? (apply parse-pattern-and env stx*)))))
(define (parse-pattern-app env stx.proc . stx*.subpattern)
  ($p:app (parse-expression env stx.proc) (apply parse-pattern-and env stx*.subpattern)))
(define (parse-pattern* env stx*)
  (if (null? stx*)
      '()
      (let loop ((stx (car stx*)) (stx* (cdr stx*)))
        (let ((P (parse-pattern env stx)))
          (cond ((null? stx*) (list P))
                ((pattern-auxiliary? '... env (car stx*))
                 (let ((stx (car stx*)) (stx* (cdr stx*)))
                   (cons (pattern:ellipsis (syntax-provenance stx) P)
                         (if (null? stx*) '() (loop (car stx*) (cdr stx*))))))
                (else (cons P (loop (car stx*) (cdr stx*)))))))))

(define (parse-pattern env stx)
  ($provenance
    (let ((x (syntax-unwrap stx)))
      (cond
        ((identifier? stx) (let ((op (env-ref^ env stx vocab.pattern)))
                             (if (procedure? op) (op env stx) ($p:var stx))))
        ((pair?    x)      (let* ((e.op (car x))
                                  (op   (and (identifier? e.op)
                                             (env-ref^ env e.op vocab.pattern-operator))))
                             (if (procedure? op)
                                 (op env stx)
                                 (raise-syntax-error "not a match pattern" stx))))
        ((literal? x)      ($p:quote x))
        (else              (raise-syntax-error "not a pattern" stx))))
    stx))
(define (parse-pattern-quasiquote env stx.qq)
  (define (operand qq) (car (syntax-unwrap (cdr qq))))
  (define (operation? qq tag)
    (and (pair? qq)
         (let ((qq.d (syntax-unwrap (cdr qq))))
           (and (pair? qq.d)
                (let ((qq.dd (syntax-unwrap (cdr qq.d))))
                  (and (null? qq.dd)
                       (identifier? (car qq))
                       (eq? (env-ref^ env (car qq) vocab.quasiquote) tag)))))))
  (define (tag tag-value P) ($p:list ($p:quote tag-value) P))
  (define (pqq* stx* level)
    (if (null? stx*)
        '()
        (let pqq.loop ((stx (car stx*)) (stx* (cdr stx*)))
          (let ((P (loop stx level)))
            (cond ((null? stx*) (list P))
                  ((pattern-auxiliary? '... env (car stx*))
                   (let ((stx (car stx*)) (stx* (cdr stx*)))
                     (cons (pattern:ellipsis (syntax-provenance stx) P)
                           (if (null? stx*) '() (pqq.loop (car stx*) (cdr stx*))))))
                  (else (cons P (pqq.loop (car stx*) (cdr stx*)))))))))
  (define (loop stx.qq level)
    (let ((qq (syntax-unwrap stx.qq)))
      (cond ((operation? qq 'unquote)    (let ((rand (operand qq)))
                                           (if (= level 0)
                                               (parse-pattern env rand)
                                               (tag 'unquote (loop rand (- level 1))))))
            ((operation? qq 'quasiquote) (tag 'quasiquote (loop (operand qq) (+ level 1))))
            ((pair?      qq)             (let (($p:a (loop (car qq) level))
                                               (qq.d (syntax-unwrap (cdr qq))))
                                           (if (and (pair? qq.d)
                                                    (pattern-auxiliary? '... env (car qq.d)))
                                               ($p:cons (pattern:ellipsis
                                                          (syntax-provenance (car qq.d)) $p:a)
                                                        (loop (cdr qq.d) level))
                                               ($p:cons $p:a (loop (cdr qq) level)))))
            ((vector?    qq)             ($p:vector (pqq* (vector->list qq) level)))
            (else (when (and (identifier? stx.qq) (env-ref^ env stx.qq vocab.quasiquote))
                    (raise-syntax-error "misplaced quasiquote pattern operator" stx.qq))
                  ($p:quote stx.qq)))))
  (loop stx.qq 0))

(define ((match-pattern-operator-parser parser argc.min argc.max) env stx)
  (let* ((stx* (syntax->list stx)) (argc (- (length stx*) 1)))
    (unless (<= argc.min argc)           (raise-syntax-error "too few operator arguments"  stx))
    (unless (<= argc (or argc.max argc)) (raise-syntax-error "too many operator arguments" stx))
    (apply parser env (cdr stx*))))

(define ((parse-match/parse-pattern parse-pattern) env stx.e . stx*.clause*)
  (let (($x ($ref 'x)) ($fail ($call ($ref 'fail))))
    (ast:let
      #f '(x) (list (parse-expression env stx.e))
      (ast:let
        #f '(fail) (list (ast:lambda #f '() ($pcall 'panic ($quote "no matching clause") $x)))
        (let loop ((stx*.clause* stx*.clause*))
          (cond
            ((null? stx*.clause*) $fail)
            (else
              (let ((clause (syntax-unwrap (car stx*.clause*))))
                (unless (and (pair? clause) (pair? (syntax-unwrap (cdr clause))))
                  (raise-syntax-error "not a match clause" (car stx*.clause*)))
                (let*-values (((stx.body)       (cdr clause))
                              ((^pattern id*.P) (linear-pattern-compile
                                                  (parse-pattern env (car clause)))))
                  (ast:let
                    #f '(fail) (list (ast:lambda #f '() (loop (cdr stx*.clause*))))
                    (ast:let
                      #f '(succeed)
                      (list ($lambda
                              env id*.P
                              (lambda (env . _)
                                (let* ((body  (syntax-unwrap stx.body))
                                       (test* (let ((fender (syntax-unwrap (car body))))
                                                (and (pair? fender)
                                                     (expression-auxiliary? 'guard env (car fender))
                                                     (syntax->list (cdr fender))))))
                                  (if test*
                                      (if (pair? test*)
                                          ($if (apply $and (parse-expression* env test*))
                                               (parse-body env (cdr body))
                                               $fail)
                                          (raise-syntax-error "not a guard" (car body)))
                                      (parse-body env stx.body))))))
                      ($provenance
                        (^pattern
                          (lambda (env) (apply $call ($ref 'succeed) (parse-expression* env id*.P)))
                          (lambda (_) $fail)
                          $x env)
                        (car stx*.clause*)))))))))))))

(define parse-match  (parse-match/parse-pattern parse-pattern))
(define parse-qmatch (parse-match/parse-pattern parse-pattern-quasiquote))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Parsing definitions ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (parse-body env stx.body)
  (let ((stx* (syntax->list stx.body)))
    (cond ((null? stx*)       (raise-syntax-error "no expression" stx.body))
          ((null? (cdr stx*)) (parse-expression env (car stx*)))
          (else (define (^def dst scope env)
                  (let ((dst (foldl (lambda (s dst) (parse-definition dst scope env s)) dst stx*)))
                    (unless (defstate-expression dst)
                      (raise-syntax-error "no expression after definitions" stx.body))
                    dst))
                ($provenance ($body env ^def) stx.body)))))

(define (parse-begin-definition dst env.scope env . stx*)
  (foldl (lambda (stx dst) (parse-definition dst env.scope env stx)) dst stx*))

(define (parse-introduce dst env.scope env . stx*) (env-introduce*! env.scope stx*) dst)

(define (parse-introduce-alias dst env.scope env id.lhs id.rhs)
  (parse-undefined-identifier env.scope id.lhs)
  (parse-identifier id.rhs)
  (let ((v=>v (env-ref env id.rhs)))
    (unless v=>v (raise-syntax-error "unbound identifier" id.rhs))
    (env-set! env.scope id.lhs v=>v))
  dst)

(define (parse-define dst env.scope env lhs . stx*.rhs)
  (cond
    ((identifier? lhs)
     (unless (and (pair? stx*.rhs) (null? (cdr stx*.rhs)))
       (raise-syntax-error "not a single expression" stx*.rhs))
     ($define dst env.scope lhs (lambda () (parse-expression env (car stx*.rhs)))))
    (else (let loop ((lhs lhs) (^rhs (lambda (env) (parse-body env stx*.rhs))))
            (let ((x (syntax-unwrap lhs)))
              (cond ((pair?       x) (loop (car x) (lambda (env)
                                                     ($lambda env (syntax->improper-list (cdr x))
                                                              (lambda (env . _) (^rhs env))))))
                    ((identifier? x) ($define dst env.scope x (lambda () (^rhs env))))
                    (else            (raise-syntax-error "not a definable form" lhs))))))))

(define (parse-define-values dst env.scope env stx.lhs*~ e.rhs)
  (let* ((lhs*~   (syntax->improper-list stx.lhs*~))
         (lhs*    (improper-list->list lhs*~))
         (v*.^rhs (lambda ()
                    ($call-with-values (ast:lambda #f '() (parse-expression env e.rhs))
                                       ($lambda env lhs*~ (lambda (env . addr*)
                                                            (apply $vector (map $ref addr*)))))))
         (v*.addr (fresh-address 'vec.value*))
         ($v*     ($ref v*.addr)))
    (foldl (lambda (i lhs dst)
             ($define dst env.scope lhs (lambda () ($vector-ref $v* ($quote i)))))
           (defstate-define dst v*.addr v*.^rhs)
           (iota (length lhs*))
           lhs*)))

(define ($splicing-rec dst env.scope env ^def ^body)
  (let* ((env.scope.inner (make-env))
         (env             (env-extend env env.scope.inner))
         (dst             (^def dst env.scope.inner env)))
    (^body dst env.scope env)))

(define ($splicing-nonrec dst env.scope env ^def ^body)
  (let ((env.scope.inner (make-env)))
    (^body (^def dst env.scope.inner env) env.scope (env-extend env env.scope.inner))))

(define ($splicing-local dst env.scope env stx.def* ^body)
  (let ((def* (syntax->list stx.def*)))
    ($splicing-rec dst env.scope env
                   (lambda (dst scope env) (apply parse-begin-definition dst scope env def*))
                   ^body)))

(splicing-local
  ((define ($splicing $splicing-etc parse-def dst env.scope env stx.bpair* ^body)
     (let ((bpair* (parse-binding-pairs stx.bpair*)))
       ($splicing-etc dst env.scope env
                      (lambda (dst scope env)
                        (foldl (lambda (lhs rhs dst) (parse-def dst scope env lhs rhs))
                               dst (map binding-pair-left bpair*) (map binding-pair-right bpair*)))
                      ^body))))
  (define ($splicing-let            . a*) (apply $splicing $splicing-nonrec parse-define        a*))
  (define ($splicing-let-values     . a*) (apply $splicing $splicing-nonrec parse-define-values a*))
  (define ($splicing-letrec*        . a*) (apply $splicing $splicing-rec parse-define        a*))
  (define ($splicing-letrec*-values . a*) (apply $splicing $splicing-rec parse-define-values a*)))

(splicing-local
  ((define ($splicing $splicing-etc dst env.scope env stx.bpair* ^body)
     (let loop ((stx*.bpair* (syntax->list stx.bpair*))
                (dst         dst)
                (scope       env.scope)
                (env         env))
       (cond ((null? stx*.bpair*) (^body dst scope env))
             (else ($splicing-etc dst scope env (list (car stx*.bpair*))
                                  (lambda (dst scope env)
                                    (loop (cdr stx*.bpair*) dst scope env))))))))
  (define ($splicing-let*        . a*) (apply $splicing $splicing-let        a*))
  (define ($splicing-let*-values . a*) (apply $splicing $splicing-let-values a*)))

(splicing-local
  ((define (parse-splicing $splicing dst env.scope env stx.def* . stx*)
     ($splicing dst env.scope env stx.def*
                (lambda (dst scope env) (apply parse-begin-definition dst scope env stx*)))))
  (define (parse-splicing-local          . a*) (apply parse-splicing $splicing-local          a*))
  (define (parse-splicing-let            . a*) (apply parse-splicing $splicing-let            a*))
  (define (parse-splicing-let-values     . a*) (apply parse-splicing $splicing-let-values     a*))
  (define (parse-splicing-let*           . a*) (apply parse-splicing $splicing-let*           a*))
  (define (parse-splicing-let*-values    . a*) (apply parse-splicing $splicing-let*-values    a*))
  (define (parse-splicing-letrec*        . a*) (apply parse-splicing $splicing-letrec*        a*))
  (define (parse-splicing-letrec*-values . a*) (apply parse-splicing $splicing-letrec*-values a*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Pre-base language syntax environment ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define env.base-0
  (let ((env.scope (make-env))
        (b*.expr-aux '(=> else guard))
        (b*.pattern-aux '(...))
        (b*.def
          (list (cons 'define          (definition-operator-parser parse-define          2 #f))
                (cons 'define-values   (definition-operator-parser parse-define-values   2 #f))
                (cons 'introduce       (definition-operator-parser parse-introduce       0 #f))
                (cons 'introduce-alias (definition-operator-parser parse-introduce-alias 2 #f))))
        (b*.expr
          (list
            (cons 'quote          (expression-operator-parser parse-quote        1 1))
            (cons 'quote-syntax   (expression-operator-parser parse-quote-syntax 1 1))
            (cons 'if             (expression-operator-parser parse-if           3 3))
            (cons 'and            (expression-operator-parser parse-and          0 #f))
            (cons 'or             (expression-operator-parser parse-or           0 #f))
            (cons 'when           (expression-operator-parser parse-when         2 #f))
            (cons 'unless         (expression-operator-parser parse-unless       2 #f))
            (cons 'cond           (expression-operator-parser parse-cond         1 #f))
            (cons 'caseq          (expression-operator-parser parse-caseq        2 #f))
            (cons 'casev          (expression-operator-parser parse-casev        2 #f))
            (cons 'match          (expression-operator-parser parse-match        1 #f))
            (cons 'qmatch         (expression-operator-parser parse-qmatch       1 #f))
            (cons 'case-lambda    (expression-operator-parser parse-case-lambda  0 #f))
            (cons 'lambda         (expression-operator-parser parse-lambda       2 #f))
            (cons 'local          (nonsplicing-expression-operator-parser $splicing-local))
            (cons 'let*           (nonsplicing-expression-operator-parser $splicing-let*))
            (cons 'letrec*        (nonsplicing-expression-operator-parser $splicing-letrec*))
            (cons 'let-values     (nonsplicing-expression-operator-parser $splicing-let-values))
            (cons 'let*-values    (nonsplicing-expression-operator-parser $splicing-let*-values))
            (cons 'letrec*-values (nonsplicing-expression-operator-parser $splicing-letrec*-values))
            (cons 'let            (expression-operator-parser parse-let          2 #f))))
        (b*.qq '(unquote unquote-splicing))
        (b*.qq-and-expr (list (cons 'quasiquote (expression-operator-parser parse-quasiquote 1 1))))
        (b*.def-and-expr
          (list
            (list 'begin
                  (definition-operator-parser parse-begin-definition 0 #f)
                  (expression-operator-parser parse-begin-expression 1 #f))
            (list 'splicing-local
                  (definition-operator-parser parse-splicing-local 2 #f)
                  (splicing-expression-operator-parser $splicing-local))
            (list 'splicing-let
                  (definition-operator-parser parse-splicing-let 2 #f)
                  (splicing-expression-operator-parser $splicing-let))
            (list 'splicing-let*
                  (definition-operator-parser parse-splicing-let* 2 #f)
                  (splicing-expression-operator-parser $splicing-let*))
            (list 'splicing-letrec*
                  (definition-operator-parser parse-splicing-letrec* 2 #f)
                  (splicing-expression-operator-parser $splicing-letrec*))
            (list 'splicing-let-values
                  (definition-operator-parser parse-splicing-let-values 2 #f)
                  (splicing-expression-operator-parser $splicing-let-values))
            (list 'splicing-let*-values
                  (definition-operator-parser parse-splicing-let*-values 2 #f)
                  (splicing-expression-operator-parser $splicing-let*-values))
            (list 'splicing-letrec*-values
                  (definition-operator-parser parse-splicing-letrec*-values 2 #f)
                  (splicing-expression-operator-parser $splicing-letrec*-values))))
        (b*.match-pattern
          (list (cons '_ parse-pattern-any)))
        (b*.match-pattern-operator
          (list (cons 'var        (match-pattern-operator-parser parse-pattern-var        1 1))
                (cons 'quote      (match-pattern-operator-parser parse-pattern-quote      1 1))
                (cons 'quasiquote (match-pattern-operator-parser parse-pattern-quasiquote 1 1))
                (cons 'app        (match-pattern-operator-parser parse-pattern-app        2 #f))
                (cons '?          (match-pattern-operator-parser parse-pattern-?          1 #f))
                (cons 'and        (match-pattern-operator-parser parse-pattern-and        0 #f))
                (cons 'or         (match-pattern-operator-parser parse-pattern-or         0 #f))
                (cons 'not        (match-pattern-operator-parser parse-pattern-not        1 1))
                ;; TODO: avoid shadowing these when defining same-named library procedures
                (cons 'cons*      (match-pattern-operator-parser parse-pattern-cons*      1 #f))
                (cons 'list       (match-pattern-operator-parser parse-pattern-list       0 #f))))
        (b*.match-pattern-operator-primitive
          (list (cons 'cons   (match-pattern-operator-parser parse-pattern-cons   2 2))
                (cons 'vector (match-pattern-operator-parser parse-pattern-vector 0 #f)))))
    (for-each (lambda (id) (env-bind! env.scope id vocab.expression-auxiliary (syntax-peek id)))
              b*.expr-aux)
    (for-each (lambda (id) (env-bind! env.scope id vocab.pattern-auxiliary (syntax-peek id)))
              b*.pattern-aux)
    (for-each (lambda (id op) (env-bind! env.scope id vocab.definition-operator op))
              (map car b*.def) (map cdr b*.def))
    (for-each (lambda (id op.def op.expr) (env-bind! env.scope id
                                                     vocab.definition-operator op.def
                                                     vocab.expression-operator op.expr))
              (map car b*.def-and-expr) (map cadr b*.def-and-expr) (map caddr b*.def-and-expr))
    (for-each (lambda (id) (env-bind! env.scope id vocab.quasiquote (syntax-peek id)))
              b*.qq)
    (for-each (lambda (id op) (env-bind! env.scope id
                                         vocab.expression-operator op
                                         vocab.quasiquote          (syntax-peek id)))
              (map car b*.qq-and-expr) (map cdr b*.qq-and-expr))
    (for-each (lambda (id op) (env-bind! env.scope id vocab.expression-operator op))
              (map car b*.expr) (map cdr b*.expr))
    (for-each (lambda (id op) (env-bind! env.scope id vocab.pattern op))
              (map car b*.match-pattern) (map cdr b*.match-pattern))
    (for-each (lambda (id op) (if (env-ref env.scope id)
                                  (env-set^! env.scope id vocab.pattern-operator op)
                                  (env-bind! env.scope id vocab.pattern-operator op)))
              (map car b*.match-pattern-operator) (map cdr b*.match-pattern-operator))
    (for-each (lambda (id op)
                (let ((v=>v (env-ref env.primitive id)))
                  (unless v=>v (raise-syntax-error "unbound primitive identifier" id))
                  (env-set! env.scope id (vocab-dict-set v=>v vocab.pattern-operator op))))
              (map car b*.match-pattern-operator-primitive)
              (map cdr b*.match-pattern-operator-primitive))
    (env-freeze! env.scope)
    (env-extend env.primitive env.scope)))
