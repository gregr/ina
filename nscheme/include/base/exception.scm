(define (make-exception   kind field*) (cons kind field*))
(define (exception-kind   exn)         (car exn))
(define (exception-field* exn)         (cdr exn))

(define (make-exception-kind superkind tag new-field-name*)
  (let* ((superkind (if superkind superkind '#()))
         (offset    (vector-length superkind))
         (mkind     (make-mvector (+ offset 2) 0)))
    (let loop ((i 0))
      (when (< i offset)
        (mvector-set! mkind i (vector-ref superkind i))
        (loop (+ i 1))))
    (mvector-set! mkind offset       tag)
    (mvector-set! mkind (+ offset 1) new-field-name*)
    (mvector->vector mkind)))
(define (exception-kind-offset          kind) (- (vector-length kind) 2))
(define (exception-kind-tag             kind) (vector-ref kind (exception-kind-offset kind)))
(define (exception-kind-new-field-name* kind) (vector-ref kind (+ (exception-kind-offset kind) 1)))
(define (exception-kind-? kind)
  (let ((offset (exception-kind-offset kind))
        (tag    (exception-kind-tag    kind)))
    (lambda (exn)
      (let ((kind (exception-kind exn)))
        (and (< offset (vector-length kind))
             (eq? (vector-ref kind offset) tag))))))
(define (exception-kind-new-field-accessor* kind)
  (let ((offset (let ((superkind-len (- (vector-length kind) 2)))
                  (let loop ((i 1) (offset 0))
                    (if (< i superkind-len)
                        (loop (+ i 2) (+ (vector-length (vector-ref kind i)) offset))
                        offset))))
        (new-field-count (vector-length (vector-ref kind (- (vector-length kind) 1)))))
    (let loop ((i 0))
      (if (< i new-field-count)
          (cons (lambda (exn) (vector-ref (exception-field* exn) i))
                (loop (+ i 1)))
          '()))))

(define (exception-field-name* exn)
  (let* ((kind (exception-kind exn))
         (len  (vector-length kind)))
    (let loop ((i 1) (new-field-name** '()) (field-name-count 0))
      (if (< i len)
          (let ((new-field-name* (vector-ref kind i)))
            (loop (+ i 2) (cons new-field-name* new-field-name**)
                  (+ field-name-count (vector-length new-field-name*))))
          (let ((mfield-name* (make-mvector field-name-count 0)))
            (let loop.outer ((i field-name-count) (new-field-name** new-field-name**))
              (if (null? new-field-name**)
                  (mvector->vector mfield-name*)
                  (let* ((new-field-name*      (car new-field-name**))
                         (new-field-name-count (vector-length new-field-name*))
                         (i                    (- i new-field-name-count)))
                    (let loop.inner ((j 0))
                      (if (< j new-field-name-count)
                          (begin (mvector-set! mfield-name* (+ i j) (vector-ref new-field-name* j))
                                 (loop.inner (+ j 1)))
                          (loop.outer i (cdr new-field-name**))))))))))))

(define (exception-pretty exn)
  (let* ((field*      (exception-field* exn))
         (field-name* (exception-field-name* exn))
         (field-count (vector-length field*)))
    (cons (list 'exception (exception-kind-tag (exception-kind exn)))
          (let loop ((i 0))
            (if (< i field-count)
                (cons (list (vector-ref field-name* i) (vector-ref field* i)) (loop (+ i 1)))
                '())))))

(define (make-exception-kind&?&new-field-accessor* . arg*)
  (let ((kind (apply make-exception-kind arg*)))
    (apply values kind (exception-kind-? kind) (exception-kind-new-field-accessor* kind))))

(define-values (exception-kind.error error? error-description)
  (make-exception-kind&?&new-field-accessor* #f 'error '#(description)))

(define (make-error desc) (make-exception exception-kind.error (vector desc)))
