(define (bytevector->symbol x) (string->symbol (bytevector->string x)))
(define (symbol->bytevector x) (string->bytevector (symbol->string x)))
(define (make-bytevector n b) (mbytevector->bytevector (make-mbytevector n b)))
(define (list->bytevector x*) (apply bytevector x*))

(define (bytevector->list x) (bytevector-take x (bytevector-length x)))
(define (bytevector-take x n)
  (let ((len (min (bytevector-length x) n)))
    (let loop ((i 0))
      (if (< i len) (cons (bytevector-ref x i) (loop (+ i 1))) '()))))

(define (bytevector-append . x*) (bytevector-append* x*))
(define (bytevector-append* x*)
  (let ((mbv (make-mbytevector
               (let loop ((x* x*) (len 0))
                 (if (null? x*)
                     len
                     (loop (cdr x*) (+ (bytevector-length (car x*)) len))))
               0)))
    (let loop ((x* x*) (i 0))
      (if (null? x*)
          (mbytevector->bytevector mbv)
          (let* ((bv (car x*)) (len (bytevector-length bv)))
            (mbytevector-copy! mbv i bv 0 len)
            (loop (cdr x*) (+ i len)))))))

(define (bytevector-join separator . x*) (bytevector-join* separator x*))
(define (bytevector-join* separator x*)
  (if (null? x*)
      #""
      (let* ((len.sep (bytevector-length separator))
             (mbv (make-mbytevector
                    (let loop ((x (car x*)) (x* (cdr x*)) (final-size 0))
                      (let ((final-size (+ (bytevector-length x) final-size)))
                        (if (null? x*)
                            final-size
                            (loop (car x*) (cdr x*) (+ len.sep final-size)))))
                    0)))
        (let loop ((i 0) (x (car x*)) (x* (cdr x*)))
          (let ((len (bytevector-length x)))
            (mbytevector-copy! mbv i x 0 len)
            (if (null? x*)
                (mbytevector->bytevector mbv)
                (let ((i (+ i len)))
                  (mbytevector-copy! mbv i separator 0 len.sep)
                  (loop (+ i len.sep) (car x*) (cdr x*)))))))))

(define (bytevector-slice bv start end) (bytevector-copy bv start (- end start)))
(define (bytevector-copy bv start count)
  (if (and (= count (bytevector-length bv)) (= start 0))
      bv
      (let ((new (make-mbytevector count 0)))
        (mbytevector-copy! new 0 bv start count)
        (mbytevector->bytevector new))))

(define (bytevector-index-start/? ?)
  (let ((go (lambda (bv start)
              (let ((len (bytevector-length bv)))
                (let loop ((i start))
                  (if (or (<= len i) (? (bytevector-ref bv i))) i (loop (+ i 1))))))))
    (case-lambda
      ((bv)       (go bv 0))
      ((bv start) (go bv start)))))
(define (bytevector-index-end/? ?)
  (let ((go (lambda (bv end)
              (let loop ((i end))
                (if (or (<= i 0) (? (bytevector-ref bv (- i 1)))) i (loop (- i 1)))))))
    (case-lambda
      ((bv)     (go bv (bytevector-length bv)))
      ((bv end) (go bv end)))))
(define (bytevector-index-start/byte b) (bytevector-index-start/? (lambda (x) (= x b))))
(define (bytevector-index-end/byte   b) (bytevector-index-end/?   (lambda (x) (= x b))))

(define ((bytevector-split/? ?) bv)
  (let ((len (bytevector-length bv)))
    (let loop-segment ((start 0))
      (let loop-byte ((i start))
        (define (make-segment) (bytevector-slice bv start i))
        (cond ((= i len)                 (list (make-segment)))
              ((? (bytevector-ref bv i)) (cons (make-segment) (loop-segment (+ i 1))))
              (else                      (loop-byte (+ i 1))))))))
(define (bytevector-split/separator separator) (bytevector-split/? (lambda (x) (= x separator))))
(define (bytevector-split bv separator) ((bytevector-split/separator separator) bv))

(define ((bytevector-rtrim1/? ?) bv)
  (let ((len (bytevector-length bv)))
    (if (and (< 0 len) (? (bytevector-ref bv (- len 1))))
        (bytevector-copy bv 0 (- len 1))
        bv)))
(define ((bytevector-rtrim/? ?) bv)
  (let ((i ((bytevector-index-end/? (lambda (x) (not (? x)))) bv)))
    (if i (bytevector-copy bv 0 i) bv)))
(define ((bytevector-ltrim/? ?) bv)
  (let ((i ((bytevector-index-start/? (lambda (x) (not (? x)))) bv)))
    (if i (bytevector-slice bv i (bytevector-length bv)) bv)))
(define (bytevector-rtrim1/byte b) (bytevector-rtrim1/? (lambda (x) (= x b))))
(define (bytevector-rtrim/byte b) (bytevector-rtrim/? (lambda (x) (= x b))))
(define (bytevector-ltrim/byte b) (bytevector-ltrim/? (lambda (x) (= x b))))
(define (bytevector-rtrim1 bv b) ((bytevector-rtrim1/byte b) bv))
(define (bytevector-rtrim  bv b) ((bytevector-rtrim/byte b) bv))
(define (bytevector-ltrim  bv b) ((bytevector-ltrim/byte b) bv))
