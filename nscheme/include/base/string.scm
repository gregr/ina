;;;;;;;;;;;;;;;;;;;;;;
;;; UTF-8 encoding ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; U+000000 - U+00007f encoded as octets: 0xxxxxxx
;; U+000080 - U+0007ff encoded as octets: 110xxxxx 10xxxxxx
;; U+000800 - U+00ffff encoded as octets: 1110xxxx 10xxxxxx 10xxxxxx
;; U+010000 - U+10ffff encoded as octets: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
;; Invalid ranges: U+d800 - U+dfff and above U+10ffff
;; With correct encoding, which uses the minimum number of octets, these octets will never appear:
;; c0: 11000000
;; c1: 11000001
;; f5-ff: 11110101 or larger
(define (utf8? bv)
  (define (extra-octet? b) (= (bitwise-and b #b11000000) #b10000000))
  (let ((end (bytevector-length bv)))
    (let loop ((i 0))
      (or (= i end)
          (let ((b0 (bytevector-u8-ref bv i)))
            (cond ((= (bitwise-and b0 #b10000000) #b00000000) (loop (+ i 1)))
                  ((= (bitwise-and b0 #b11100000) #b11000000)
                   (and (< #b11000001 b0) (< (+ i 1) end)
                        (extra-octet? (bytevector-u8-ref bv (+ i 1)))
                        (loop (+ i 2))))
                  ((= (bitwise-and b0 #b11110000) #b11100000)
                   (and (< (+ i 2) end)
                        (let ((b1 (bytevector-u8-ref bv (+ i 1)))
                              (b2 (bytevector-u8-ref bv (+ i 2))))
                          (and (extra-octet? b1) (extra-octet? b2)
                               (let ((c (bitwise-ior
                                          (bitwise-arithmetic-shift-left (bitwise-and b0 #x0f) 12)
                                          (bitwise-arithmetic-shift-left (bitwise-and b1 #x3f) 6)
                                          (bitwise-and b2 #x3f))))
                                 (or (< #x7ff c #xd800) (< #xdfff c)))
                               (loop (+ i 3))))))
                  ((= (bitwise-and b0 #b11111000) #b11110000)
                   (and (< b0 #xb11110101) (< (+ i 3) end)
                        (let ((b1 (bytevector-u8-ref bv (+ i 1)))
                              (b2 (bytevector-u8-ref bv (+ i 2)))
                              (b3 (bytevector-u8-ref bv (+ i 3))))
                          (and (extra-octet? b1) (extra-octet? b2) (extra-octet? b3)
                               (let ((c (bitwise-ior
                                          (bitwise-arithmetic-shift-left (bitwise-and b0 #x0f) 18)
                                          (bitwise-arithmetic-shift-left (bitwise-and b1 #x3f) 12)
                                          (bitwise-arithmetic-shift-left (bitwise-and b2 #x3f) 6)
                                          (bitwise-and b3 #x3f))))
                                 (< #xffff c #x110000))
                               (loop (+ i 4))))))
                  (else #f)))))))

(splicing-local
  ((define byte:- 45)
   (define byte:0 48) (define byte:A 65) (define byte:a 97)
   (define byte:/ 47) (define byte:. 46) (define byte:~ 126)
   (define byte:e 101) (define byte:E 69)
   (define byte:p 112) (define byte:P 80)
   (define byte:# 35) (define byte:b 98) (define byte:d 100) (define byte:o 111) (define byte:x 120)
   (define byte:B 66) (define byte:D 68) (define byte:O 79) (define byte:X 88)
   (define (digit10 d) (- d byte:0))
   (define (digit16 d)
     (cond ((<= byte:a d) (+ (- d byte:a) 10))
           ((<= byte:A d) (+ (- d byte:A) 10))
           (else          (digit10 d))))
   (define (radix?! r) (unless (and (integer? r) (<= 2 r 16)) (error "unsupported radix" r)))
   (define (set-nat-radix-digits! mbv start count n radix)
     (let loop ((i (+ start count -1)) (n n))
       (when (<= start i)
         (let-values (((q r) (integer-floor-divmod n radix)))
           (mbytevector-u8-set! mbv i (if (< r 10) (+ r byte:0) (+ (- r 10) byte:a)))
           (loop (- i 1) q)))))
   (define (style-ref style key) (and style (let ((kv (assq style key))) (and kv (cdr kv)))))
   (define (integer->utf8 n radix use-exponent-above)
     ;; TODO: respect use-exponent-above if present
     (cond ((< n 0) (let* ((len (+ (floor-log (- n) radix) 2))
                           (mbv (make-mbytevector len 0)))
                      (mbytevector-u8-set! mbv 0 byte:-)
                      (set-nat-radix-digits! mbv 1 (- len 1) (- n) radix)
                      (mbytevector->bytevector mbv)))
           ((< 0 n) (let* ((len (+ (floor-log n radix) 1))
                           (mbv (make-mbytevector len 0)))
                      (set-nat-radix-digits! mbv 0 len n radix)
                      (mbytevector->bytevector mbv)))
           (else #"0")))
   (define (fraction->utf8 n radix)
     (bytevector-append (integer->utf8 (numerator n) radix #f) #"/"
                        (integer->utf8 (denominator n) radix #f)))
   (define (decimal->utf8 n radix radix.exponent use-exponent-below use-exponent-above)
     (error "TODO: decimal->utf8" n radix radix.exponent use-exponent-below use-exponent-above)))
  (define number->utf8
    (let ((go (lambda (n radix style)
                (radix?! radix)
                (cond ((integer? n) (integer->utf8 n radix (style-ref style 'use-exponent-above)))
                      ((or (not style) (eq? style 'fraction)) (fraction->utf8 n radix))
                      (else (decimal->utf8 n radix (or (style-ref style 'exponent-radix) radix)
                                           (style-ref style 'use-exponent-below)
                                           (style-ref style 'use-exponent-above)))))))
      (case-lambda
        ((n)             (go n 10    #f))
        ((n radix)       (go n radix #f))
        ((n radix style) (go n radix style)))))
  (define utf8->number
    (let ((go (lambda (bv radix)
                (radix?! radix)
                (let* ((len    (bytevector-length bv))
                       (digitX (if (< radix 11) digit10 digit16))
                       (digit  (lambda (b succeed fail)
                                 (let ((x (digitX b))) (if (< -1 x radix) (succeed x) (fail b)))))
                       (digit* (lambda (n i succeed.more succeed.end)
                                 (let loop ((i i) (n n))
                                   (if (< i len)
                                       (digit (bytevector-u8-ref bv i)
                                              (lambda (x) (loop (+ i 1) (+ (* n radix) x)))
                                              (lambda (b) (succeed.more n i b)))
                                       (succeed.end n)))))
                       (digit+ (lambda (i succeed.more succeed.end fail)
                                 (if (< i len)
                                     (digit (bytevector-u8-ref bv i)
                                            (lambda (x) (digit* x (+ i 1) succeed.more succeed.end))
                                            (lambda (b) (fail)))
                                     (fail))))
                       (int    (lambda (i succeed.more succeed.end fail)
                                 ;; TODO: check for a radix-adjusting prefix.
                                 (if (< i len)
                                     (let ((b (bytevector-u8-ref bv i)))
                                       (if (= b byte:-)
                                           (digit+ (+ i 1)
                                                   (lambda (n i b) (succeed.more (- n) i b))
                                                   (lambda (n) (succeed.end (- n)))
                                                   fail)
                                           (digit b
                                                  (lambda (x)
                                                    (digit* x (+ i 1) succeed.more succeed.end))
                                                  (lambda (b) (fail)))))
                                     (fail)))))
                  (int 0
                       (lambda (n i b)
                         (cond
                           ((= b byte:/) (digit+ (+ i 1)
                                                 (lambda (d i b) #f)
                                                 (lambda (d) (/ n d))
                                                 (lambda () #f)))
                           ((= b byte:.) (error "TODO: utf8->number decimal" bv))
                           ((or (= b byte:e) (= b byte:E) (= b byte:p) (= b byte:P))
                            (error "TODO: utf8->number exponent" bv))
                           (else #f)))
                       (lambda (n) n)
                       (lambda () #f))))))
      (case-lambda
        ((bv)       (go bv 10))
        ((bv radix) (go bv radix))))))

(define (string->utf8 s) (string->bytevector s))
(define (utf8->string bv)
  (unless (utf8? bv) (error "not UTF-8 encoded" bv))
  (bytevector->string bv))

(define (number->string . x*) (utf8->string (apply number->utf8 x*)))
(define (string->number s . option*) (apply utf8->number (string->utf8 s) option*))

(define (string-append* x*) (bytevector->string (bytevector-append* (map string->bytevector x*))))
(define (string-append . x*) (string-append* x*))

(define (make-local-gensym)
  (mlet ((count -1))
    (lambda (str)
      (set! count (+ count 1))
      (string->symbol (string-append str "." (number->string count))))))
