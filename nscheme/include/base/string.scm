;;;;;;;;;;;;;;;;;;;;;;
;;; UTF-8 encoding ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; U+000000 - U+00007f encoded as octets: 0xxxxxxx
;; U+000080 - U+0007ff encoded as octets: 110xxxxx 10xxxxxx
;; U+000800 - U+00ffff encoded as octets: 1110xxxx 10xxxxxx 10xxxxxx
;; U+010000 - U+10ffff encoded as octets: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
;; Invalid ranges: U+d800 - U+dfff and above U+10ffff
;; With correct encoding, which uses the minimum number of octets, these octets will never appear:
;; c0: 11000000
;; c1: 11000001
;; f5-ff: 11110101 or larger
(define (utf8? bv)
  (define (extra-octet? b) (= (bitwise-and b #b11000000) #b10000000))
  (let ((end (bytevector-length bv)))
    (let loop ((i 0))
      (or (= i end)
          (let ((b0 (bytevector-u8-ref bv i)))
            (cond ((= (bitwise-and b0 #b10000000) #b00000000) (loop (+ i 1)))
                  ((= (bitwise-and b0 #b11100000) #b11000000)
                   (and (< #b11000001 b0) (< (+ i 1) end)
                        (extra-octet? (bytevector-u8-ref bv (+ i 1)))
                        (loop (+ i 2))))
                  ((= (bitwise-and b0 #b11110000) #b11100000)
                   (and (< (+ i 2) end)
                        (let ((b1 (bytevector-u8-ref bv (+ i 1)))
                              (b2 (bytevector-u8-ref bv (+ i 2))))
                          (and (extra-octet? b1) (extra-octet? b2)
                               (let ((c (bitwise-ior
                                          (bitwise-arithmetic-shift-left (bitwise-and b0 #x0f) 12)
                                          (bitwise-arithmetic-shift-left (bitwise-and b1 #x3f) 6)
                                          (bitwise-and b2 #x3f))))
                                 (or (< #x7ff c #xd800) (< #xdfff c)))
                               (loop (+ i 3))))))
                  ((= (bitwise-and b0 #b11111000) #b11110000)
                   (and (< b0 #xb11110101) (< (+ i 3) end)
                        (let ((b1 (bytevector-u8-ref bv (+ i 1)))
                              (b2 (bytevector-u8-ref bv (+ i 2)))
                              (b3 (bytevector-u8-ref bv (+ i 3))))
                          (and (extra-octet? b1) (extra-octet? b2) (extra-octet? b3)
                               (let ((c (bitwise-ior
                                          (bitwise-arithmetic-shift-left (bitwise-and b0 #x0f) 18)
                                          (bitwise-arithmetic-shift-left (bitwise-and b1 #x3f) 12)
                                          (bitwise-arithmetic-shift-left (bitwise-and b2 #x3f) 6)
                                          (bitwise-and b3 #x3f))))
                                 (< #xffff c #x110000))
                               (loop (+ i 4))))))
                  (else #f)))))))

(splicing-local
  ((define byte:+ 43)
   (define byte:- 45)
   (define byte:0 48) (define byte:A 65) (define byte:a 97)
   (define byte:/ 47) (define byte:. 46) (define byte:~ 126)
   (define byte:e 101) (define byte:E 69)
   (define byte:p 112) (define byte:P 80)
   (define byte:# 35) (define byte:b 98) (define byte:d 100) (define byte:o 111) (define byte:x 120)
   (define byte:B 66) (define byte:D 68) (define byte:O 79) (define byte:X 88)
   (define (digit16 d)
     (if (<= byte:A d)
         (if (<= byte:a d) (+ (- d byte:a) 10) (+ (- d byte:A) 10))
         (- d byte:0)))
   (define (radix?! r) (unless (and (integer? r) (<= 2 r 16)) (error "unsupported radix" r)))
   (define (set-nat-radix-digits! mbv start count n radix)
     (let loop ((i (+ start count -1)) (n n))
       (when (<= start i)
         (let-values (((q r) (integer-floor-divmod n radix)))
           (mbytevector-u8-set! mbv i (if (< r 10) (+ r byte:0) (+ (- r 10) byte:a)))
           (loop (- i 1) q)))))
   (define (style-ref style key) (and style (let ((kv (assq style key))) (and kv (cdr kv)))))
   (define (integer->utf8 n radix use-exponent-above)
     ;; TODO: respect use-exponent-above if present
     (cond ((< n 0) (let* ((len (+ (floor-log (- n) radix) 2))
                           (mbv (make-mbytevector len 0)))
                      (mbytevector-u8-set! mbv 0 byte:-)
                      (set-nat-radix-digits! mbv 1 (- len 1) (- n) radix)
                      (mbytevector->bytevector mbv)))
           ((< 0 n) (let* ((len (+ (floor-log n radix) 1))
                           (mbv (make-mbytevector len 0)))
                      (set-nat-radix-digits! mbv 0 len n radix)
                      (mbytevector->bytevector mbv)))
           (else #"0")))
   (define (fraction->utf8 n radix)
     (bytevector-append (integer->utf8 (numerator n) radix #f) #"/"
                        (integer->utf8 (denominator n) radix #f)))
   (define (decimal->utf8 n radix radix.exponent use-exponent-below use-exponent-above)
     (error "TODO: decimal->utf8" n radix radix.exponent use-exponent-below use-exponent-above)))
  (define number->utf8
    (let ((go (lambda (n radix style)
                (radix?! radix)
                (cond ((integer? n) (integer->utf8 n radix (style-ref style 'use-exponent-above)))
                      ((or (not style) (eq? style 'fraction)) (fraction->utf8 n radix))
                      (else (decimal->utf8 n radix (or (style-ref style 'exponent-radix) radix)
                                           (style-ref style 'use-exponent-below)
                                           (style-ref style 'use-exponent-above)))))))
      (case-lambda
        ((n)             (go n 10    #f))
        ((n radix)       (go n radix #f))
        ((n radix style) (go n radix style)))))
  (define utf8->number
    (let ((go (lambda (bv radix)
                (radix?! radix)
                (let ((len (bytevector-length bv)))
                  (define (Radix radix i k)
                    (and (< i len)
                         (let ((b (bytevector-u8-ref bv i)))
                           (if (= b byte:#)
                               (let ((i (+ i 1)))
                                 (and (< i len)
                                      (let ((b (bytevector-u8-ref bv i)))
                                        (let ((i (+ i 1)))
                                          (and (< i len)
                                               (let ((c (bytevector-u8-ref bv i)))
                                                 (cond
                                                   ((or (= b byte:b) (= b byte:B)) (k 2 i c))
                                                   ((or (= b byte:o) (= b byte:O)) (k 8 i c))
                                                   ((or (= b byte:d) (= b byte:D)) (k 10 i c))
                                                   ((or (= b byte:x) (= b byte:X)) (k 16 i c))
                                                   (else #f))))))))
                               (k radix i b)))))
                  (define (Sign i b k)
                    (define (next sign)
                      (let ((i (+ i 1)))
                        (and (< i len) (k sign i (bytevector-u8-ref bv i)))))
                    (cond ((= b byte:-) (next -1))
                          ((= b byte:+) (next  1))
                          (else         (k 1 i b))))
                  (define (RadixSign radix i k)
                    (Radix radix i (lambda (radix i b) (Sign i b (lambda (sign i b)
                                                                   (k radix sign i b))))))
                  (define (Digit* radix i b k.more k.end)
                    (let loop ((n 0) (digit-count 0) (i i) (b b))
                      (let ((x (digit16 b)))
                        (if (< -1 x radix)
                            (let ((n (+ (* n radix) x)) (digit-count (+ digit-count 1)) (i (+ i 1)))
                              (if (< i len)
                                  (loop n digit-count i (bytevector-u8-ref bv i))
                                  (k.end n digit-count)))
                            (k.more n digit-count i b)))))
                  (define (Digit+ radix i k.more k.end)
                    (if (< i len)
                        (Digit* radix i (bytevector-u8-ref bv i) k.more k.end)
                        (k.end 0 0)))
                  (define (Exp n radix i b)
                    (and (or (= b byte:e) (= b byte:E) (= b byte:p) (= b byte:P))
                         (RadixSign radix (+ i 1)
                                    (lambda (radix sign i b)
                                      (Digit* radix i b
                                              (lambda (x digit-count i b) #f)
                                              (lambda (x digit-count)
                                                (and (< 0 digit-count)
                                                     (* n (expt radix (* sign x))))))))))
                  (RadixSign
                    radix 0
                    (lambda (radix sign i b)
                      (define (decimal lhs lhs-digit-count rhs rhs-digit-count)
                        (and (or (< 0 lhs-digit-count) (< 0 rhs-digit-count))
                             (* sign (+ lhs (/ rhs (expt radix rhs-digit-count))))))
                      (Digit* radix i b
                              (lambda (n digit-count i b)
                                (if (= b byte:.)
                                    (Digit+ radix (+ i 1)
                                            (lambda (rhs rhs-digit-count i b)
                                              (let ((n (decimal n digit-count rhs rhs-digit-count)))
                                                (and n (Exp n radix i b))))
                                            (lambda (rhs rhs-digit-count)
                                              (decimal n digit-count rhs rhs-digit-count)))
                                    (and (< 0 digit-count)
                                         (if (= b byte:/)
                                             (Digit+ radix (+ i 1)
                                                     (lambda (d digit-count i b) #f)
                                                     (lambda (d digit-count)
                                                       (and (< 0 digit-count)
                                                            (* sign (/ n d)))))
                                             (Exp (* sign n) radix i b)))))
                              (lambda (n digit-count)
                                (and (< 0 digit-count) (* sign n))))))))))
      (case-lambda
        ((bv)       (go bv 10))
        ((bv radix) (go bv radix))))))

(define (string->utf8 s) (string->bytevector s))
(define (utf8->string bv)
  (unless (utf8? bv) (error "not UTF-8 encoded" bv))
  (bytevector->string bv))

(define (number->string . x*) (utf8->string (apply number->utf8 x*)))
(define (string->number s . option*) (apply utf8->number (string->utf8 s) option*))

(define (string-append* x*) (bytevector->string (bytevector-append* (map string->bytevector x*))))
(define (string-append . x*) (string-append* x*))

(define (make-local-gensym)
  (mlet ((count -1))
    (lambda (str)
      (set! count (+ count 1))
      (string->symbol (string-append str "." (number->string count))))))
