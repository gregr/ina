(define (mbytevector . args)
  (let ((x (make-mbytevector (length args) 0)))
    (let loop ((i 0) (args args))
      (cond ((null? args) x)
            (else         (mbytevector-set! x i (car args))
                          (loop (+ i 1) (cdr args)))))))

(define mbytevector-fill!
  (let ((go (lambda (mbv v start count)
              (nonnegative-integer? start)
              (nonnegative-integer? count)
              (let ((end (+ start count)))
                (unless (<= end (mbytevector-length mbv))
                  (error "mbytevector-fill! range out of bounds" start count
                         (mbytevector-length mbv)))
                (range-for-each (lambda (i) (mbytevector-set! mbv i v)) start end)))))
  (case-lambda
    ((mbv v)             (go mbv v 0     (mbytevector-length mbv)))
    ((mbv v start)       (go mbv v start (- (mbytevector-length mbv) start)))
    ((mbv v start count) (go mbv v start count)))))

(define (mbytevector-copy! src start.src dst start.dst count)
  (nonnegative-integer?! start.src)
  (nonnegative-integer?! start.dst)
  (nonnegative-integer?! count)
  (unless (<= (+ start.dst count) (mbytevector-length dst))
    (error "mbytevector-copy! destination range is out of bounds" start.dst count
           (mbytevector-length dst)))
  (define (go ref len.src)
    (unless (<= (+ start.src count) len.src)
      (error "mbytevector-copy! source range is out of bounds" start.src count len.src))
    (if (and (eq? src dst) (< start.src start.dst))
        (range-for-each (lambda (i) (mbytevector-set! dst (+ start.dst i) (ref src (+ start.src i))))
                        (- count 1) -1 -1)
        (range-for-each (lambda (i) (mbytevector-set! dst (+ start.dst i) (ref src (+ start.src i))))
                        0 count)))
  (cond ((mbytevector? src) (go mbytevector-ref (mbytevector-length src)))
        ((bytevector? src)  (go bytevector-ref (bytevector-length src)))
        (else               (error "not a bytevector or mbytevector" src))))
