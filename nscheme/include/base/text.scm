;;; Text values are assumed to be UTF-8-encoded.

;;;;;;;;;;;;;;;;
;;; Printing ;;;
;;;;;;;;;;;;;;;;
;;; To interoperate safely with printer targets that perform compositing, calls to printer-print
;;; must emit text horizontally in a predictable manner.  This means that text passed to
;;; printer-print must not contain control codes or markup that change vertical position or that
;;; nonlocally transform text or other ambient state.  Vertical spacing should be requested by
;;; calling printer-newline.
(define (make-printer print newline) (vector print newline))
(define (printer-print   p text attr) ((vector-ref p 0) text attr))
(define (printer-newline p)           ((vector-ref p 1)))

(define (printer:port port)
  (make-printer (lambda (t _) (let ((len (bytevector-length t))) (oport-write port t 0 len len)))
                (lambda ()    (oport-write-byte port 10))))

(define (printer-map p f)
  (make-printer
    (lambda (text attr) (let-values (((text attr) (f text attr))) (printer-print p text attr)))
    (lambda ()          (printer-newline p))))
(define (printer-map-text/attribute p f)
  (make-printer
    (lambda (text attr) (printer-print p (f text attr) attr))
    (lambda ()          (printer-newline p))))
(define (printer-map-attribute p f)
  (make-printer
    (lambda (text attr) (printer-print p text (f attr)))
    (lambda ()          (printer-newline p))))

(define (printer-decorate/sgr p)
  (printer-map-text/attribute p (lambda (t sgr) (if sgr (bytevector-append sgr t #"\e[0m") t))))
(define (printer-sgr-default p sgr.default)
  (printer-map-attribute p (lambda (sgr) (or sgr sgr.default))))
(define (printer-sgr-add p sgr.add)
  (printer-map-attribute p (lambda (sgr) (if sgr (bytevector-append sgr sgr.add) sgr.add))))

(define (printer-fill p width text attr)
  (mlet ((size 0))
    (make-printer
      (lambda (text attr)
        (set! size (+ size (utf8-length text)))
        (printer-print p text attr))
      (lambda ()
        (when (< size width) (range-for-each (lambda (i) (printer-print p text attr))
                                             (- width size)))
        (set! size 0)
        (printer-newline p)))))

(define (printer-truncate p width)
  (mlet ((size 0))
    (define (nl) (set! size 0) (printer-newline p))
    (make-printer
      (lambda (text attr)
        (let ((current-size size))
          (when (< current-size width)
            (let* ((ulen (utf8-length text)) (new-size (+ current-size ulen)))
              (if (<= new-size width)
                  (begin (set! size new-size) (printer-print p text attr))
                  (let* ((ulen   (- ulen (- new-size width)))
                         (len    (utf8-index text 0 ulen))
                         (prefix (make-mbytevector len 0)))
                    (mbytevector-copy! prefix 0 text 0 len)
                    (set! size width)
                    (printer-print p (mbytevector->bytevector prefix) attr)))))))
      nl)))

(define (printer-line-wrap p width)
  (mlet ((size 0))
    (define (nl) (set! size 0) (printer-newline p))
    (make-printer
      (lambda (text attr)
        (let* ((ulen (utf8-length text)) (new-size (+ size ulen)))
          (if (<= new-size width)
              (begin (set! size new-size) (printer-print p text attr))
              (let ((len.full (bytevector-length text)))
                (let loop ((start 0) (ulen ulen) (new-size new-size))
                  (let* ((ulen.rhs (- new-size width))
                         (len.lhs  (utf8-index text start (- ulen ulen.rhs)))
                         (lhs      (make-mbytevector len.lhs 0)))
                    (mbytevector-copy! lhs 0 text start len.lhs)
                    (printer-print p (mbytevector->bytevector lhs) attr)
                    (nl)
                    (let ((start (+ start len.lhs)) (ulen ulen.rhs))
                      (if (<= ulen width)
                          (let* ((len.lhs (- len.full start)) (lhs (make-mbytevector len.lhs 0)))
                            (mbytevector-copy! lhs 0 text start len.lhs)
                            (set! size ulen)
                            (printer-print p (mbytevector->bytevector lhs) attr))
                          (loop start ulen ulen)))))))))
      nl)))

(define (printer-correlate-location p correlate!)
  (mlet ((line 0) (col 0))
    (make-printer
      (lambda (text attr) (let ((size (utf8-length text)))
                            (correlate! text attr line col size)
                            (set! col (+ col size))
                            (printer-print p text attr)))
      (lambda ()          (set! line (+ line 1)) (set! col 0) (printer-newline p)))))

;;;;;;;;;;;;;;
;;; Layout ;;;
;;;;;;;;;;;;;;
;;; Layout commands express preferences, not guarantees.  The layout policy is responsible for
;;; determining when and how preferences are realized.
;;; - The layout-place command requests that text be presented, optionally with an attribute that
;;;   may contain metadata to be correlated with the text, or preferences in how the text is
;;;   displayed, including styling, coloring, markup, etc.  The text value itself should be plain,
;;;   and not embed any attributes.
;;; - The layout-space, layout-newline and layout-space^newline commands request separation, and
;;;   respectively indicate a preference for spacing in the horizontal or vertical direction, or no
;;;   preference at all for layout-space^newline.  Whether the preferred direction is used or not is
;;;   decided by the layout policy.
;;; - The layout-group-begin and layout-group-end commands form groups of aligned lines of text.  A
;;;   new group is specified with an indentation amount that will be calculated relative to its
;;;   first line, and that will be applied to subsequent lines.
;;; - Assumptions:
;;;   - A layout-group-end can only be followed by layout-newline, layout-space^newline, or another
;;;     layout-group-end.
;;;   - Groups will not be pathologically nested.
;;;   - Incomplete groups may prevent layout effects from being observed.
;;;   - Top-level uses of layout-space^newline followed by layout-place or layout-space will
;;;     eventually be terminated with layout-newline, layout-space^newline, or a complete group.
;;;   - In the case of a terminating layout-space^newline, its effect might never be observed.
;;;     - But layout effects preceding the layout-space^newline will be observed.
(define (make-layout place group-begin group-end space newline space^newline)
  (vector place group-begin group-end space newline space^newline))
(define (layout-place         l text attr) ((vector-ref l 0) text attr))
(define (layout-group-begin   l indent)    ((vector-ref l 1) indent))
(define (layout-group-end     l)           ((vector-ref l 2)))
(define (layout-space         l)           ((vector-ref l 3)))
(define (layout-newline       l)           ((vector-ref l 4)))
(define (layout-space^newline l)           ((vector-ref l 5)))

(define (layout:single-line printer)
  (define (space) (printer-print printer #" " #f))
  (make-layout (lambda (text attr) (printer-print printer text attr))
               (lambda (indent)    (values))
               (lambda ()          (values))
               space space space))

(splicing-local
  ((define (make-group parent indent) (let ((g (mvector parent #f indent '())))
                                        (when parent (group-set-child! parent g))
                                        g))
   (define (group?            x)   (mvector? x))
   (define (group-parent      g)   (mvector-ref  g 0))
   (define (group-child       g)   (mvector-ref  g 1))
   (define (group-indent      g)   (mvector-ref  g 2))
   (define (group-rt*         g)   (mvector-ref  g 3))
   (define (group-set-parent! g p) (mvector-set! g 0 p))
   (define (group-set-child!  g c) (mvector-set! g 1 c))
   (define (group-rt*-add!    g t) (mvector-set! g 3 (cons t (mvector-ref g 3))))
   (define (make-placement size text attr) (vector size text attr))
   (define (placement-size p) (vector-ref p 0))
   (define (placement-text p) (vector-ref p 1))
   (define (placement-attr p) (vector-ref p 2)))
  (define (layout:pretty printer width)
    (mlet ((start* '(0)) (pos.actual 0) (pos.potential 0) (group.outer #f) (group.inner #f))
      (define (place size text attr)
        (set! pos.actual (+ pos.actual size))
        (printer-print printer text attr))
      (define (newline)
        (let* ((start (car start*))
               (text  (make-mbytevector start 32)))
          (printer-newline printer)
          (printer-print printer (mbytevector->bytevector text) #f)
          (set! pos.potential (- pos.potential (- pos.actual start)))
          (set! pos.actual start)))
      (define (newline-instead) (set! pos.potential (- pos.potential 1)) (newline))
      (define (push-placement size t attr)
        (set! pos.potential (+ pos.potential size))
        (let ((g group.inner))
          (if g
              (begin (group-rt*-add! g (make-placement size t attr))
                     (constrain-width))
              (place size t attr))))
      (define (group-run g horizontal?)
        (for-each
          (lambda (t)
            (cond ((group? t) (group-run t #t))
                  ((eqv? t 'space^newline) (if horizontal? (place 1 #" " #f) (newline-instead)))
                  (else (place (placement-size t) (placement-text t) (placement-attr t)))))
          (reverse (group-rt* g))))
      (define (pop)
        (let ((g group.outer))
          (set! start* (cons (+ pos.actual (group-indent g)) start*))
          (let ((child (group-child g)))
            (if child (group-set-parent! child #f) (set! group.inner #f))
            (set! group.outer child))
          (group-run g #f)))
      (define (flush)           (let loop () (when group.outer (pop) (loop))))
      (define (constrain-width) (let loop ()
                                  (when (and group.outer (< width pos.potential)) (pop) (loop))))
      (make-layout
        (lambda (text attr) (push-placement (utf8-length text) text attr))
        (lambda (indent) (let ((g (make-group group.inner indent)))
                           (unless group.outer (set! group.outer g))
                           (set! group.inner g)))
        (lambda () (let ((g group.inner))
                     (if g
                         (let ((parent (group-parent g)))
                           (set! group.inner parent)
                           (if parent
                               (begin (group-set-child! parent #f) (group-rt*-add! parent g))
                               (begin (set! group.outer #f) (group-run g #t))))
                         (begin (set! start* (cdr start*))
                                (when (null? start*) (error "layout-group-end outside a group"))))))
        (lambda () (push-placement 1 #" " #f))
        (lambda () (flush) (newline))
        (lambda () (if group.inner
                       (begin (set! pos.potential (+ pos.potential 1))
                              (constrain-width)
                              (let ((g group.inner))
                                (if g (group-rt*-add! g 'space^newline) (newline-instead))))
                       (newline)))))))

(splicing-local
  ((define (make-gbnode prev indent) (let ((gbn (mvector prev #f indent)))
                                       (when prev (gbnode-set-next! prev gbn))
                                       gbn))
   (define (gbnode?          x)        (mvector? x))
   (define (gbnode-prev      gbn)      (mvector-ref  gbn 0))
   (define (gbnode-next      gbn)      (mvector-ref  gbn 1))
   (define (gbnode-set-prev! gbn prev) (mvector-set! gbn 0 prev))
   (define (gbnode-set-next! gbn next) (mvector-set! gbn 1 next))
   (define (gbnode-indent    gbn)      (mvector-ref  gbn 2))
   (define (gbnode-active?   gbn)      (gbnode-indent gbn))
   (define (gbnode-deactivate! gbn)
     (mvector-set! gbn 2 #f)
     (let ((prev (gbnode-prev gbn)) (next (gbnode-next gbn)))
       (when prev (gbnode-set-next! prev next))
       (when next (gbnode-set-prev! next prev))))
   (define (make-placement size text attr) (vector size text attr))
   (define (placement-size p) (vector-ref p 0))
   (define (placement-text p) (vector-ref p 1))
   (define (placement-attr p) (vector-ref p 2))
   (define (make-seg t*) t*)
   (define (seg-t*        s) s)
   (define (seg-complete? s) (not (ormap (lambda (t) (and (gbnode? t) (gbnode-active? t)))
                                         (seg-t* s))))
   (define fifo.empty '(() . ()))
   (define (fifo-empty? q)   (null? (car q)))
   (define (fifo-top    q)   (car (car q)))
   (define (fifo-pop    q)   (let ((out (cdr (car q))))
                               (if (null? out)
                                   (cons (reverse (cdr q)) '())
                                   (cons out (cdr q)))))
   (define (fifo-push   q x) (if (null? (car q))
                                 (cons (list x) '())
                                 (cons (car q) (cons x (cdr q))))))
  (define (layout:compact printer width)
    (mlet ((single-line-group-depth 1)
           (start* '(0)) (pos.actual 0) (pos.potential 0) (seg* fifo.empty) (rt* #f) (gbn.last #f))
      (define (group-push indent)
        (set! start* (cons (+ pos.actual indent) start*))
        (set! single-line-group-depth (+ single-line-group-depth 1)))
      (define (group-pop)
        (flush)
        (set! start* (cdr start*))
        (when (null? start*) (error "layout-group-end outside a group"))
        (set! single-line-group-depth (max (- single-line-group-depth 1) 0)))
      (define (place size text attr)
        (set! pos.actual (+ pos.actual size))
        (printer-print printer text attr))
      (define (newline)
        (let* ((start (car start*))
               (text  (make-mbytevector start 32)))
          (printer-newline printer)
          (printer-print printer (mbytevector->bytevector text) #f)
          (set! pos.potential (- pos.potential (- pos.actual start)))
          (set! pos.actual start)
          (set! single-line-group-depth 1)))
      (define (pop)
        (let* ((seg  (let ((s* seg*))
                       (if (fifo-empty? s*)
                           (let ((seg (make-seg (reverse rt*))))
                             (set! rt* #f)
                             seg)
                           (let ((seg (fifo-top s*)))
                             (set! seg* (fifo-pop s*))
                             seg))))
               (t*   (seg-t* seg))
               (size (+ 1 (foldl (lambda (t size) (if (gbnode? t) size (+ (placement-size t) size)))
                                 0 t*))))
          (if (and (<= (+ pos.actual size) width) (seg-complete? seg))
              (place 1 #" " #f)
              (begin (set! pos.potential (- pos.potential 1))
                     (newline)))
          (for-each (lambda (t)
                      (if (gbnode? t)
                          (when (gbnode-active? t)
                            (group-push (gbnode-indent t))
                            (when (eqv? t gbn.last) (set! gbn.last (gbnode-prev t)))
                            (gbnode-deactivate! t))
                          (place (placement-size t) (placement-text t) (placement-attr t))))
                    t*)))
      (define (flush)           (let loop () (when rt*                               (pop) (loop))))
      (define (constrain-width) (let loop () (when (and rt* (< width pos.potential)) (pop) (loop))))
      (define (push-placement size t attr)
        (set! pos.potential (+ pos.potential size))
        (if rt*
            (begin (set! rt* (cons (make-placement size t attr) rt*))
                   (constrain-width))
            (place size t attr)))
      (make-layout
        (lambda (text attr) (push-placement (utf8-length text) text attr))
        (lambda (indent)
          (if rt*
              (let ((gbn (make-gbnode gbn.last indent)))
                (set! gbn.last gbn)
                (set! rt* (cons gbn rt*)))
              (group-push indent)))
        (lambda ()
          (let ((last gbn.last))
            (if last
                (let ((prev (gbnode-prev last)))
                  (set! gbn.last prev)
                  (gbnode-deactivate! last)
                  (unless prev (flush)))
                (group-pop))))
        (lambda () (push-placement 1 #" " #f))
        (lambda () (flush) (newline))
        (lambda () (if (< 0 single-line-group-depth)
                       (begin (set! pos.potential (+ pos.potential 1))
                              (when rt*
                                (constrain-width)
                                (if gbn.last
                                    (set! seg* (fifo-push seg* (make-seg (reverse rt*))))
                                    (flush)))
                              (set! rt* '())
                              (constrain-width))
                       (begin (flush) (newline))))))))

;;;;;;;;;;;;;;
;;; Writer ;;;
;;;;;;;;;;;;;;
;;; A writer consumes a stream of tokens coming from a structured data source.  Each writer
;;; operation corresponds to a type of token, taking a text value, optional attribute, and a source
;;; datum parameter when applicable.
(define (make-writer atom prefix dot left-bracket right-bracket)
  (vector atom prefix dot left-bracket right-bracket))
(define (writer-atom          w text attr datum) ((vector-ref w 0) text attr datum))
(define (writer-prefix        w text attr datum) ((vector-ref w 1) text attr datum))
(define (writer-dot           w text attr)       ((vector-ref w 2) text attr))
(define (writer-left-bracket  w text attr datum) ((vector-ref w 3) text attr datum))
(define (writer-right-bracket w text attr)       ((vector-ref w 4) text attr))

(define (writer-decorate/sgr w sgr.prefix sgr.dot sgr.bracket atom->sgr)
  (define (decorate attr sgr) (or attr sgr))
  (make-writer
    (lambda (t attr x) (writer-atom          w t (decorate attr (atom->sgr x)) x))
    (lambda (t attr x) (writer-prefix        w t (decorate attr sgr.prefix)    x))
    (lambda (t attr)   (writer-dot           w t (decorate attr sgr.dot)))
    (lambda (t attr x) (writer-left-bracket  w t (decorate attr sgr.bracket)   x))
    (lambda (t attr)   (writer-right-bracket w t (decorate attr sgr.bracket)))))

(define (writer:layout l)
  (mlet ((depth 0) (separate? #f) (right-bracket-count 0))
    (define (end-bracketed!)
      (range-for-each (lambda (i) (layout-group-end l)) right-bracket-count)
      (set! right-bracket-count 0)
      (set! separate? #t))
    (define (separate)
      (when (< 0 right-bracket-count) (end-bracketed!))
      (when separate? (layout-space^newline l))
      (set! separate? #t))
    (define (place t attr) (layout-place l t attr))
    (make-writer
      (lambda (text attr datum) (separate) (place text attr))
      (lambda (text attr datum) (separate) (place text attr) (set! separate? #f))
      (lambda (text attr)       (separate) (place text attr))
      (lambda (text attr datum)
        (separate)
        (place text attr)
        (set! separate? #f)
        (layout-group-begin l 0)
        (set! depth (+ depth 1)))
      (lambda (text attr)
        (place text attr)
        (set! depth (- depth 1))
        (set! right-bracket-count (+ right-bracket-count 1))
        (unless (< 0 depth) (end-bracketed!))))))

(define (writer:layout/sgr l sgr.prefix sgr.dot sgr.bracket datum->sgr)
  (writer-decorate/sgr (writer:layout l) sgr.prefix sgr.dot sgr.bracket datum->sgr))

;;;;;;;;;;;;;;
;;; Reader ;;;
;;;;;;;;;;;;;;
;;; A reader consumes a stream of tokens coming from an unstructured data source such as text.
;;; Each reader operation corresponds to a type of token, taking parameters for source position and
;;; length, followed by parameters for any token-specific details, and returning a boolean
;;; indicating whether its driver should continue sending tokens.
(define (make-reader atom prefix dot left-bracket right-bracket datum-comment-prefix comment newline eof error)
  (vector atom prefix dot left-bracket right-bracket datum-comment-prefix comment newline eof error))
(define (reader-atom                 r pos size datum)          ((vector-ref r 0) pos size datum))
(define (reader-prefix               r pos size type)           ((vector-ref r 1) pos size type))
(define (reader-dot                  r pos size)                ((vector-ref r 2) pos size))
(define (reader-left-bracket         r pos size shape type len) ((vector-ref r 3) pos size shape type len))
(define (reader-right-bracket        r pos size shape)          ((vector-ref r 4) pos size shape))
(define (reader-datum-comment-prefix r pos size)                ((vector-ref r 5) pos size))
(define (reader-comment              r pos size)                ((vector-ref r 6) pos size))
(define (reader-newline              r pos)                     ((vector-ref r 7) pos))
(define (reader-eof                  r pos)                     ((vector-ref r 8) pos))
(define (reader-error                r pos exception)           ((vector-ref r 9) pos exception))

;;;;;;;;;;;;;;;;
;;; Notation ;;;
;;;;;;;;;;;;;;;;
;; structure:
;; - abbreviate-prefix?
;;   - for: quote quasiquote unquote unquote-splicing syntax quasisyntax unsyntax unsyntax-splicing
;; - abbreviate-pair?
;; - bracket: `( [ {`
;; - length-prefix?
;; - bytevector-numeric?
;; - number
;;   - implicit-radix: 2 8 10 16
;;     - determines which radix does not need a prefix
;;     - read should be given an impicit-radix to decide how to recognize unprefixed numbers
;;   - radix: #f 2 8 10 16
;;     - #f (the default) to use implicit-radix
;;   - fraction
;;     - ratio
;;     - decimal (falls back to ratio if there would be unallowed repetition)
;;     - decimal/repeat
;;   - exponent
;;     - above: #f or nonnegative integer
;;       - use scientific notation for decimal fractions when (>= (abs value) (expt radix above))
;;       - #f is infinity
;;     - below: #f or nonpositive integer
;;       - use scientific notation for decimal fractions when (< 0 (abs value) (expt radix below))
;;       - #f is infinity
(define number-notation.default
  '((implicit-radix . 10) (radix . #f) (fraction . ratio) (exponent (above . #f) (below . -3))))
(define notation.empty '())
(define notation.default
  `((abbreviate-prefix? . #f)
    (abbreviate-pair? . #t)
    (bracket . 40)  ; "("
    (length-prefix? . #f)
    (bytevector-numeric? . #f)
    (number . ,number-notation.default)))
(define (notation-ref notation key)
  (atree-ref/k notation key (lambda () (error "missing notation key" key notation)) (lambda (v) v)))
(define (notation-override notation notation.override) (atree-replace notation notation.override))

(splicing-local
  ((define byte:dquote 34)
   (define byte:# 35) (define byte:+ 43) (define byte:- 45) (define byte:. 46) (define byte:/ 47)
   (define byte:0 48) (define byte:semicolon 59) (define byte:@ 64) (define byte:A 65)
   (define byte:B 66) (define byte:D 68) (define byte:E 69) (define byte:O 79) (define byte:P 80)
   (define byte:X 88) (define byte:backslash 92) (define byte:a 97) (define byte:b 98)
   (define byte:d 100) (define byte:e 101) (define byte:f 102) (define byte:n 110)
   (define byte:o 111) (define byte:p 112) (define byte:r 114) (define byte:t 116)
   (define byte:v 118) (define byte:x 120) (define byte:pipe 124) (define byte:~ 126)
   (define (punctuation? c) (memv c (bytevector->list #"\"#'(),;[]`{}")))
   (define (undigit16 d) (cond ((< d byte:A)    (- d byte:0))
                               ((< d byte:a) (+ (- d byte:A) 10))
                               (else         (+ (- d byte:a) 10))))
   (define (digit16-count n) (if (< 0 n) (+ (floor-log n 16) 1) 1))
   (define (radix?! r) (unless (memv r '(2 8 10 16)) (error "radix not in (2 8 10 16)" r)))
   (define (set-nat-radix-digits! mbv start count n radix)
     (let loop ((i (+ start count -1)) (n n))
       (when (<= start i)
         (let-values (((q r) (integer-floor-divmod n radix)))
           (mbytevector-set! mbv i (if (< r 10) (+ r byte:0) (+ (- r 10) byte:A)))
           (loop (- i 1) q))))))
  (define (make-number->utf8 notation)
    (let* ((notation  (notation-override number-notation.default notation))
           (iradix    (notation-ref notation '(implicit-radix)))
           (radix     (or (notation-ref notation '(radix)) iradix))
           (prefix    (begin (radix?! iradix) (radix?! radix)
                             (and (not (eqv? iradix radix))
                                  (case radix ((2) #"#b") ((8) #"#o") ((10) #"#d") (else #"#x")))))
           (fraction  (notation-ref notation '(fraction)))
           (exp-above (notation-ref notation '(exponent above)))
           (exp-below (notation-ref notation '(exponent below)))
           (exp-above (if (or (not exp-above) (nonnegative-integer? exp-above))
                          (and exp-above (not (eqv? fraction 'ratio)) (expt radix exp-above))
                          (error "(exponent above) is not #f or a nonnegative integer" exp-above)))
           (exp-below (if (or (not exp-below) (nonpositive-integer? exp-below))
                          (and exp-below (not (eqv? fraction 'ratio)) (expt radix exp-below))
                          (error "(exponent below) is not #f or a nonpositive integer" exp-below))))
      (define (integer->utf8 n)
        (cond ((< n 0) (let* ((len (+ (floor-log (- n) radix) 2)) (mbv (make-mbytevector len 0)))
                         (mbytevector-set! mbv 0 byte:-)
                         (set-nat-radix-digits! mbv 1 (- len 1) (- n) radix)
                         (mbytevector->bytevector mbv)))
              ((< 0 n) (let* ((len (+ (floor-log n radix) 1)) (mbv (make-mbytevector len 0)))
                         (set-nat-radix-digits! mbv 0 len n radix)
                         (mbytevector->bytevector mbv)))
              (else #"0")))
      (define (ratio->utf8 n) (bytevector-append (integer->utf8 (numerator n)) #"/"
                                                 (integer->utf8 (denominator n))))
      (define (repeat?->decimal->utf8 repeat?)
        (define non-repeating?
          (let ((check1 (lambda (a) (lambda (n) (= (integer-floor-mod (denominator n) a) 0))))
                (check2 (lambda (a b) (lambda (n) (let ((d (denominator n)))
                                                    (or (= (integer-floor-mod d a) 0)
                                                        (= (integer-floor-mod d b) 0)))))))
            (cond ((= (integer-floor-mod radix 2) 0)
                   (cond ((= (integer-floor-mod radix 3) 0) (check2 2 3))
                         ((= (integer-floor-mod radix 5) 0) (check2 2 5))
                         ((= (integer-floor-mod radix 7) 0) (check2 2 7))
                         (else                              (check1 2))))
                  ((= (integer-floor-mod radix 3) 0)
                   (if (= (integer-floor-mod radix 5) 0) (check2 3 5) (check1 3)))
                  (else (check1 radix)))))
        (define (rhs-digit-counts n)
          (let loop-non-repeating ((n n) (non-repeating-count 0))
            (cond ((= n 0) (values non-repeating-count 0))
                  ((non-repeating? n) (let* ((m (* n radix)) (n (- m (floor m))))
                                        (loop-non-repeating n (+ non-repeating-count 1))))
                  ((not repeat?) (values 1 1))  ; early abort
                  (else (let ((start n))
                          (let loop-repeating ((n n) (repeating-count 1))
                            (let* ((m (* n radix)) (n (- m (floor m))))
                              (if (= n start)
                                  (values non-repeating-count repeating-count)
                                  (loop-repeating n (+ repeating-count 1))))))))))
        (define (go n mag power)
          (let* ((mag   (/ mag (expt radix power)))
                 (whole (floor mag))
                 (part  (- mag whole)))
            (let-values (((non-repeating-count repeating-count) (rhs-digit-counts part)))
              (if (and (not repeat?) (< 0 repeating-count))
                  (ratio->utf8 n)
                  (let* ((part-len          (+ non-repeating-count repeating-count))
                         (part-len          (if (< 0 part-len) (+ part-len 1) 0))
                         (part-len          (if (< 0 repeating-count) (+ part-len 1) part-len))
                         (part              (* (expt radix non-repeating-count) part))
                         (non-repeating     (floor part))
                         (part              (- part non-repeating))
                         (repeating         (floor (* (expt radix repeating-count) part)))
                         (power-digit-count (if (= power 0) 0 (+ (floor-log (abs power) radix) 1)))
                         (whole-digit-count (if (= whole 0) 1 (+ (floor-log whole radix) 1)))
                         (len               (+ whole-digit-count part-len power-digit-count
                                               (if (< n 0) 1 0)
                                               (cond ((< power 0) 2) ((= power 0) 0) (else 1))))
                         (mbv               (make-mbytevector len 0)))
                    (let* ((i (if (< n 0)
                                  (begin (mbytevector-set! mbv 0 byte:-)
                                         1)
                                  0))
                           (i (begin (set-nat-radix-digits! mbv i whole-digit-count whole radix)
                                     (+ i whole-digit-count)))
                           (i (if (< 0 part-len)
                                  (begin
                                    (mbytevector-set! mbv i byte:.)
                                    (let* ((i (+ i 1))
                                           (i (begin (set-nat-radix-digits!
                                                       mbv i non-repeating-count non-repeating
                                                       radix)
                                                     (+ i non-repeating-count))))
                                      (if (< 0 repeating-count)
                                          (begin (mbytevector-set! mbv i byte:~)
                                                 (let ((i (+ i 1)))
                                                   (set-nat-radix-digits! mbv i repeating-count
                                                                          repeating
                                                                          radix)
                                                   (+ i repeating-count)))
                                          i)))
                                  i))
                           (i (if (< 0 power-digit-count)
                                  (begin (mbytevector-set! mbv i (if (<= radix 10) byte:e byte:p))
                                         (+ i 1))
                                  i))
                           (i (if (< power 0)
                                  (begin (mbytevector-set! mbv i byte:-)
                                         (+ i 1))
                                  i)))
                      (set-nat-radix-digits! mbv i power-digit-count power radix)
                      (mbytevector->bytevector mbv)))))))
        (lambda (n) (let ((mag (abs n)))
                      (cond ((and exp-below (< mag exp-below)) (go n mag (floor-log mag radix)))
                            ((and exp-above (< exp-above mag)) (go n mag (floor-log mag radix)))
                            (else                              (go n mag 0))))))
      (define fraction->utf8
        (case fraction
          ((ratio)          ratio->utf8)
          ((decimal)        (repeat?->decimal->utf8 #f))
          ((decimal/repeat) (repeat?->decimal->utf8 #t))
          (else (error "fraction not in (ratio decimal decimal/repeat)" fraction))))
      (lambda (n) (let ((text (if (or (not (integer? n)) (and exp-above (< exp-above (abs n))))
                                  (fraction->utf8 n)
                                  (integer->utf8 n))))
                    (if prefix (bytevector-append prefix text) text)))))
  (define (radix->number->utf8 radix) (make-number->utf8 '((implicit-radix . radix) (radix . #f))))
  (define number->utf8                (make-number->utf8 notation.empty))
  (define number->utf8/decimal        (make-number->utf8 '((fraction . decimal))))
  (define number->utf8/decimal/repeat (make-number->utf8 '((fraction . decimal/repeat))))
  (define utf8->number
    (let ((go (lambda (bv radix)
                (radix?! radix)
                (let ((len (bytevector-length bv)))
                  (define (Radix radix i k)
                    (and (< i len)
                         (let ((b (bytevector-ref bv i)))
                           (if (= b byte:#)
                               (let ((i (+ i 1)))
                                 (and (< i len)
                                      (let ((b (bytevector-ref bv i)))
                                        (let ((i (+ i 1)))
                                          (and (< i len)
                                               (let ((c (bytevector-ref bv i)))
                                                 (cond
                                                   ((or (= b byte:b) (= b byte:B)) (k 2 i c))
                                                   ((or (= b byte:o) (= b byte:O)) (k 8 i c))
                                                   ((or (= b byte:d) (= b byte:D)) (k 10 i c))
                                                   ((or (= b byte:x) (= b byte:X)) (k 16 i c))
                                                   (else #f))))))))
                               (k radix i b)))))
                  (define (Sign i b k)
                    (define (next sign)
                      (let ((i (+ i 1)))
                        (and (< i len) (k sign i (bytevector-ref bv i)))))
                    (cond ((= b byte:-) (next -1))
                          ((= b byte:+) (next  1))
                          (else         (k 1 i b))))
                  (define (RadixSign radix i k)
                    (Radix radix i (lambda (radix i b) (Sign i b (lambda (sign i b)
                                                                   (k radix sign i b))))))
                  (define (Digit* radix i b k.more k.end)
                    (let loop ((n 0) (digit-count 0) (i i) (b b))
                      (let ((x (undigit16 b)))
                        (if (< -1 x radix)
                            (let ((n (+ (* n radix) x)) (digit-count (+ digit-count 1)) (i (+ i 1)))
                              (if (< i len)
                                  (loop n digit-count i (bytevector-ref bv i))
                                  (k.end n digit-count)))
                            (k.more n digit-count i b)))))
                  (define (Digit+ radix i k.more k.end)
                    (if (< i len)
                        (Digit* radix i (bytevector-ref bv i) k.more k.end)
                        (k.end 0 0)))
                  (define (Exp n radix i b)
                    (and (or (= b byte:e) (= b byte:E) (= b byte:p) (= b byte:P))
                         (RadixSign radix (+ i 1)
                                    (lambda (radix sign i b)
                                      (Digit* radix i b
                                              (lambda (x digit-count i b) #f)
                                              (lambda (x digit-count)
                                                (and (< 0 digit-count)
                                                     (* n (expt radix (* sign x))))))))))
                  (RadixSign
                    radix 0
                    (lambda (radix sign i b)
                      (define (decimal lhs lhs-digit-count rhs rhs-digit-count rep rep-digit-count)
                        (and (or (< 0 lhs-digit-count) (< 0 rhs-digit-count))
                             (let ((rhs (if (< 0 rep-digit-count)
                                            (+ rhs (/ rep (- (expt radix rep-digit-count) 1)))
                                            rhs)))
                               (* sign (+ lhs (/ rhs (expt radix rhs-digit-count)))))))
                      (Digit*
                        radix i b
                        (lambda (n digit-count i b)
                          (if (= b byte:.)
                              (Digit+
                                radix (+ i 1)
                                (lambda (rhs rhs-digit-count i b)
                                  (if (= b byte:~)
                                      (Digit+
                                        radix (+ i 1)
                                        (lambda (repeating repeating-digit-count i b)
                                          (and (< 0 repeating-digit-count)
                                               (let ((n (decimal n digit-count rhs rhs-digit-count
                                                                 repeating
                                                                 repeating-digit-count)))
                                                 (and n (Exp n radix i b)))))
                                        (lambda (repeating repeating-digit-count)
                                          (and (< 0 repeating-digit-count)
                                               (decimal n digit-count rhs rhs-digit-count repeating
                                                        repeating-digit-count))))
                                      (let ((n (decimal n digit-count rhs rhs-digit-count 0 0)))
                                        (and n (Exp n radix i b)))))
                                (lambda (rhs rhs-digit-count)
                                  (decimal n digit-count rhs rhs-digit-count 0 0)))
                              (and (< 0 digit-count)
                                   (if (= b byte:/)
                                       (Digit+ radix (+ i 1)
                                               (lambda (d digit-count i b) #f)
                                               (lambda (d digit-count)
                                                 (and (< 0 digit-count)
                                                      (* sign (/ n d)))))
                                       (Exp (* sign n) radix i b)))))
                        (lambda (n digit-count)
                          (and (< 0 digit-count) (* sign n))))))))))
      (case-lambda
        ((bv)       (go bv 10))
        ((bv radix) (go bv radix)))))
  (define (make-notate notation)
    (let* ((notation            (notation-override notation.default notation))
           (abbreviate-prefix?  (notation-ref notation '(abbreviate-prefix?)))
           (abbreviate-pair?    (notation-ref notation '(abbreviate-pair?)))
           (bracket-index       (case (notation-ref notation '(bracket))
                                  ((40  #"(" "(" round)  0)
                                  ((91  #"[" "[" square) 1)
                                  ((123 #"{" "{" curly)  2)
                                  (=> (lambda (b) "not a bracket" b))))
           (length-prefix?      (notation-ref notation '(length-prefix?)))
           (bytevector-numeric? (notation-ref notation '(bytevector-numeric?)))
           (number-notation     (notation-ref notation '(number)))
           (n->utf8             (make-number->utf8 number-notation))
           (text.left-bracket   (vector-ref '#(#"(" #"[" #"{") bracket-index))
           (text.right-bracket  (vector-ref '#(#")" #"]" #"}") bracket-index))
           (text.null           (bytevector-append text.left-bracket text.right-bracket)))
      (lambda (writer x)
        (let notate ((x x))
          (define (atom         text x) (writer-atom          writer text               #f x))
          (define (prefix       text x) (writer-prefix        writer text               #f x))
          (define (dot)                 (writer-dot           writer #"."               #f))
          (define (left-bracket text x) (writer-left-bracket  writer text               #f x))
          (define (right-bracket)       (writer-right-bracket writer text.right-bracket #f))
          (define (notate-text t.prefix byte:delim delim? bv len)
            (let loop ((i 0) (size 0) (delim? delim?))
              (if (< i len)
                  (let* ((b0 (bytevector-ref bv i))
                         (kf (lambda _ (loop (+ i 1) (+ (digit16-count b0)
                                                        (bytevector-length #"\\x;"))))))
                    (utf8-decode-width/k
                      b0 kf
                      (lambda (width)
                        (utf8-ref/b0&width/k
                          bv i b0 width kf
                          (lambda (c)
                            (case c
                              ((7 8 9 10 11 12 13 27 92) (loop (+ i 1) (+ size 2) #t))
                              (else (cond ((eqv? c byte:delim) (loop (+ i 1) (+ size 2) #t))
                                          ((or (unicode-control? c) (unicode-vspace? c))
                                           (loop (+ i width) (+ size (digit16-count c)
                                                                (bytevector-length #"\\u;"))
                                                 #t))
                                          (else (loop (+ i width) (+ size width)
                                                      (or delim? (unicode-hspace? c)
                                                          (punctuation? c))))))))))))
                  (let* ((len.t.prefix (bytevector-length t.prefix))
                         (size         (+ size len.t.prefix (if delim? 2 0)))
                         (mbv          (make-mbytevector size 0)))
                    (when delim?
                      (mbytevector-set! mbv len.t.prefix byte:delim)
                      (mbytevector-set! mbv (- size 1)   byte:delim))
                    (mbytevector-copy! mbv 0 t.prefix 0 len.t.prefix)
                    (let loop ((i 0) (j (+ len.t.prefix (if delim? 1 0))))
                      (define (slash-escape b)
                        (mbytevector-set! mbv j byte:backslash)
                        (mbytevector-set! mbv (+ j 1) b)
                        (loop (+ i 1) (+ j 2)))
                      (define (code-escape width prefix c)
                        (let ((dcount (digit16-count c)) (len.prefix (bytevector-length prefix)))
                          (mbytevector-copy! mbv j prefix 0 len.prefix)
                          (mbytevector-set! mbv (+ j dcount len.prefix) byte:semicolon)
                          (set-nat-radix-digits! mbv (+ j len.prefix) dcount c 16)
                          (loop (+ i width) (+ j dcount len.prefix 1))))
                      (if (< i len)
                          (let* ((b0 (bytevector-ref bv i))
                                 (kf (lambda _ (code-escape 1 #"\\x" b0))))
                            (utf8-decode-width/k
                              b0 kf
                              (lambda (width)
                                (utf8-ref/b0&width/k
                                  bv i b0 width kf
                                  (lambda (c)
                                    (case c
                                      ((7)  (slash-escape byte:a))
                                      ((8)  (slash-escape byte:b))
                                      ((9)  (slash-escape byte:t))
                                      ((10) (slash-escape byte:n))
                                      ((11) (slash-escape byte:v))
                                      ((12) (slash-escape byte:f))
                                      ((13) (slash-escape byte:r))
                                      ((27) (slash-escape byte:e))
                                      ((92) (slash-escape byte:backslash))
                                      (else (cond ((eqv? c byte:delim) (slash-escape byte:delim))
                                                  ((or (unicode-control? c) (unicode-vspace? c))
                                                   (code-escape width #"\\u" c))
                                                  (else (mbytevector-copy! mbv j bv i width)
                                                        (loop (+ i width) (+ j width)))))))))))
                          (atom (mbytevector->bytevector mbv) x)))))))
          (cond
            ((null? x)   (atom text.null x))
            ((not x)     (atom #"#f"     x))
            ((eqv? x #t) (atom #"#t"     x))
            ((pair? x)   (let ((abbrev (and abbreviate-prefix?
                                            (symbol? (car x))
                                            (pair? (cdr x))
                                            (null? (cddr x))
                                            (case (car x)
                                              ((quote)             #"'")
                                              ((quasiquote)        #"`")
                                              ((unquote)           #",")
                                              ((unquote-splicing)  #",@")
                                              ((syntax)            #"#'")
                                              ((quasisyntax)       #"#`")
                                              ((unsyntax)          #"#,")
                                              ((unsyntax-splicing) #"#,@")
                                              (else                #f)))))
                           (if abbrev
                               (begin (prefix abbrev x) (notate (cadr x)))
                               (begin (left-bracket text.left-bracket x)
                                      (notate (car x))
                                      (if abbreviate-pair?
                                          (let loop ((x (cdr x)))
                                            (unless (null? x)
                                              (cond ((pair? x) (notate (car x)) (loop (cdr x)))
                                                    (else      (dot) (notate x)))))
                                          (begin (dot) (notate (cdr x))))
                                      (right-bracket)))))
            ((vector? x)
             (let ((len (vector-length x)))
               (left-bracket (bytevector-append #"#" (if length-prefix? (number->utf8 len) #"")
                                                text.left-bracket)
                             x)
               (unless (= len 0)
                 (notate (vector-ref x 0))
                 (range-for-each (lambda (i) (notate (vector-ref x i)))
                                 1
                                 (if (and (< 1 len) length-prefix?)
                                     (let ((last (vector-ref x (- len 1))))
                                       (let loop ((i (- len 2)))
                                         (if (equal? (vector-ref x i) last)
                                             (if (< 0 i) (loop (- i 1)) 1)
                                             (+ i 2))))
                                     len))))
             (right-bracket))
            ((bytevector? x)
             (let* ((len      (bytevector-length x))
                    (t.prefix (if length-prefix? (bytevector-append #"#" (number->utf8 len)) #"#"))
                    (len      (if (and (< 1 len) length-prefix?)
                                  (let ((last (bytevector-ref x (- len 1))))
                                    (let loop ((i (- len 2)))
                                      (if (equal? (bytevector-ref x i) last)
                                          (if (< 0 i) (loop (- i 1)) 1)
                                          (+ i 2))))
                                  len)))
               (if bytevector-numeric?
                   (begin (left-bracket (bytevector-append t.prefix #"vu8" text.left-bracket) x)
                          (range-for-each (lambda (i) (notate (bytevector-ref x i))) len)
                          (right-bracket))
                   (notate-text t.prefix byte:dquote #t x len))))
            ((string? x) (let ((bv (string->utf8 x)))
                           (notate-text #"" byte:dquote #t bv (bytevector-length bv))))
            ((symbol? x)
             (cond ((eqv? x '||)  (atom #"||"  x))
                   ((eqv? x '|.|) (atom #"|.|" x))
                   (else (let ((bv (string->utf8 (symbol->string x))))
                           (notate-text #"" byte:pipe (or (= (bytevector-ref bv 0) byte:@)
                                                          (utf8->number bv))
                                        bv (bytevector-length bv))))))
            ((number? x)      (atom (n->utf8 x)       x))
            ((mbytevector? x) (atom #"#<mbytevector>" x))
            ((mvector? x)     (atom #"#<mvector>"     x))
            ((procedure? x)   (atom #"#<procedure>"   x))
            (else             (atom #"#<unknown>"     x))))))))
(define notate (make-notate notation.empty))

(define (make-number->string   notation) (let ((n->utf8 (make-number->utf8 notation)))
                                           (lambda (n) (utf8->string (n->utf8 n)))))
(define (radix->number->string r)        (let ((n->utf8 (radix->number->utf8 r)))
                                           (lambda (n) (utf8->string (n->utf8 n)))))
(define (number->string                n) (utf8->string (number->utf8                n)))
(define (number->string/decimal        n) (utf8->string (number->utf8/decimal        n)))
(define (number->string/decimal/repeat n) (utf8->string (number->utf8/decimal/repeat n)))

(define (string->number s . option*) (apply utf8->number (string->utf8 s) option*))

(define (string-append* x*) (utf8->string (bytevector-append* (map string->utf8 x*))))
(define (string-append . x*) (string-append* x*))
(define (string-join* separator x*)
  (utf8->string (bytevector-join* (string->utf8 separator) (map string->utf8 x*))))
(define (string-join separator . x*) (string-join* separator x*))

(define (make-local-gensym)
  (mlet ((count -1))
    (lambda (name)
      (set! count (+ count 1))
      (let ((name (cond ((bytevector? name) name)
                        ((string?     name) (string->utf8 name))
                        ((symbol?     name) (string->utf8 (symbol->string name)))
                        (else               (error "not a symbol, string, or bytevector" name)))))
        (string->symbol (utf8->string (bytevector-append name #"." (number->utf8 count))))))))

;; TODO: move this example
#;(let* ((example
         (append (list (utf8->string (bytevector 0 15 16 31 127
                                                 ;#x03BB
                                                 #b11001110 #b10111011
                                                 ;159
                                                 #b11000010 #b10011111
                                                 ;8192
                                                 #b11100010 #b10000000 #b10000000
                                                 ;8233
                                                 #b11100010 #b10000000 #b10101001))
                       (string->symbol "ze\ro") (string->symbol "@zero") (string->symbol "ze#ro"))
                 '(() (0) 1 #('2 three "four" "\fou\r" #(100 101 102 103 104 105 106 107 108 109 110 111) #"\fi\ve" #"fiveeee") #(6 7 7 7) #t #f . 10)))
       (example-writer/sgr (lambda (l)
                             (writer:layout/sgr l #"\e[33;5m" #"\e[31;5m" #"\e[32m"
                                                (lambda (datum)
                                                  (cond ((symbol? datum)  #"\e[34m")
                                                        ((number? datum)  #"\e[35m")
                                                        ((boolean? datum) #"\e[33m")
                                                        ((null? datum)    #"\e[32m")
                                                        (else             #"\e[36m"))))))
       (example-printer:stdout
         (lambda () (printer:port standard-output-port)))
       (example-printer-fill
         (lambda (p) (printer-fill p 80 #"." #f)))
       (example-printer
         (lambda () (example-printer-fill (example-printer:stdout))))
       (example-printer/sgr
         (lambda ()
           (example-printer-fill
             (printer-sgr-add (printer-decorate/sgr (example-printer:stdout))
                              #"\e[47m"))))
       (verbose-notate (make-notate '((abbreviate-prefix? . #t)
                                      (abbreviate-pair? . #f)
                                      (bracket . #"[")
                                      (length-prefix? . #t)
                                      (bytevector-numeric? . #t)))))
  (notate (writer:layout (layout:single-line (printer-truncate (example-printer) 78))) example)
  (oport-write-byte standard-output-port 10)
  (oport-write-byte standard-output-port 10)
  (notate (example-writer/sgr (layout:single-line (printer-truncate (example-printer/sgr) 78))) example)
  (oport-write-byte standard-output-port 10)
  (oport-write-byte standard-output-port 10)
  (notate (writer:layout (layout:single-line (printer-line-wrap (example-printer) 78))) example)
  (oport-write-byte standard-output-port 10)
  (oport-write-byte standard-output-port 10)
  (notate (example-writer/sgr (layout:single-line (printer-line-wrap (example-printer/sgr) 78))) example)
  (oport-write-byte standard-output-port 10)
  (oport-write-byte standard-output-port 10)
  (notate (writer:layout (layout:single-line (example-printer))) example)
  (oport-write-byte standard-output-port 10)
  (notate (example-writer/sgr (layout:single-line (example-printer/sgr))) example)
  (oport-write-byte standard-output-port 10)
  (verbose-notate (writer:layout (layout:single-line (example-printer))) example)
  (oport-write-byte standard-output-port 10)
  (verbose-notate (example-writer/sgr (layout:single-line (example-printer/sgr))) example)
  (oport-write-byte standard-output-port 10)
  (oport-write-byte standard-output-port 10)
  (let ((width 29))
    (notate (writer:layout (layout:compact (printer-truncate (example-printer) width) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (notate (example-writer/sgr (layout:compact (printer-truncate (example-printer/sgr) width) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (notate (writer:layout (layout:compact (example-printer) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (notate (example-writer/sgr (layout:compact (example-printer/sgr) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (verbose-notate (writer:layout (layout:compact (example-printer) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (verbose-notate (example-writer/sgr (layout:compact (example-printer/sgr) width)) example)
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)
    (mdefine correlation* '())
    (define (correlate! text attr line col size)
      (set! correlation* (cons (vector text attr line col size) correlation*)))
    (let* ((l      (layout:pretty (printer-correlate-location (example-printer) correlate!) width))
           (place  (lambda (t) (layout-place l t #f)))
           (gbegin (lambda () (layout-group-begin l 0)))
           (gend   (lambda () (layout-group-end l)))
           (s^nl   (lambda () (layout-space^newline l)))
           (nl     (lambda () (layout-newline l))))
      (gbegin)
      (place #"(")
      (gbegin)
      (place #"one")
      (s^nl)
      ;(nl)
      (place #"two")
      (s^nl)
      ;(nl)
      (place #"three")
      (s^nl)
      (place #"four")
      (place #")")
      (gend)
      (s^nl)
      (place #"five")
      ;(s^nl)
      (nl)
      (place #"six")
      (gend))
    (oport-write-byte standard-output-port 10)
    (oport-write-byte standard-output-port 10)))
