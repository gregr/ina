(define (open-input-file path) (open-input-file/k path raise-io-error values))
(define (open-input-file/k path kf k)
  (open-file-istream/k path kf (lambda (s) (k (istream->iport s)))))
(define (open-output-file path restriction)
  (open-output-file/k path restriction raise-io-error values))
(define (open-output-file/k path restriction kf k)
  (open-file-ostream/k path restriction kf (lambda (s) (k (ostream->oport s)))))

(define (open-file-istream path) (open-file-istream/k path raise-io-error values))
(define (open-file-ostream path restriction)
  (open-file-ostream/k path restriction raise-io-error values))
(define (directory-file*       path) (directory-file*/k       path raise-io-error values))
(define (make-symbolic-link to path) (make-symbolic-link/k to path raise-io-error values))
(define (make-directory        path) (make-directory/k        path raise-io-error values))
(define (move-file          old new) (move-file/k          old new raise-io-error values))
(define (delete-file           path) (delete-file/k           path raise-io-error values))
(define (delete-directory      path) (delete-directory/k      path raise-io-error values))
(define (file-type             path) (file-type/k             path raise-io-error values))
(define (file-size             path) (file-size/k             path raise-io-error values))
(define (file-permissions      path) (file-permissions/k      path raise-io-error values))
(define (file-modified-seconds path) (file-modified-seconds/k path raise-io-error values))
(define (set-file-permissions! path permissions)
  (set-file-permissions!/k path permissions raise-io-error values))
(define (set-file-modified-seconds! path seconds)
  (set-file-modified-seconds!/k path seconds raise-io-error values))

(define (find-file/env env name)
  (find-file/PATH (let ((kv (assv #"PATH" env))) (if kv (cdr kv) #"")) name))
(define (find-file/PATH PATH name)
  (find-file/directory* (bytevector-split PATH (bytevector-ref #":" 0)) name))
(define (find-file/directory* dir* name)
  (let ((name (if (string? name) (string->utf8 name) name)))
    (if (and (< 0 (bytevector-length name))
             (let ((b0 (bytevector-ref name 0)))
               (or (= b0 (bytevector-ref #"." 0)) (= b0 (bytevector-ref #"/" 0)))))
        (utf8->string name)
        (ormap (lambda (dir)
                 (let ((path (utf8->string (bytevector-join #"/" dir name))))
                   (and (file-type/k path (lambda _ #f) values)
                        path)))
               (map (lambda (dir) (if (string? dir) (string->utf8 dir) dir)) dir*)))))

(define (open-pipe-streams) (open-pipe-streams/k raise-io-error values))
(define (open-pipe)         (open-pipe/k         raise-io-error values))
(define (open-pipe/k kf k)
  (open-pipe-streams/k kf (lambda (out in) (k (ostream->oport out) (istream->iport in)))))

(define (host-process-in        p) (p 'in))
(define (host-process-out       p) (p 'out))
(define (host-process-err       p) (p 'err))
(define (host-process-pid       p) (p 'pid))
(define (host-process-wait      p) (p 'wait))
(define (host-process-kill      p) (p 'kill))
(define (host-process-interrupt p) (p 'interrupt))
(define (host-process in out err path arg* env)
  (host-process/k in out err path arg* env raise-io-error raise-io-error values))
(define (host-process/k in.0 out.0 err.0 path arg* env handle-internal-error kf k)
  (define (continue in out err)
    (define (x->fd x)
      (and x (let ((kv (assoc 'file-descriptor (iostream-description x))))
               (and kv (cdr kv)))))
    (raw-host-process/k
      (x->fd in) (x->fd out) (if (and err (or (eqv? out err) (eq? err 'stdout)))
                                 'stdout
                                 (x->fd err))
      path arg* env kf
      (lambda (p)
        (let ((in.p  (host-process-in  p))
              (out.p (host-process-out p))
              (err.p (host-process-err p)))
          (mlet ((fuse* '()))
            (define (fuse-io in out close!)
              (thread
                (lambda ()
                  (let* ((buffer-size 4096) (buffer (make-mbytevector buffer-size 0)))
                    (let loop ()
                      (istream-read/k
                        in buffer 0 1 buffer-size handle-internal-error close!
                        (lambda (amount)
                          (ostream-write/k out buffer 0 amount amount handle-internal-error
                                           (lambda (amount) (loop))))))))))
            (define (fuse*-push t) (set! fuse* (cons t fuse*)) #f)
            (define (fuse-input in out)
              (fuse-io in out (lambda () (ostream-close/k out handle-internal-error values))))
            (define (fuse-output in out)
              (fuse*-push
                (fuse-io in out (lambda () (istream-close/k in handle-internal-error values)))))
            (let ((out (and out.p (if out (fuse-output out.p out) out.p)))
                  (err (and err.p (if err (fuse-output err.p err) err.p)))
                  (in  (and in.p
                            (if in
                                (let ((cust (make-custodian)))
                                  (let ((t.in (current-custodian cust (lambda ()
                                                                        (fuse-input in in.p)))))
                                    (fuse*-push
                                      (thread
                                        (lambda ()
                                          (p 'wait)
                                          (custodian-shutdown-all cust)
                                          (thread-wait t.in)
                                          (ostream-close/k in.p handle-internal-error values))))))
                                in.p))))
              (k (if (null? fuse*)
                     p
                     (mlet ((status #f))
                       (set! status (thread (lambda () (let ((exit-code (p 'wait)))
                                                         (for-each thread-wait fuse*)
                                                         (set! status exit-code)
                                                         (set! fuse* '())))))
                       (lambda (method)
                         (case method
                           ((in)   in)
                           ((out)  out)
                           ((err)  err)
                           ((wait) (let ((current status))
                                     (if (number? current) current (begin (thread-wait current)
                                                                          status))))
                           (else   (p method)))))))))))))
  (define (k.out out)
    (define (k.err err)
      (let ((in (and in.0 (if (iostream? in.0) in.0 (iport->istream in.0)))))
        (continue in out err)))
    (cond ((not err.0)                                 (k.err #f))
          ((or (eqv? out.0 err.0) (eq? err.0 'stdout)) (k.err 'stdout))
          ((iostream? err.0)                           (k.err err.0))
          (else                                        (oport->ostream/k err.0 kf k.err))))
  (cond ((not out.0)       (k.out #f))
        ((iostream? out.0) (k.out out.0))
        (else              (oport->ostream/k out.0 kf k.out))))
