(define ($annotated    E ann)         (E-annotation-add E ann))
(define ($quote        value)         (E:quote          value))
(define ($ref          addr)          (E:ref            addr))
(define ($call         rator . rand*) (E:call           rator rand*))
(define ($apply/values rator vrand)   (E:apply/values   rator vrand))
(define ($if           c t f)         (E:if             c t f))

(splicing-local
  ((define (param->address stx)
     (let ((x (syntax-unwrap stx)))
       (unless (or (symbol? x) (not x)) (error "not a formal parameter" stx))
       (make-address x (syntax-provenance stx)))))
  (define ($case-lambda param*~* ^body*)
    (let* ((addr*~* (map (lambda (param) (improper-list-map param->address param)) param*~*))
           (body*   (map (lambda (addr*~ ^body)
                           (apply ^body (map $ref (improper-list->list addr*~))))
                         addr*~* ^body*)))
      (E:case-lambda addr*~* body*)))

  (define ($letrec param* ^rhs*&body)
    (let ((addr* (map param->address param*)))
      (let-values (((rhs* body) (apply ^rhs*&body (map $ref addr*))))
        (E:letrec addr* rhs* body)))))
