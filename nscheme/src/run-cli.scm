(define options
  `(((flags "-h" "--help")
     (description "Print this usage and option information, then exit.")
     ,(lambda (_)
        (displayln (usage-description path.self #"[<option> ...] [(<file> | -) <argument> ...]" options))
        (posix-exit 0)))
    ((flags "-q" "--quiet")
     (description "Suppress implicit printing when loading definitions.")
     ,(lambda (arg*) (set! quiet? #t) (loop arg*)))
    ((flags "-v" "--verbose")
     (description "Print diagnostic information during startup.")
     ,(lambda (arg*) (set! verbose? #t) (loop arg*)))
    ((flags "-r" "--reboot")
     (description "Load fresh copies of libraries that are normally persisted.")
     ,(lambda (arg*) (set! reboot? #t) (loop arg*)))
    ((flags "-i" "--interact")
     (description "Load definitions interactively from standard input after loading all other sources.")
     ,(lambda (arg*) (set! interact? #t) (loop arg*)))
    ((flags "-f" "--file")
     (description "Load definitions from <file>.")
     (arguments "<file>")
     ,(lambda (path arg*) (source*-add-file! path) (loop arg*)))
    ((flags "-t" "--text")
     (description "Load <definitions> from text provided directly on the command-line.")
     (arguments "<definitions>")
     ,(lambda (text.def* arg*) (source*-add-text! text.def*) (loop arg*)))
    ((flags "-c" "--compile")
     (description
       "Compile loaded definitions instead of evaluating them."
       "Generate code for <target> and write the generated code to <output-file>."
       "<backend> must be one of the following: TODO"
       "<output-file> may be '-' to write the generated code to standard output."
       "This option may be used multiple times to compile for multiple targets at once.")
     (arguments "<target>" "<output-file>")
     ,(lambda (target path.out arg*)
        (pretty-write `((target ,target) (output-file ,path.out)))
        (displayln "Compiler is not yet supported.")
        (posix-exit 1)))
    ((flags "-")
     (description "Pass through remaining command-line arguments.")
     ,(lambda (arg*) (finish 'stdin arg*)))
    ((flags "--")
     (description "Stop parsing option flags in remaining command-line arguments.")
     ,(lambda (arg*) (finish #f arg*)))))

(mdefine cli-arg* (current-posix-argument*))
(define path.self (car cli-arg*))
(define path.library (path-directory path.self))

(mdefine quiet? #f)
(mdefine verbose? #f)
(mdefine reboot? #f)
(mdefine interact? #f)
(mdefine source* '())
(define (source*-add! src) (set! source* (cons src source*)))
(define (source*-add-file! path) (source*-add! `(file ,path)))
(define (source*-add-text! txt)  (source*-add! `(text ,txt)))
(define (source*->def*)
  (if (null? source*)
      (verbose-displayln "No additional sources to load.")
      (verbose-displayln "Reading sources:"))
  (append* (map (lambda (source)
                  (case (car source)
                    ((file) (let ((path (cadr source)))
                              (verbose-write `(read-file ,path))
                              (posix-read-file-annotated path)))
                    ((text) (let ((text (cadr source)))
                              (verbose-write `(read-text ,text))
                              (read*-syntax (iport:bytevector text))))
                    (else (mistake "unexpected definition source" source))))
                source*)))

(define dispatch (options->dispatch options))
(define (loop arg*) (dispatch arg* (lambda () (finish #f arg*))))
(define (finish stdin? arg*)
  (cond (stdin?       (set! cli-arg* (cons path.self arg*)))
        ((pair? arg*) (source*-add-file! (car arg*))
                      (set! cli-arg* arg*))
        (else         (set! cli-arg* (list path.self))))
  (when (null? source*) (set! interact? #t))
  (set! source* (reverse source*)))

(loop (cdr cli-arg*))
(define out.verbose (and verbose? (current-error-port)))
(define (verbose-write . x*)
  (when verbose? (for-each (lambda (x) (pretty-write x out.verbose)) x*)))
(define (verbose-displayln . x*)
  (when verbose? (for-each (lambda (x) (displayln x out.verbose)) x*)))
(apply verbose-write
       `((quiet? ,quiet?)
         (verbose? ,verbose?)
         (reboot? ,reboot?)
         (interact? ,interact?)
         (command-line-arguments ,cli-arg*)
         (definition-sources . ,source*)
         (library-path ,path.library)
         (library-files . ,library=>path*)))

(define eval-def*
  (if quiet?
      eval-definition*
      (eval-definition*/yield (lambda x* (for-each pretty-write x*)))))

(let* ((library=>def* (make-library=>def* out.verbose #t library=>text*))
       (library=>env (make-library=>env out.verbose library=>text* library=>def*))
       (env (alist-ref library=>env 'large))
       (def* (source*->def*)))
  (current-posix-argument*
    cli-arg*
    (lambda ()
      (verbose-displayln (string-append "Loading source definitions: " (number->string (length def*))))
      (let ((env (env-conjoin (eval-def* env def*) env)))
        (when interact?
          (unless quiet? (displayln ";; Entering REPL"))
          ;; TODO: panic handling, abort, retry
          (let loop ((env env))
            (unless quiet? (displayln ";; Evaluate:"))
            (case-values (read)
              (()    (values))
              ((stx) (loop (env-conjoin (eval-def* env (list stx)) env))))))))))
