(define options
  `(((flags "-h" "--help")
     (description "Print this usage and option information, then exit.")
     ,(lambda (_)
        (displayln (usage-description path.self #"[<option> ...] [(<file> | -) <argument> ...]" options))
        (posix-exit 0)))
    ((flags "-q" "--quiet")
     (description "Suppress implicit printing when loading definitions.")
     ,(lambda (arg*) (set! quiet? #t) (loop arg*)))
    ((flags "-v" "--verbose")
     (description "Print diagnostic information during startup.")
     ,(lambda (arg*) (set! verbose? #t) (loop arg*)))
    ((flags "-r" "--reboot")
     (description "Load fresh copies of libraries that are normally persisted.")
     ,(lambda (arg*) (set! reboot? #t) (loop arg*)))
    ((flags "-i" "--interact")
     (description "Load definitions interactively from standard input after loading all other sources.")
     ,(lambda (arg*) (set! interact? #t) (loop arg*)))
    ((flags "-f" "--file")
     (description "Load definitions from <file>.")
     (arguments "<file>")
     ,(lambda (path arg*) (source*-add-file! path) (loop arg*)))
    ((flags "-t" "--text")
     (description "Load <definitions> from text provided directly on the command-line.")
     (arguments "<definitions>")
     ,(lambda (text.def* arg*) (source*-add-text! text.def*) (loop arg*)))
    ((flags "-c" "--compile")
     (description
       "Compile loaded definitions instead of evaluating them."
       "Generate code for <target> and write the generated code to <output-file>."
       "<backend> must be one of the following: TODO"
       "<output-file> may be '-' to write the generated code to standard output."
       "This option may be used multiple times to compile for multiple targets at once.")
     (arguments "<target>" "<output-file>")
     ,(lambda (target path.out arg*) (compiler-output*-add! target path.out) (loop arg*)))
    ((flags "-")
     (description "Pass through remaining command-line arguments.")
     ,(lambda (arg*) (finish 'stdin arg*)))
    ((flags "--")
     (description "Stop parsing option flags in remaining command-line arguments.")
     ,(lambda (arg*) (finish #f arg*)))))

(mdefine cli-arg* (current-posix-argument*))
(define path.self (car cli-arg*))

(mdefine quiet? #f)
(mdefine verbose? #f)
(mdefine reboot? #f)
(mdefine interact? #f)
(mdefine compiler-output* '())
(mdefine source* '())
(define (compiler-output*-add! target path)
  (set! compiler-output* (cons (cons (bytevector->symbol target) path) compiler-output*)))
(define (source*-add! src) (set! source* (cons src source*)))
(define (source*-add-file! path) (source*-add! `(file ,path)))
(define (source*-add-text! txt)  (source*-add! `(text ,txt)))
(define (source*->def*)
  (if (null? source*)
      (verbose-displayln "No additional sources to load.")
      (verbose-displayln "Reading sources:"))
  (append* (map (lambda (source)
                  (case (car source)
                    ((file) (let ((path (cadr source)))
                              (verbose-write `(read-file ,path))
                              (posix-read-file-annotated path)))
                    ((text) (let ((text (cadr source)))
                              (verbose-write `(read-text ,text))
                              (read*-syntax (iport:bytevector text))))
                    (else (mistake "unexpected definition source" source))))
                source*)))
(define (source*->path&text)
  (if (null? source*)
      (verbose-displayln "No additional sources to load.")
      (verbose-displayln "Reading sources:"))
  (map (lambda (source)
         (case (car source)
           ((file) (let ((path (cadr source)))
                     (verbose-write `(read-file-text ,path))
                     (cons path (file->bytevector path))))
           ((text) (let ((text (cadr source)))
                     (verbose-write `(read-text ,text))
                     (cons #f text)))
           (else (mistake "unexpected definition source" source))))
       source*))

(define dispatch (options->dispatch options))
(define (loop arg*) (dispatch arg* (lambda () (finish #f arg*))))
(define (finish stdin? arg*)
  (cond (stdin?       (set! cli-arg* (cons path.self arg*)))
        ((pair? arg*) (source*-add-file! (car arg*))
                      (set! cli-arg* arg*))
        (else         (set! cli-arg* (list path.self))))
  (when (null? source*) (set! interact? #t))
  (set! source* (reverse source*)))

(loop (cdr cli-arg*))
(define out.verbose (and verbose? (current-error-port)))
(define (verbose-write . x*)
  (when verbose? (for-each (lambda (x) (pretty-write x out.verbose)) x*)))
(define (verbose-displayln . x*)
  (when verbose? (for-each (lambda (x) (displayln x out.verbose)) x*)))
(verbose-displayln
  "This program uses a persisted copy of the library file data that it was built with."
  "Rebuild this program to update the library files it uses.")
(apply verbose-write
       `((quiet? ,quiet?)
         (verbose? ,verbose?)
         (reboot? ,reboot?)
         (interact? ,interact?)
         (command-line-arguments ,cli-arg*)
         (definition-sources . ,source*)
         (compiler-outputs . ,compiler-output*)
         (library-files . ,library=>path*)))
(define library=>def* (make-library=>def* out.verbose #t library=>text*))

(if (null? compiler-output*)
    (let* ((library=>env (make-library=>env out.verbose library=>text* library=>def*))
           (env (alist-ref library=>env 'large))
           (def* (source*->def*)))
      (define eval-def*
        (if quiet?
            eval-definition*
            (eval-definition*/yield (lambda x* (for-each pretty-write x*)))))
      (current-posix-argument*
        cli-arg*
        (lambda ()
          (verbose-displayln (string-append "Loading source definitions: " (number->string (length def*))))
          (let ((env (env-conjoin (eval-def* env def*) env)))
            (when interact?
              (unless quiet? (displayln ";; Entering REPL"))
              ;; TODO: panic handling, abort, retry
              (let loop ((env env))
                (unless quiet? (displayln ";; Evaluate:"))
                (case-values (read)
                  (()    (values))
                  ((stx) (loop (env-conjoin (eval-def* env (list stx)) env))))))))))
    (let ((E.program
            (parse-bootstrapped-program-definition*
              library=>text* library=>def*
              `((let* ((library=>text* ',library=>text*)
                       (library=>def* (make-library=>def* #f #t library=>text*))
                       (library=>env (make-library=>env #f library=>text* library=>def*))
                       (env (alist-ref library=>env 'large))
                       (program (make-program))
                       (def*.source*
                         (append*
                           (alist-map
                             ',(source*->path&text)
                             (lambda (path text)
                               ((text->definition*/read*
                                  (if path (read*-syntax-annotated/source path) read*-syntax))
                                text))))))
                  (program-parse-definition* program env def*.source*)
                  (E-eval (program->E program)))))))
      (displayln "Compiler is not yet supported." (current-error-port))
      (posix-exit 1)
      (verbose-displayln "Generating code:")
      ;; TODO: generate code for each target and write it to the corresponding output
      (compact-write (E-pretty E.program))
      (verbose-displayln "Testing evaluation:")
      (pretty-write (apply/values list (E-eval E.program)))))
