(splicing-local
  ((define (comma sub . x*) (comma* sub x*))
   (define (comma* sub x*)
     (if (null? x*) '() (let loop ((x (sub (car x*))) (x* (cdr x*)))
                          (if (null? x*) x (loop (list x ", " (sub (car x*))) (cdr x*))))))
   (define (c:rand    x) (c:expr/context 'rand    x))
   (define (c:prefix  x) (c:expr/context 'prefix  x))
   (define (c:postfix x) (c:expr/context 'postfix x))
   (define (c:lhs     x) (c:expr x)))
  (define (c:expr x) (c:expr/context 'expr x))
  (define (c:expr/context context x)
    (define (plow     x) (case context ((rand prefix postfix) (list "(" x ")")) (else x)))
    (define (pmid     x) (case context ((prefix postfix)      (list "(" x ")")) (else x)))
    (define (pprefix  x) (if (eqv? context 'postfix) (list "(" x ")") x))
    (define (ppostfix x) (if (eqv? context 'prefix)  (list "(" x ")") x))
    (define ((c:binop* op) a b . x*)
      (let loop ((x (list (c:rand a) op (c:rand b))) (x* x*))
        (if (null? x*) (plow x) (loop (list "(" x ")" op (c:rand (car x*))) (cdr x*)))))
    (define ((c:binop    op) a b)     (plow (list (c:rand a) op (c:rand b))))
    (define ((c:assign   op) lhs rhs) (plow (list (c:lhs lhs) op (c:expr rhs))))
    (define ((c:prefixop op) x)       (pprefix (list op (c:prefix x))))
    (cond ((symbol?  x) x)
          ((boolean? x) (if x "1" "0"))
          ((integer? x) (number->string x))
          ((string?  x) (call/oport:bytes (lambda (out) (write x out))))
          ((vector?  x) (list "{" (comma* c:expr (vector->list x)) "}"))
          (else
            (apply
              (case (car x)
                ((:)      (lambda (type x . x*) (list (c:expr type) " " (apply comma c:expr x x*))))
                ((access) (lambda (root . field*)
                            (when (null? field*) (mistake "access operator without field" x))
                            (let loop ((root (c:postfix root)) (field* field*))
                              (if (null? field*)
                                  (ppostfix root)
                                  (let ((field (car field*)) (field* (cdr field*)))
                                    (if (eqv? field '->)
                                        (if (null? field*)
                                            (mistake "-> not followed by field" x)
                                            (loop (list root "->" (car field*)) (cdr field*)))
                                        (loop (list root "." field) field*)))))))
                ((index)  (lambda (root . i*)
                            (when (null? i*) (mistake "index operator without indices" x))
                            (let loop ((root (c:postfix root)) (i* i*))
                              (if (null? i*)
                                  (ppostfix root)
                                  (loop (list root "[" (c:expr (car i*)) "]") (cdr i*))))))
                ((ref)    (lambda (root) (pprefix (list "&" (c:prefix root)))))
                ((deref)  (lambda (root) (pprefix (list "*" (c:prefix root)))))
                ((cast)   (lambda (type x) (pmid (list "(" (c:expr type) ")" (c:expr x)))))
                ((-) (case-lambda
                       ((x) (list "-" (c:rand x)))
                       (x* (apply (c:binop* " - ") x*))))
                ((+) (c:binop* " + ")) ((*) (c:binop* " * ")) ((/) (c:binop* " / "))
                ((%) (c:binop* " % ")) ((<<) (c:binop* " << ")) ((>>) (c:binop* " >> "))
                ((band) (c:binop* " & ")) ((bor) (c:binop* " | ")) ((bxor) (c:binop* " ^ "))
                ((and) (c:binop* " && ")) ((or) (c:binop* " || ")) ((==) (c:binop " == "))
                ((!=) (c:binop " != ")) ((<) (c:binop " < ")) ((>) (c:binop " > "))
                ((<=) (c:binop " <= ")) ((>=) (c:binop " >= "))
                ((:=) (c:assign " = ")) ((+=) (c:assign " += ")) ((-=) (c:assign " -= "))
                ((*=) (c:assign " *= ")) ((/=) (c:assign " /= ")) ((%=) (c:assign " %= "))
                ((<<=) (c:assign " <<= ")) ((>>=) (c:assign " >>= "))
                ((band=) (c:assign " &= ")) ((bor=) (c:assign " |= ")) ((bxor=) (c:assign " ^= "))
                ((++) (c:prefixop "++")) ((--) (c:prefixop "--"))
                ((~) (c:prefixop "~")) ((not) (c:prefixop "!"))
                ((call) (lambda (rator . rand*)
                          (list (c:postfix rator) (list "(" (comma* c:expr rand*) ")"))))
                ((sizeof) (lambda (x) (list "sizeof(" (c:expr x) ")")))
                ((begin) (lambda (x . x*) (plow (apply comma c:expr x x*))))
                ((if)    (lambda (c t f)
                           (plow (list (c:rand c) " ? " (c:rand t) " : " (c:rand f)))))
                ((cond)  (lambda (c . c*)
                           (let loop ((context context) (c c) (c* c*))
                             (if (null? c*)
                                 (if (eqv? (car c) 'else)
                                     (c:rand (cadr c))
                                     (mistake "cond expression without else" x))
                                 (let ((x (list (c:rand (car c)) " ? " (c:rand (cadr c)) " : "
                                                (loop 'rand (car c*) (cdr c*)))))
                                   (case context
                                     ((rand prefix postfix) (list "(" x ")"))
                                     (else                  x)))))))
                ((extern static auto register const restrict volatile)
                 => (lambda (tag) (lambda (x) (list tag " " (c:expr x)))))
                ((struct union enum)
                 => (lambda (tag) (lambda (name) (plow (list (c:expr tag) " " (c:expr name))))))
                ((V)  (lambda (s) s))
                (else (mistake "bad C syntax" x)))
              (cdr x)))))
  (define c:type c:expr)

  (define (c:stmt/indent indent x)
    (define nl (list "\n" indent))
    (define (stmt x) (let ((indent (list "  " indent))) (list "\n" indent (c:stmt/indent indent x))))
    (define (make-if c x*) (list "if (" (c:expr c) ") {" (map stmt x*) nl "}"))
    (define (aggregate tag y*)
      (define (body x*)
        (when (null? x*) (mistake "bad aggregate syntax" tag y*))
        (let ((field* (car x*)) (init* (cdr x*)))
          (list "{" (if (null? field*)
                        "}"
                        (list (if (eqv? tag 'enum)
                                  (let loop ((f (car field*)) (f* (cdr field*)))
                                    (list "\n  " indent (c:expr f)
                                          (if (null? f*) '() (list "," (loop (car f*) (cdr f*))))))
                                  (map stmt field*))
                              nl "}"))
                (if (null? init*) '() (list " " (comma* c:expr init*))) ";")))
      (list (c:expr tag) " "
            (if (symbol? (car y*))
                (list (c:expr (car y*)) " " (body (cdr y*)))
                (body y*))))
    (if (pair? x)
        (apply
          (case (car x)
            ((fn inline-fn)
             (lambda (rtype name param* . body*)
               (append (if (eqv? (car x) 'inline)
                           '("inline ")
                           '())
                       (list (c:expr rtype) " " name "(" (comma* c:expr param*) ") {"
                             (map stmt body*) nl "}"))))
            ((return break continue goto)
             => (lambda (tag) (case-lambda
                                (() (list tag ";"))
                                ((x) (list tag " " (c:expr x) ";")))))
            ((local) (lambda x* (list "{" (map stmt x*) nl "}")))
            ((when) (lambda (c . x*) (make-if c x*)))
            ((unless) (lambda (c . x*) (make-if (list 'not c) x*)))
            ((cond) (lambda (c . c*)
                      (let loop ((c c) (c* c*))
                        (if (null? c*)
                            (if (eqv? (car c) 'else)
                                (list "{" (map stmt (cdr c)) nl "}")
                                (make-if (car c) (cdr c)))
                            (list (make-if (car c) (cdr c)) " else " (loop (car c*) (cdr c*)))))))
            ((while)    (lambda (c . x*)
                          (list (list "while (" (c:expr c) ") {") (map stmt x*) nl "}")))
            ((do-while) (lambda (c . x*)
                          (list "do {" (map stmt x*) (list nl "} while (" (c:expr c) ");"))))
            ((for)      (lambda (init c step . x*)
                          (list "for (" (c:expr init) "; " (c:expr c) "; " (c:expr step) ") {"
                                (map stmt x*) nl "}")))
            ((case switch)
             => (lambda (tag)
                  (lambda (input . c*)
                    (let ((end (if (eqv? tag 'case) (list nl "  break;") '())))
                      (list "switch (" (c:expr input) ") {"
                            (map (lambda (c)
                                   (list (if (eqv? (car c) 'else)
                                             (list nl "default:")
                                             (map (lambda (tag) (list nl "case " (c:expr tag) ":"))
                                                  (car c)))
                                         (map stmt (cdr c))
                                         end))
                                 c*)
                            nl "}")))))
            ((typedef) (lambda (t . x*)
                         (list "typedef " (case t
                                            ((struct union enum) (aggregate t x*))
                                            (else (list (c:expr t) " " (comma* c:expr x*) ";"))))))
            ((struct union enum) => (lambda (tag) (lambda x* (aggregate tag x*))))

            ((label)  (lambda (name) (list (c:expr name) ":")))
            ((V)      (lambda (s) s))
            (else     (lambda _ (list (c:expr x) ";"))))
          (cdr x))
        (list (c:expr x) ";")))
  (define (c:stmt x) (c:stmt/indent '() x))
  (define c:decl c:stmt))

(define (c-emit c out)
  (let loop ((c c))
    (cond ((string? c) (oport-write-bytes out c))
          ((symbol? c) (oport-write-bytes out (symbol->string c)))
          (else        (for-each loop c)))))

(define (c-flatten c) (call/oport:bytes (lambda (out) (c-emit c out))))
