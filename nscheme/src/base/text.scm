;;; Text values are assumed to be UTF-8-encoded.

;;;;;;;;;;;;;;;;
;;; Printing ;;;
;;;;;;;;;;;;;;;;
;;; To interoperate safely with printer targets that perform compositing, calls to printer-print
;;; must emit text horizontally in a predictable manner.  This means that text passed to
;;; printer-print must not contain control codes or markup that change vertical position or that
;;; nonlocally transform text or other ambient state.  Vertical spacing should be requested by
;;; calling printer-newline.
(define (make-printer print newline) (vector print newline))
(define (printer-print   p text attr) ((vector-ref p 0) text attr))
(define (printer-newline p)           ((vector-ref p 1)))

(define (printer:port port) (make-printer (lambda (t _) (oport-write-bytevector port t))
                                          (lambda ()    (oport-write-byte port 10))))

(define (printer-map p f)
  (make-printer
    (lambda (text attr) (let-values (((text attr) (f text attr))) (printer-print p text attr)))
    (lambda ()          (printer-newline p))))
(define (printer-map-text/attribute p f)
  (make-printer
    (lambda (text attr) (printer-print p (f text attr) attr))
    (lambda ()          (printer-newline p))))
(define (printer-map-attribute p f)
  (make-printer
    (lambda (text attr) (printer-print p text (f attr)))
    (lambda ()          (printer-newline p))))

(define (printer-fill p width byte attr)
  (mlet ((size 0))
    (make-printer
      (lambda (text attr)
        (set! size (+ size (~utf8-length text)))
        (printer-print p text attr))
      (lambda ()
        (when (< size width) (printer-print p (make-bytevector (- width size) byte) attr))
        (set! size 0)
        (printer-newline p)))))

(define (printer-truncate p width)
  (mlet ((size 0))
    (make-printer
      (lambda (text attr)
        (let ((current-size size))
          (when (< current-size width)
            (let* ((ulen (~utf8-length text)) (new-size (+ current-size ulen)))
              (if (<= new-size width)
                  (begin (set! size new-size) (printer-print p text attr))
                  (let* ((ulen   (- ulen (- new-size width)))
                         (len    (~utf8-index text 0 ulen))
                         (prefix (make-mbytevector len 0)))
                    (mbytevector-copy! prefix 0 text 0 len)
                    (set! size width)
                    (printer-print p (mbytevector->bytevector prefix) attr)))))))
      (lambda () (set! size 0) (printer-newline p)))))

(define (printer-line-wrap p width)
  (mlet ((size 0))
    (make-printer
      (lambda (text attr)
        (let* ((ulen (~utf8-length text)) (new-size (+ size ulen)))
          (if (<= new-size width)
              (begin (set! size new-size) (printer-print p text attr))
              (let ((len.full (bytevector-length text)))
                (let loop ((start 0) (ulen ulen) (new-size new-size))
                  (let* ((ulen.rhs (- new-size width))
                         (len.lhs  (~utf8-index text start (- ulen ulen.rhs)))
                         (lhs      (make-mbytevector len.lhs 0)))
                    (mbytevector-copy! lhs 0 text start len.lhs)
                    (printer-print p (mbytevector->bytevector lhs) attr)
                    (printer-newline p)
                    (let ((start (+ start len.lhs)) (ulen ulen.rhs))
                      (if (<= ulen width)
                          (let* ((len.lhs (- len.full start)) (lhs (make-mbytevector len.lhs 0)))
                            (mbytevector-copy! lhs 0 text start len.lhs)
                            (set! size ulen)
                            (printer-print p (mbytevector->bytevector lhs) attr))
                          (loop start ulen ulen)))))))))
      (lambda () (set! size 0) (printer-newline p)))))

(define (printer-correlate-location p correlate!)
  (mlet ((line 0) (col 0))
    (make-printer
      (lambda (text attr) (let ((size (~utf8-length text)))
                            (correlate! text attr line col size)
                            (set! col (+ col size))
                            (printer-print p text attr)))
      (lambda ()          (set! line (+ line 1)) (set! col 0) (printer-newline p)))))

;;;;;;;;;;;;;;
;;; Layout ;;;
;;;;;;;;;;;;;;
;;; Layout commands express preferences, not guarantees.  The layout policy is responsible for
;;; determining when and how preferences are realized.
;;; - The layout-place command requests that text be presented, optionally with an attribute that
;;;   may contain metadata to be correlated with the text, or preferences in how the text is
;;;   displayed, including styling, coloring, markup, etc.  The text value itself should be plain,
;;;   and not embed any attributes.
;;; - The layout-space, layout-newline and layout-space^newline commands request separation, and
;;;   respectively indicate a preference for spacing in the horizontal or vertical direction, or no
;;;   preference at all for layout-space^newline.  Whether the preferred direction is used or not is
;;;   decided by the layout policy.
;;; - The layout-group-begin and layout-group-end commands form groups of aligned lines of text.  A
;;;   new group is specified with an indentation amount that will be calculated relative to its
;;;   first line, and that will be applied to subsequent lines.
;;; - Assumptions:
;;;   - A layout-group-end can only be followed by layout-newline, layout-space^newline, or another
;;;     layout-group-end.
;;;   - Groups will not be pathologically nested.
;;;   - Incomplete groups may prevent layout effects from being observed.
;;;   - Top-level uses of layout-space^newline followed by layout-place or layout-space will
;;;     eventually be terminated with layout-newline, layout-space^newline, or a complete group.
;;;   - In the case of a terminating layout-space^newline, its effect might never be observed.
;;;     - But layout effects preceding the layout-space^newline will be observed.
(define (make-layout place group-begin group-end space newline space^newline)
  (vector place group-begin group-end space newline space^newline))
(define (layout-place         l text attr) ((vector-ref l 0) text attr))
(define (layout-group-begin   l indent)    ((vector-ref l 1) indent))
(define (layout-group-end     l)           ((vector-ref l 2)))
(define (layout-space         l)           ((vector-ref l 3)))
(define (layout-newline       l)           ((vector-ref l 4)))
(define (layout-space^newline l)           ((vector-ref l 5)))

(define (layout:single-line printer)
  (define (space) (printer-print printer #" " #f))
  (make-layout (lambda (text attr) (printer-print printer text attr))
               (lambda (indent)    (values))
               (lambda ()          (values))
               space space space))

(splicing-local
  ((define byte:space 32)
   (define (make-group parent indent) (let ((g (mvector parent #f indent '())))
                                        (when parent (group-set-child! parent g))
                                        g))
   (define (group?            x)   (mvector? x))
   (define (group-parent      g)   (mvector-ref  g 0))
   (define (group-child       g)   (mvector-ref  g 1))
   (define (group-indent      g)   (mvector-ref  g 2))
   (define (group-rt*         g)   (mvector-ref  g 3))
   (define (group-set-parent! g p) (mvector-set! g 0 p))
   (define (group-set-child!  g c) (mvector-set! g 1 c))
   (define (group-rt*-add!    g t) (mvector-set! g 3 (cons t (mvector-ref g 3))))
   (define (make-placement size text attr) (vector size text attr))
   (define (placement-size p) (vector-ref p 0))
   (define (placement-text p) (vector-ref p 1))
   (define (placement-attr p) (vector-ref p 2)))
  (define (layout:pretty printer width)
    (mlet ((start* '(0)) (pos.actual 0) (pos.potential 0) (group.outer #f) (group.inner #f))
      (define (place size text attr)
        (set! pos.actual (+ pos.actual size))
        (printer-print printer text attr))
      (define (newline)
        (let* ((start (car start*))
               (text  (make-mbytevector start byte:space)))
          (printer-newline printer)
          (printer-print printer (mbytevector->bytevector text) #f)
          (set! pos.potential (- pos.potential (- pos.actual start)))
          (set! pos.actual start)))
      (define (newline-instead) (set! pos.potential (- pos.potential 1)) (newline))
      (define (push-placement size t attr)
        (set! pos.potential (+ pos.potential size))
        (let ((g group.inner))
          (if g
              (begin (group-rt*-add! g (make-placement size t attr))
                     (constrain-width))
              (place size t attr))))
      (define (group-run g horizontal?)
        (for-each
          (lambda (t)
            (cond ((group? t) (group-run t #t))
                  ((eqv? t 'space^newline) (if horizontal? (place 1 #" " #f) (newline-instead)))
                  (else (place (placement-size t) (placement-text t) (placement-attr t)))))
          (reverse (group-rt* g))))
      (define (pop)
        (let ((g group.outer))
          (set! start* (cons (+ pos.actual (group-indent g)) start*))
          (let ((child (group-child g)))
            (if child (group-set-parent! child #f) (set! group.inner #f))
            (set! group.outer child))
          (group-run g #f)))
      (define (flush)           (let loop () (when group.outer (pop) (loop))))
      (define (constrain-width) (let loop ()
                                  (when (and group.outer (< width pos.potential)) (pop) (loop))))
      (make-layout
        (lambda (text attr) (push-placement (~utf8-length text) text attr))
        (lambda (indent) (let ((g (make-group group.inner indent)))
                           (unless group.outer (set! group.outer g))
                           (set! group.inner g)))
        (lambda () (let ((g group.inner))
                     (if g
                         (let ((parent (group-parent g)))
                           (set! group.inner parent)
                           (if parent
                               (begin (group-set-child! parent #f) (group-rt*-add! parent g))
                               (begin (set! group.outer #f) (group-run g #t))))
                         (begin (set! start* (cdr start*))
                                (when (null? start*) (mistake 'layout-group-end "not inside a group"))))))
        (lambda () (push-placement 1 #" " #f))
        (lambda () (flush) (newline))
        (lambda () (if group.inner
                       (begin (set! pos.potential (+ pos.potential 1))
                              (constrain-width)
                              (let ((g group.inner))
                                (if g (group-rt*-add! g 'space^newline) (newline-instead))))
                       (newline)))))))

(splicing-local
  ((define byte:space 32)
   (define (make-gbnode prev indent) (let ((gbn (mvector prev #f indent)))
                                       (when prev (gbnode-set-next! prev gbn))
                                       gbn))
   (define (gbnode?          x)        (mvector? x))
   (define (gbnode-prev      gbn)      (mvector-ref  gbn 0))
   (define (gbnode-next      gbn)      (mvector-ref  gbn 1))
   (define (gbnode-set-prev! gbn prev) (mvector-set! gbn 0 prev))
   (define (gbnode-set-next! gbn next) (mvector-set! gbn 1 next))
   (define (gbnode-indent    gbn)      (mvector-ref  gbn 2))
   (define (gbnode-active?   gbn)      (gbnode-indent gbn))
   (define (gbnode-deactivate! gbn)
     (mvector-set! gbn 2 #f)
     (let ((prev (gbnode-prev gbn)) (next (gbnode-next gbn)))
       (when prev (gbnode-set-next! prev next))
       (when next (gbnode-set-prev! next prev))))
   (define (make-placement size text attr) (vector size text attr))
   (define (placement-size p) (vector-ref p 0))
   (define (placement-text p) (vector-ref p 1))
   (define (placement-attr p) (vector-ref p 2))
   (define (make-seg t*) t*)
   (define (seg-t*        s) s)
   (define (seg-complete? s) (not (ormap (lambda (t) (and (gbnode? t) (gbnode-active? t)))
                                         (seg-t* s))))
   (define fifo.empty '(() . ()))
   (define (fifo-empty? q)   (null? (car q)))
   (define (fifo-top    q)   (car (car q)))
   (define (fifo-pop    q)   (let ((out (cdr (car q))))
                               (if (null? out)
                                   (cons (reverse (cdr q)) '())
                                   (cons out (cdr q)))))
   (define (fifo-push   q x) (if (null? (car q))
                                 (cons (list x) '())
                                 (cons (car q) (cons x (cdr q))))))
  (define (layout:compact printer width)
    (mlet ((single-line-group-depth 1)
           (start* '(0)) (pos.actual 0) (pos.potential 0) (seg* fifo.empty) (rt* #f) (gbn.last #f))
      (define (group-push indent)
        (set! start* (cons (+ pos.actual indent) start*))
        (set! single-line-group-depth (+ single-line-group-depth 1)))
      (define (group-pop)
        (flush)
        (set! start* (cdr start*))
        (when (null? start*) (mistake 'layout-group-end "not inside a group"))
        (set! single-line-group-depth (max (- single-line-group-depth 1) 0)))
      (define (place size text attr)
        (set! pos.actual (+ pos.actual size))
        (printer-print printer text attr))
      (define (newline)
        (let* ((start (car start*))
               (text  (make-mbytevector start byte:space)))
          (printer-newline printer)
          (printer-print printer (mbytevector->bytevector text) #f)
          (set! pos.potential (- pos.potential (- pos.actual start)))
          (set! pos.actual start)
          (set! single-line-group-depth 1)))
      (define (pop)
        (let* ((seg  (let ((s* seg*))
                       (if (fifo-empty? s*)
                           (let ((seg (make-seg (reverse rt*))))
                             (set! rt* #f)
                             seg)
                           (let ((seg (fifo-top s*)))
                             (set! seg* (fifo-pop s*))
                             seg))))
               (t*   (seg-t* seg))
               (size (+ 1 (foldl (lambda (t size) (if (gbnode? t) size (+ (placement-size t) size)))
                                 0 t*))))
          (if (and (<= (+ pos.actual size) width) (seg-complete? seg))
              (place 1 #" " #f)
              (begin (set! pos.potential (- pos.potential 1))
                     (newline)))
          (for-each (lambda (t)
                      (if (gbnode? t)
                          (when (gbnode-active? t)
                            (group-push (gbnode-indent t))
                            (when (eqv? t gbn.last) (set! gbn.last (gbnode-prev t)))
                            (gbnode-deactivate! t))
                          (place (placement-size t) (placement-text t) (placement-attr t))))
                    t*)))
      (define (flush)           (let loop () (when rt*                               (pop) (loop))))
      (define (constrain-width) (let loop () (when (and rt* (< width pos.potential)) (pop) (loop))))
      (define (push-placement size t attr)
        (set! pos.potential (+ pos.potential size))
        (if rt*
            (begin (set! rt* (cons (make-placement size t attr) rt*))
                   (constrain-width))
            (place size t attr)))
      (make-layout
        (lambda (text attr) (push-placement (~utf8-length text) text attr))
        (lambda (indent)
          (if rt*
              (let ((gbn (make-gbnode gbn.last indent)))
                (set! gbn.last gbn)
                (set! rt* (cons gbn rt*)))
              (group-push indent)))
        (lambda ()
          (let ((last gbn.last))
            (if last
                (let ((prev (gbnode-prev last)))
                  (set! gbn.last prev)
                  (gbnode-deactivate! last)
                  (unless prev (flush)))
                (group-pop))))
        (lambda () (push-placement 1 #" " #f))
        (lambda () (flush) (newline))
        (lambda () (if (< 0 single-line-group-depth)
                       (begin (set! pos.potential (+ pos.potential 1))
                              (when rt*
                                (constrain-width)
                                (if gbn.last
                                    (set! seg* (fifo-push seg* (make-seg (reverse rt*))))
                                    (flush)))
                              (set! rt* '())
                              (constrain-width))
                       (begin (flush) (newline))))))))

;;;;;;;;;;;;;;
;;; Writer ;;;
;;;;;;;;;;;;;;
;;; A writer consumes a stream of tokens coming from a structured data source.  Each writer
;;; operation corresponds to a type of token, taking a text value, optional attribute, and a source
;;; datum parameter when applicable.
(define (make-writer atom prefix dot left-bracket right-bracket)
  (vector atom prefix dot left-bracket right-bracket))
(define (writer-atom          w text attr datum) ((vector-ref w 0) text attr datum))
(define (writer-prefix        w text attr datum) ((vector-ref w 1) text attr datum))
(define (writer-dot           w text attr)       ((vector-ref w 2) text attr))
(define (writer-left-bracket  w text attr datum) ((vector-ref w 3) text attr datum))
(define (writer-right-bracket w text attr)       ((vector-ref w 4) text attr))

(define (writer:layout l)
  (mlet ((depth 0) (separate? #f) (right-bracket-count 0))
    (define (end-bracketed!)
      (for-each (lambda (i) (layout-group-end l)) (range right-bracket-count))
      (set! right-bracket-count 0)
      (set! separate? #t))
    (define (separate)
      (when (< 0 right-bracket-count) (end-bracketed!))
      (when separate? (layout-space^newline l))
      (set! separate? #t))
    (define (place t attr) (layout-place l t attr))
    (make-writer
      (lambda (text attr datum) (separate) (place text attr))
      (lambda (text attr datum) (separate) (place text attr) (set! separate? #f))
      (lambda (text attr)       (separate) (place text attr))
      (lambda (text attr datum)
        (separate)
        (place text attr)
        (set! separate? #f)
        (layout-group-begin l 0)
        (set! depth (+ depth 1)))
      (lambda (text attr)
        (place text attr)
        (set! depth (- depth 1))
        (set! right-bracket-count (+ right-bracket-count 1))
        (unless (< 0 depth) (end-bracketed!))))))

;;;;;;;;;;;;;;
;;; Reader ;;;
;;;;;;;;;;;;;;
;;; A reader consumes a stream of tokens coming from an unstructured data source such as text.
;;; Every operation corresponds to a type of token, taking parameters for source location and text,
;;; followed by parameters for any token-specific details, and returning a boolean indicating
;;; whether its driver should continue sending tokens.
(define (make-reader atom prefix dot left-bracket right-bracket datum-comment-prefix comment newline eof error)
  (vector atom prefix dot left-bracket right-bracket datum-comment-prefix comment newline eof error))
(define (reader-atom                 r loc text datum)          ((vector-ref r 0) loc text datum))
(define (reader-prefix               r loc text type)           ((vector-ref r 1) loc text type))
(define (reader-dot                  r loc text)                ((vector-ref r 2) loc text))
(define (reader-left-bracket         r loc text shape type len) ((vector-ref r 3) loc text shape type len))
(define (reader-right-bracket        r loc text shape)          ((vector-ref r 4) loc text shape))
(define (reader-datum-comment-prefix r loc text)                ((vector-ref r 5) loc text))
(define (reader-comment              r loc text)                ((vector-ref r 6) loc text))
(define (reader-newline              r loc codepoint)           ((vector-ref r 7) loc codepoint))
(define (reader-eof                  r loc)                     ((vector-ref r 8) loc))
(define (reader-error                r loc text desc)           ((vector-ref r 9) loc text desc))
(define-values (read-error:kind read-error? read-error-location read-error-text)
  (make-exception-kind-etc error:kind 'read-error '#(location text)))
(define (make-read-error desc location text)
  (make-exception read-error:kind (vector desc location text)))
(define ((make-read-error-location-update f) e)
  (make-read-error (error-description e) (f (read-error-location e)) (read-error-text e)))
(define (raise-read-error . x*) (raise (apply make-read-error x*)))

(define ((reader:data/annotate annotate) yf yeof yield)
  (mlet ((frame* '()))
    (define (make-prefix loc text type) (cons 'prefix (annotate type loc text #f #f)))
    (define (prefix-type p) (cdr p))
    (define (make-seq loc text shape type len current-len x*)
      (vector loc text shape type len current-len x*))
    (define (make-empty-seq loc text shape type len) (make-seq loc text shape type len 0 '()))
    (define (seq?               x) (vector? x))
    (define (seq-loc            s) (vector-ref s 0))
    (define (seq-text           s) (vector-ref s 1))
    (define (seq-shape          s) (vector-ref s 2))
    (define (seq-type           s) (vector-ref s 3))
    (define (seq-length         s) (vector-ref s 4))
    (define (seq-current-length s) (vector-ref s 5))
    (define (seq-x*             s) (vector-ref s 6))
    (define (seq-full?          s) (and (seq-length s) (= (seq-length s) (seq-current-length s))))
    (define (seq-push  s x)
      (make-seq (seq-loc s) (seq-text s) (seq-shape s) (seq-type s) (seq-length s)
                (+ (seq-current-length s) 1) (cons x (seq-x* s))))
    (define (seq-cons* s)
      (make-seq (seq-loc s) (seq-text s) (seq-shape s) 'cons* (seq-length s) (seq-current-length s)
                (seq-x* s)))
    (define (fail loc text desc . x*)
      (yf (make-read-error (if (null? x*) desc (cons desc x*)) loc text)))
    (define (frame*-top)     (and (pair? frame*) (car frame*)))
    (define (frame*-retop f) (set! frame* (cons f (cdr frame*))) #t)
    (define (frame*-push  f) (set! frame* (cons f frame*)) #t)
    (define (frame*-pop)     (set! frame* (cdr frame*)) #t)
    (define (push-datum x)
      (let ((top (frame*-top)))
        (cond ((not top)                 (yield x))
              ((seq? top)                (frame*-retop (seq-push top x)))
              ((eqv? top 'datum-comment) (frame*-pop))
              ((eqv? top 'datum&rb)      (frame*-pop) (push-datum x) (frame*-push 'rb))
              (else                      (frame*-pop) (push-datum (list (prefix-type top) x))))))
    (define (fail-full top loc text)
      (fail loc text "too many values in sequence with length-prefix"
            (cons 'location (seq-loc top)) (cons 'length-prefix (seq-length top))
            (cons 'type (seq-type top)) (cons 'shape (seq-shape top))))
    (make-reader
      (lambda (loc text datum)
        (let ((top (frame*-top)))
          (cond ((eqv? top 'rb) (fail loc text "too many values following dot"))
                ((and (seq? top) (eqv? (seq-type top) 'bytevector))
                 (if (and (integer? datum) (<= 0 datum 255))
                     (push-datum datum)
                     (fail loc text "not a byte")))
                ((and (seq? top) (seq-full? top)) (fail-full top loc text))
                (else (push-datum (annotate datum loc text #f #f))))))
      (lambda (loc text type)
        (let ((top (frame*-top)))
          (cond ((eqv? top 'rb) (fail loc text "too many values following dot"))
                ((and (seq? top) (eqv? (seq-type top) 'bytevector)) (fail loc text "not a byte"))
                ((and (seq? top) (seq-full? top)) (fail-full top loc text))
                (else (frame*-push (make-prefix loc text type))))))
      (lambda (loc text)
        (let ((top (frame*-top)))
          (if (and (seq? top) (eqv? (seq-type top) 'list) (pair? (seq-x* top)))
              (begin (frame*-retop (seq-cons* top)) (frame*-push 'datum&rb))
              (fail loc text "misplaced dot" top))))
      (lambda (loc text shape type len)
        (let ((top (frame*-top)))
          (cond ((eqv? top 'rb) (fail loc text "too many values following dot"))
                ((and (seq? top) (eqv? (seq-type top) 'bytevector)) (fail loc text "not a byte"))
                ((and (seq? top) (seq-full? top)) (fail-full top loc text))
                (else (frame*-push (make-empty-seq loc text shape type len))))))
      (lambda (loc text shape)
        (define (check-shape s k)
          (let ((expected (seq-shape s)))
            (if (eqv? expected shape) (k) (fail loc text "mismatched closing bracket shape"
                                                (cons 'expected expected (cons 'found shape))))))
        (let ((top (frame*-top)))
          (cond ((eqv? top 'rb)
                 (frame*-pop)
                 (let ((top (frame*-top)))
                   (check-shape
                     top (lambda ()
                           (let ((x* (seq-x* top)))
                             (frame*-pop)
                             (let loop ((x (car x*)) (x* (cdr x*)))
                               (if (null? x*)
                                   (push-datum (annotate x (seq-loc top) (seq-text top) loc text))
                                   (loop (cons (car x*) x) (cdr x*)))))))))
                ((seq? top)
                 (check-shape
                   top (lambda ()
                         (define (go x*)
                           (let ((x* (reverse x*)))
                             (frame*-pop)
                             (push-datum (annotate (case (seq-type top)
                                                     ((vector)     (list->vector x*))
                                                     ((bytevector) (list->bytevector x*))
                                                     (else         x*))
                                                   (seq-loc top) (seq-text top) loc text))))
                         (let* ((x*  (seq-x* top))
                                (len (seq-length top))
                                (gap (and len (- len (seq-current-length top)))))
                           (if (and gap (< 0 gap))
                               (if (null? x*)
                                   (fail loc text "zero values in sequence with length-prefix"
                                         (cons 'length-prefix len) (cons 'type (seq-type top))
                                         (cons 'shape (seq-shape top)))
                                   (let ((x (car x*)))
                                     (let loop ((gap gap) (x* x*))
                                       (if (< 0 gap) (loop (- gap 1) (cons x x*)) (go x*)))))
                               (go x*))))))
                (else (fail loc text "misplaced closing bracket" shape)))))
      (lambda (loc text) (frame*-push 'datum-comment))
      (lambda (loc text) #t)
      (lambda (loc c)    #t)
      (lambda (loc)      (if (null? frame*) (yeof) (fail loc #"" "unexpected EOF")))
      fail)))
(define reader:data (reader:data/annotate (lambda (x loc text loc.end text.end) x)))

(define (make-line-location pos line line-pos) (vector pos line line-pos))
(define (line-location-absolute-position loc) (vector-ref loc 0))
(define (line-location-line              loc) (vector-ref loc 1))
(define (line-location-line-position     loc) (vector-ref loc 2))
(define ((reader-track-line/start line-start) r)
  (mlet ((prev-line-start* '()) (line-start line-start) (line-count 0))
    (define (make-loc line start pos) (make-line-location pos line (- pos start)))
    (define (translate pos)
      (if (null? prev-line-start*)
          (make-loc line-count line-start pos)
          (let loop ((i 0) (next line-start) (pos* prev-line-start*))
            (if (or (<= next pos) (null? pos*))
                (begin (set! prev-line-start* '()) (make-loc (- line-count i) next pos))
                (loop (+ i 1) (car pos*) (cdr pos*))))))
    (make-reader
      (lambda (pos text datum)          (reader-atom                 r (translate pos) text datum))
      (lambda (pos text type)           (reader-prefix               r (translate pos) text type))
      (lambda (pos text)                (reader-dot                  r (translate pos) text))
      (lambda (pos text shape type len) (reader-left-bracket         r (translate pos) text shape type len))
      (lambda (pos text shape)          (reader-right-bracket        r (translate pos) text shape))
      (lambda (pos text)                (reader-datum-comment-prefix r (translate pos) text))
      (lambda (pos text)                (reader-comment              r (translate pos) text))
      (lambda (pos c)                   (let ((start line-start) (current line-count))
                                          (set! prev-line-start* (cons start prev-line-start*))
                                          (set! line-start (+ pos 1))
                                          (set! line-count (+ current 1))
                                          (reader-newline r (make-loc current start pos) c)))
      (lambda (pos)                     (reader-eof                  r (translate pos)))
      (lambda (pos text desc)           (reader-error                r (translate pos) text desc)))))

;;;;;;;;;;;;;;;;
;;; Notation ;;;
;;;;;;;;;;;;;;;;
;; structure:
;; - abbreviate-prefix?
;;   - for: quote quasiquote unquote unquote-splicing syntax quasisyntax unsyntax unsyntax-splicing
;; - abbreviate-pair?
;; - bracket: `( [ {`
;; - length-prefix?
;; - bytevector-numeric?
;; - number
;;   - implicit-radix: 2 8 10 16
;;     - determines which radix does not need a prefix
;;     - read should be given an impicit-radix to decide how to recognize unprefixed numbers
;;   - radix: #f 2 8 10 16
;;     - #f (the default) to use implicit-radix
;;   - fraction
;;     - ratio
;;     - decimal (falls back to ratio if there would be unallowed repetition)
;;     - decimal/repeat
;;   - exponent
;;     - above: #f or nonnegative integer
;;       - use scientific notation for decimal fractions when (>= (abs value) (expt radix above))
;;       - #f is infinity
;;     - below: #f or nonpositive integer
;;       - use scientific notation for decimal fractions when (< 0 (abs value) (expt radix below))
;;       - #f is infinity
(define number-notation.default
  '((implicit-radix . 10) (radix . #f) (fraction . ratio) (exponent (above . #f) (below . -3))))
(define notation.empty '())
(define notation.default
  `((abbreviate-prefix? . #f)
    (abbreviate-pair? . #t)
    (bracket . 40)  ; "("
    (length-prefix? . #f)
    (bytevector-numeric? . #f)
    (number . ,number-notation.default)))
(define (notation-ref notation key)
  (atree-ref/k notation key (lambda () (mistake 'notation-ref "missing key" key notation)) (lambda (v) v)))
(define (notation-override notation notation.override) (atree-replace notation notation.override))

(splicing-local
  ((define byte:bell 7)
   (define byte:backspace 8) (define byte:tab 9) (define byte:newline 10) (define byte:vtab 11)
   (define byte:feed 12) (define byte:return 13) (define byte:escape 27) (define byte:space 32)
   (define byte:! 33) (define byte:dquote 34) (define byte:hash 35) (define byte:quote 39)
   (define byte:lparen 40) (define byte:rparen 41) (define byte:+ 43) (define byte:comma 44)
   (define byte:- 45) (define byte:. 46) (define byte:/ 47) (define byte:0 48) (define byte:8 56)
   (define byte:semicolon 59) (define byte:< 60) (define byte:@ 64) (define byte:A 65)
   (define byte:B 66) (define byte:D 68) (define byte:E 69) (define byte:F 70) (define byte:O 79)
   (define byte:P 80) (define byte:T 84) (define byte:X 88) (define byte:lsquare 91)
   (define byte:backslash 92) (define byte:rsquare 93) (define byte:backtick 96) (define byte:a 97)
   (define byte:b 98) (define byte:d 100) (define byte:e 101) (define byte:f 102)
   (define byte:n 110) (define byte:o 111) (define byte:p 112) (define byte:r 114)
   (define byte:t 116) (define byte:u 117) (define byte:v 118) (define byte:x 120)
   (define byte:lcurly 123) (define byte:pipe 124) (define byte:rcurly 125) (define byte:~ 126)
   (define (punctuation? c) (memv c (bytevector->list #"\"#'(),;[]`{|}")))
   (define (undigit10 x) (and x (let ((n (- x byte:0))) (and (< -1 n 10) n))))
   (define (undigit16 d) (if (< d byte:A) (- d byte:0) (+ (- (bitwise-and d #xDF) byte:A) 10)))
   (define (digit16-count n) (if (< 0 n) (+ (floor-log n 16) 1) 1))
   (define (radix?! r) (unless (memv r '(2 8 10 16)) (mistake 'radix "not in (2 8 10 16)" r)))
   (define (set-nat-radix-digits! mbv start count n radix)
     (let loop ((i (+ start count -1)) (n n))
       (when (<= start i)
         (let-values (((q r) (integer-floor-divmod n radix)))
           (mbytevector-set! mbv i (if (< r 10) (+ r byte:0) (+ (- r 10) byte:A)))
           (loop (- i 1) q))))))
  (define (make-number->utf8 notation)
    (let* ((notation  (notation-override number-notation.default notation))
           (iradix    (notation-ref notation '(implicit-radix)))
           (radix     (or (notation-ref notation '(radix)) iradix))
           (prefix    (begin (radix?! iradix) (radix?! radix)
                             (and (not (eqv? iradix radix))
                                  (case radix ((2) #"#b") ((8) #"#o") ((10) #"#d") (else #"#x")))))
           (fraction  (notation-ref notation '(fraction)))
           (exp-above (notation-ref notation '(exponent above)))
           (exp-below (notation-ref notation '(exponent below)))
           (exp-above (if (or (not exp-above) (nonnegative-integer? exp-above))
                          (and exp-above (not (eqv? fraction 'ratio)) (expt radix exp-above))
                          (mistake '(exponent above) "not #f or a nonnegative integer" exp-above)))
           (exp-below (if (or (not exp-below) (nonpositive-integer? exp-below))
                          (and exp-below (not (eqv? fraction 'ratio)) (expt radix exp-below))
                          (mistake '(exponent below) "not #f or a nonpositive integer" exp-below))))
      (define (integer->utf8 n)
        (cond ((< n 0) (let* ((len (+ (floor-log (- n) radix) 2)) (mbv (make-mbytevector len 0)))
                         (mbytevector-set! mbv 0 byte:-)
                         (set-nat-radix-digits! mbv 1 (- len 1) (- n) radix)
                         (mbytevector->bytevector mbv)))
              ((< 0 n) (let* ((len (+ (floor-log n radix) 1)) (mbv (make-mbytevector len 0)))
                         (set-nat-radix-digits! mbv 0 len n radix)
                         (mbytevector->bytevector mbv)))
              (else #"0")))
      (define (ratio->utf8 n) (bytevector-append (integer->utf8 (numerator n)) #"/"
                                                 (integer->utf8 (denominator n))))
      (define (repeat?->decimal->utf8 repeat?)
        (define non-repeating?
          (let ((check1 (lambda (a) (lambda (n) (= (integer-floor-mod (denominator n) a) 0))))
                (check2 (lambda (a b) (lambda (n) (let ((d (denominator n)))
                                                    (or (= (integer-floor-mod d a) 0)
                                                        (= (integer-floor-mod d b) 0)))))))
            (cond ((= (integer-floor-mod radix 2) 0)
                   (cond ((= (integer-floor-mod radix 3) 0) (check2 2 3))
                         ((= (integer-floor-mod radix 5) 0) (check2 2 5))
                         ((= (integer-floor-mod radix 7) 0) (check2 2 7))
                         (else                              (check1 2))))
                  ((= (integer-floor-mod radix 3) 0)
                   (if (= (integer-floor-mod radix 5) 0) (check2 3 5) (check1 3)))
                  (else (check1 radix)))))
        (define (rhs-digit-counts n)
          (let loop-non-repeating ((n n) (non-repeating-count 0))
            (cond ((= n 0) (values non-repeating-count 0))
                  ((non-repeating? n) (let* ((m (* n radix)) (n (- m (floor m))))
                                        (loop-non-repeating n (+ non-repeating-count 1))))
                  ((not repeat?) (values 1 1))  ; early abort
                  (else (let ((start n))
                          (let loop-repeating ((n n) (repeating-count 1))
                            (let* ((m (* n radix)) (n (- m (floor m))))
                              (if (= n start)
                                  (values non-repeating-count repeating-count)
                                  (loop-repeating n (+ repeating-count 1))))))))))
        (define (go n mag power)
          (let* ((mag   (/ mag (expt radix power)))
                 (whole (floor mag))
                 (part  (- mag whole)))
            (let-values (((non-repeating-count repeating-count) (rhs-digit-counts part)))
              (if (and (not repeat?) (< 0 repeating-count))
                  (ratio->utf8 n)
                  (let* ((part-len          (+ non-repeating-count repeating-count))
                         (part-len          (if (< 0 part-len) (+ part-len 1) 0))
                         (part-len          (if (< 0 repeating-count) (+ part-len 1) part-len))
                         (part              (* (expt radix non-repeating-count) part))
                         (non-repeating     (floor part))
                         (part              (- part non-repeating))
                         (repeating         (floor (* (expt radix repeating-count) part)))
                         (power-digit-count (if (= power 0) 0 (+ (floor-log (abs power) radix) 1)))
                         (whole-digit-count (if (= whole 0) 1 (+ (floor-log whole radix) 1)))
                         (len               (+ whole-digit-count part-len power-digit-count
                                               (if (< n 0) 1 0)
                                               (cond ((< power 0) 2) ((= power 0) 0) (else 1))))
                         (mbv               (make-mbytevector len 0)))
                    (let* ((i (if (< n 0)
                                  (begin (mbytevector-set! mbv 0 byte:-)
                                         1)
                                  0))
                           (i (begin (set-nat-radix-digits! mbv i whole-digit-count whole radix)
                                     (+ i whole-digit-count)))
                           (i (if (< 0 part-len)
                                  (begin
                                    (mbytevector-set! mbv i byte:.)
                                    (let* ((i (+ i 1))
                                           (i (begin (set-nat-radix-digits!
                                                       mbv i non-repeating-count non-repeating
                                                       radix)
                                                     (+ i non-repeating-count))))
                                      (if (< 0 repeating-count)
                                          (begin (mbytevector-set! mbv i byte:~)
                                                 (let ((i (+ i 1)))
                                                   (set-nat-radix-digits! mbv i repeating-count
                                                                          repeating
                                                                          radix)
                                                   (+ i repeating-count)))
                                          i)))
                                  i))
                           (i (if (< 0 power-digit-count)
                                  (begin (mbytevector-set! mbv i (if (<= radix 10) byte:e byte:p))
                                         (+ i 1))
                                  i))
                           (i (if (< power 0)
                                  (begin (mbytevector-set! mbv i byte:-)
                                         (+ i 1))
                                  i)))
                      (set-nat-radix-digits! mbv i power-digit-count power radix)
                      (mbytevector->bytevector mbv)))))))
        (lambda (n) (let ((mag (abs n)))
                      (cond ((and exp-below (< mag exp-below)) (go n mag (floor-log mag radix)))
                            ((and exp-above (< exp-above mag)) (go n mag (floor-log mag radix)))
                            (else                              (go n mag 0))))))
      (define fraction->utf8
        (case fraction
          ((ratio)          ratio->utf8)
          ((decimal)        (repeat?->decimal->utf8 #f))
          ((decimal/repeat) (repeat?->decimal->utf8 #t))
          (else (mistake 'fraction "not in (ratio decimal decimal/repeat)" fraction))))
      (lambda (n) (let ((text (if (or (not (integer? n)) (and exp-above (< exp-above (abs n))))
                                  (fraction->utf8 n)
                                  (integer->utf8 n))))
                    (if prefix (bytevector-append prefix text) text)))))
  (define (radix->number->utf8 radix) (make-number->utf8 '((implicit-radix . radix) (radix . #f))))
  (define number->utf8                (make-number->utf8 notation.empty))
  (define number->utf8/decimal        (make-number->utf8 '((fraction . decimal))))
  (define number->utf8/decimal/repeat (make-number->utf8 '((fraction . decimal/repeat))))
  (define (radix->utf8->number radix)
    (radix?! radix)
    (lambda (bv)
      (let ((len (bytevector-length bv)))
        (define (Radix radix i k)
          (and (< i len)
               (let ((b (bytevector-ref bv i)))
                 (if (= b byte:hash)
                     (let ((i (+ i 1)))
                       (and (< i len)
                            (let ((b (bytevector-ref bv i)))
                              (let ((i (+ i 1)))
                                (and (< i len)
                                     (let ((c (bytevector-ref bv i)))
                                       (cond
                                         ((or (= b byte:b) (= b byte:B)) (k 2 i c))
                                         ((or (= b byte:o) (= b byte:O)) (k 8 i c))
                                         ((or (= b byte:d) (= b byte:D)) (k 10 i c))
                                         ((or (= b byte:x) (= b byte:X)) (k 16 i c))
                                         (else #f))))))))
                     (k radix i b)))))
        (define (Sign i b k)
          (define (next sign)
            (let ((i (+ i 1)))
              (and (< i len) (k sign i (bytevector-ref bv i)))))
          (cond ((= b byte:-) (next -1))
                ((= b byte:+) (next  1))
                (else         (k 1 i b))))
        (define (RadixSign radix i k)
          (Radix radix i (lambda (radix i b) (Sign i b (lambda (sign i b)
                                                         (k radix sign i b))))))
        (define (Digit*1 radix i b k.more k.end)
          (let loop ((n 0) (digit-count 0) (i i) (b b))
            (let ((x (undigit16 b)))
              (if (< -1 x radix)
                  (let ((n (+ (* n radix) x)) (digit-count (+ digit-count 1)) (i (+ i 1)))
                    (if (< i len)
                        (loop n digit-count i (bytevector-ref bv i))
                        (k.end n digit-count)))
                  (k.more n digit-count i b)))))
        (define (Digit* radix i k.more k.end)
          (if (< i len)
              (Digit*1 radix i (bytevector-ref bv i) k.more k.end)
              (k.end 0 0)))
        (define (Exp n radix i b)
          (and (or (= b byte:e) (= b byte:E) (= b byte:p) (= b byte:P))
               (RadixSign radix (+ i 1)
                          (lambda (radix sign i b)
                            (Digit*1 radix i b
                                     (lambda (x digit-count i b) #f)
                                     (lambda (x digit-count)
                                       (and (< 0 digit-count)
                                            (* n (expt radix (* sign x))))))))))
        (RadixSign
          radix 0
          (lambda (radix sign i b)
            (define (decimal lhs lhs-digit-count rhs rhs-digit-count rep rep-digit-count)
              (and (or (< 0 lhs-digit-count) (< 0 rhs-digit-count) (< 0 rep-digit-count))
                   (let ((rhs (if (< 0 rep-digit-count)
                                  (+ rhs (/ rep (- (expt radix rep-digit-count) 1)))
                                  rhs)))
                     (* sign (+ lhs (/ rhs (expt radix rhs-digit-count)))))))
            (Digit*1
              radix i b
              (lambda (n digit-count i b)
                (if (= b byte:.)
                    (Digit*
                      radix (+ i 1)
                      (lambda (rhs rhs-digit-count i b)
                        (if (= b byte:~)
                            (Digit*
                              radix (+ i 1)
                              (lambda (repeating repeating-digit-count i b)
                                (and (< 0 repeating-digit-count)
                                     (let ((n (decimal n digit-count rhs rhs-digit-count
                                                       repeating
                                                       repeating-digit-count)))
                                       (and n (Exp n radix i b)))))
                              (lambda (repeating repeating-digit-count)
                                (and (< 0 repeating-digit-count)
                                     (decimal n digit-count rhs rhs-digit-count repeating
                                              repeating-digit-count))))
                            (let ((n (decimal n digit-count rhs rhs-digit-count 0 0)))
                              (and n (Exp n radix i b)))))
                      (lambda (rhs rhs-digit-count)
                        (decimal n digit-count rhs rhs-digit-count 0 0)))
                    (and (< 0 digit-count)
                         (if (= b byte:/)
                             (Digit* radix (+ i 1)
                                     (lambda (d digit-count i b) #f)
                                     (lambda (d digit-count)
                                       (and (< 0 digit-count)
                                            (* sign (/ n d)))))
                             (Exp (* sign n) radix i b)))))
              (lambda (n digit-count)
                (and (< 0 digit-count) (* sign n)))))))))
  (define (make-utf8->number notation)
    (radix->utf8->number
      (notation-ref (notation-override number-notation.default notation) '(implicit-radix))))
  (define utf8->number (make-utf8->number notation.empty))
  (define (make-notate notation)
    (let* ((notation            (notation-override notation.default notation))
           (abbreviate-prefix?  (notation-ref notation '(abbreviate-prefix?)))
           (abbreviate-pair?    (notation-ref notation '(abbreviate-pair?)))
           (bracket-index       (case (notation-ref notation '(bracket))
                                  ((40  #"(" "(" round)  0)
                                  ((91  #"[" "[" square) 1)
                                  ((123 #"{" "{" curly)  2)
                                  (=> (lambda (b) "not a bracket" b))))
           (length-prefix?      (notation-ref notation '(length-prefix?)))
           (bytevector-numeric? (notation-ref notation '(bytevector-numeric?)))
           (number-notation     (notation-ref notation '(number)))
           (n->utf8             (make-number->utf8 number-notation))
           (utf8->n             (make-utf8->number number-notation))
           (text.left-bracket   (vector-ref '#(#"(" #"[" #"{") bracket-index))
           (text.right-bracket  (vector-ref '#(#")" #"]" #"}") bracket-index))
           (text.special-lb     #"#<")
           (text.special-rb     #">")
           (text.null           (bytevector-append text.left-bracket text.right-bracket)))
      (lambda (x writer)
        (mlet ((buf.text (make-mbytevector 64 0)))
          (let notate/seen ((x x) (mv* '()))
            (define (notate x) (notate/seen x mv*))
            (define (atom          text) (writer-atom          writer text #f x))
            (define (prefix        text) (writer-prefix        writer text #f x))
            (define (dot)                (writer-dot           writer #"." #f))
            (define (left-bracket  text) (writer-left-bracket  writer text #f x))
            (define (right-bracket text) (writer-right-bracket writer text #f))
            (define notate-text
              (lambda (t.prefix byte:delim delim? bv len)
                (mlet ((pos.text 0))
                  (define (grow pos end)
                    (let ((len (mbytevector-length buf.text)))
                      (when (< len end) (let ((new (make-mbytevector (* len 2) 0)))
                                          (mbytevector-copy! new 0 buf.text 0 pos)
                                          (set! buf.text new)))))
                  (define (claim len) (let* ((pos pos.text) (end (+ pos len)))
                                        (grow pos end)
                                        (set! pos.text end)
                                        pos))
                  (let ((len.t.prefix (bytevector-length t.prefix)))
                    (claim (+ len.t.prefix 1))
                    (mbytevector-copy! buf.text 0 t.prefix 0 len.t.prefix))
                  (let loop ((i 0) (delim? delim?))
                    (define (slash-escape b)
                      (let ((j (claim 2)))
                        (mbytevector-set! buf.text j byte:backslash)
                        (mbytevector-set! buf.text (+ j 1) b)
                        (loop (+ i 1) #t)))
                    (define (code-escape width prefix c)
                      (let* ((dcount     (digit16-count c))
                             (len.prefix (bytevector-length prefix))
                             (j          (claim (+ dcount len.prefix 1))))
                        (mbytevector-copy! buf.text j prefix 0 len.prefix)
                        (mbytevector-set! buf.text (+ j dcount len.prefix) byte:semicolon)
                        (set-nat-radix-digits! buf.text (+ j len.prefix) dcount c 16)
                        (loop (+ i width) #t)))
                    (if (< i len)
                        (let* ((b0 (bytevector-ref bv i)) (kf (lambda _ (code-escape 1 #"\\x" b0))))
                          (utf8-decode-width/k
                            b0 kf
                            (lambda (width)
                              (utf8-ref/b0&width/k
                                bv i b0 width kf
                                (lambda (c)
                                  (cond ((eqv? c byte:bell)      (slash-escape byte:a))
                                        ((eqv? c byte:backspace) (slash-escape byte:b))
                                        ((eqv? c byte:tab)       (slash-escape byte:t))
                                        ((eqv? c byte:newline)   (slash-escape byte:n))
                                        ((eqv? c byte:vtab)      (slash-escape byte:v))
                                        ((eqv? c byte:feed)      (slash-escape byte:f))
                                        ((eqv? c byte:return)    (slash-escape byte:r))
                                        ((eqv? c byte:escape)    (slash-escape byte:e))
                                        ((eqv? c byte:backslash) (slash-escape byte:backslash))
                                        ((eqv? c byte:delim)     (slash-escape byte:delim))
                                        ((or (unicode-control? c) (unicode-vspace? c))
                                         (code-escape width #"\\u" c))
                                        (else (let ((j (claim width)))
                                                (mbytevector-copy! buf.text j bv i width))
                                              (loop (+ i width) (or delim? (unicode-hspace? c)
                                                                    (punctuation? c))))))))))
                        (atom (if delim?
                                  (let ((j (claim 1)) (len.t.prefix (bytevector-length t.prefix)))
                                    (mbytevector-set! buf.text len.t.prefix byte:delim)
                                    (mbytevector-set! buf.text j            byte:delim)
                                    (mbytevector->bytevector buf.text 0 pos.text))
                                  (mbytevector->bytevector buf.text 1 (- pos.text 1)))))))))
            (cond
              ((null? x)   (atom text.null))
              ((not x)     (atom #"#f"))
              ((eqv? x #t) (atom #"#t"))
              ((pair? x)   (let ((abbrev (and abbreviate-prefix?
                                              (symbol? (car x))
                                              (pair? (cdr x))
                                              (null? (cddr x))
                                              (case (car x)
                                                ((quote)             #"'")
                                                ((quasiquote)        #"`")
                                                ((unquote)           #",")
                                                ((unquote-splicing)  #",@")
                                                ((syntax)            #"#'")
                                                ((quasisyntax)       #"#`")
                                                ((unsyntax)          #"#,")
                                                ((unsyntax-splicing) #"#,@")
                                                (else                #f)))))
                             (if abbrev
                                 (begin (prefix abbrev) (notate (cadr x)))
                                 (begin (left-bracket text.left-bracket)
                                        (notate (car x))
                                        (if abbreviate-pair?
                                            (let loop ((x (cdr x)))
                                              (unless (null? x)
                                                (cond ((pair? x) (notate (car x)) (loop (cdr x)))
                                                      (else      (dot) (notate x)))))
                                            (begin (dot) (notate (cdr x))))
                                        (right-bracket text.right-bracket)))))
              ((vector? x)
               (let ((len (vector-length x)))
                 (left-bracket (bytevector-append #"#" (if length-prefix? (number->utf8 len) #"")
                                                  text.left-bracket))
                 (unless (= len 0)
                   (notate (vector-ref x 0))
                   (for-each (lambda (i) (notate (vector-ref x i)))
                             (range 1 (if (and (< 1 len) length-prefix?)
                                          (let ((last (vector-ref x (- len 1))))
                                            (let loop ((i (- len 2)))
                                              (if (equal? (vector-ref x i) last)
                                                  (if (< 0 i) (loop (- i 1)) 1)
                                                  (+ i 2))))
                                          len)))))
               (right-bracket text.right-bracket))
              ((bytevector? x)
               (let* ((len      (bytevector-length x))
                      (t.prefix (if length-prefix? (bytevector-append #"#" (number->utf8 len)) #"#"))
                      (len      (if (and (< 1 len) length-prefix?)
                                    (let ((last (bytevector-ref x (- len 1))))
                                      (let loop ((i (- len 2)))
                                        (if (equal? (bytevector-ref x i) last)
                                            (if (< 0 i) (loop (- i 1)) 1)
                                            (+ i 2))))
                                    len)))
                 (if bytevector-numeric?
                     (begin (left-bracket (bytevector-append t.prefix #"vu8" text.left-bracket))
                            (for-each (lambda (i) (notate (bytevector-ref x i))) (range len))
                            (right-bracket text.right-bracket))
                     (notate-text t.prefix byte:dquote #t x len))))
              ((string? x) (let ((bv (string->bytevector x)))
                             (notate-text #"" byte:dquote #t bv (bytevector-length bv))))
              ((symbol? x)
               (cond ((eqv? x '||) (atom #"||"))
                     ((eqv? x '|.|) (atom #"|.|"))
                     (else (let ((bv (symbol->bytevector x)))
                             (notate-text #"" byte:pipe (or (= (bytevector-ref bv 0) byte:@)
                                                            (utf8->n bv))
                                          bv (bytevector-length bv))))))
              ((number? x)      (atom (n->utf8 x)))
              ((mbytevector? x) (left-bracket text.special-lb)
                                (atom #"mbytevector")
                                (notate (mbytevector->bytevector x))
                                (right-bracket text.special-rb))
              ((mvector? x)     (left-bracket text.special-lb)
                                (atom #"mvector")
                                (let loop ((i 0) (parent* mv*))
                                  (cond ((null? parent*)        (notate/seen (mvector->vector x) (cons x mv*)))
                                        ((eqv? x (car parent*)) (atom (bytevector-append #"#" (number->utf8 i))))
                                        (else                   (loop (+ i 1) (cdr parent*)))))
                                (right-bracket text.special-rb))
              ((procedure? x)   (atom #"#<procedure>"))
              (else             (atom #"#<unknown>"))))))))
  (define (separator? c) (or (not c) (unicode-space? c) (unicode-control? c) (punctuation? c)))
  (define (make-denotate notation)
    (let ((utf8->n (make-utf8->number
                     (notation-ref (notation-override notation.default notation) '(number)))))
      (lambda (pos.abs port reader)
        (mlet ((buf (make-mbytevector 8192 0)) (pos.buf 0) (end.buf 0) (eof? #f) (pos.abs pos.abs))
          (define (buf-slice start count) (mbytevector->bytevector buf (+ pos.buf start) count))
          (define (buf-span count) (buf-slice 0 count))
          (define (buf-span+1 offset) (buf-span (+ offset 1)))
          (define (pos++ width) (let ((pos pos.abs))
                                  (set! pos.abs (+ pos width))
                                  (set! pos.buf (+ pos.buf width))
                                  pos))
          (define (rerror pos text desc x*)
            (reader-error reader pos text (if (null? x*) desc (cons desc x*))))
          (define (fail-local text desc . x*) (rerror pos.abs text desc x*))
          (define (fail offset text desc . x*) (rerror (pos++ (max 1 offset)) text desc x*))
          (define (unread-buffer) (iport-unread port buf pos.buf (- end.buf pos.buf)))
          (define (fill-buffer keof k)
            (define (copy! dst) (let ((count (- end.buf pos.buf)))
                                  (mbytevector-copy! dst 0 buf pos.buf count)
                                  (set! pos.buf 0)
                                  (set! end.buf count)))
            (define (go buf count avail)
              (iport-read/k port buf count avail raise-io-error keof
                            (lambda (amount) (set! end.buf (+ count amount)) (k))))
            (let* ((len.buf (mbytevector-length buf))
                   (count   (- end.buf pos.buf))
                   (avail   (- len.buf count)))
              (if (< avail 4096)
                  (let* ((len.buf (* len.buf 2))
                         (buf.new (make-mbytevector len.buf 0)))
                    (copy! buf.new)
                    (set! buf buf.new)
                    (go buf.new count (- len.buf count)))
                  (begin (copy! buf) (go buf count avail)))))
          (define (peek offset k)
            (define (kf . x*) (apply fail offset (buf-span+1 offset) x*) #f)
            (let loop ()
              (let ((i (+ pos.buf offset)))
                (cond ((< i end.buf)
                       (let ((b0 (mbytevector-ref buf i)))
                         (utf8-decode-width/k
                           b0 kf
                           (lambda (w)
                             (if (<= (+ i w) end.buf)
                                 (utf8-ref/b0&width/k buf i b0 w kf (lambda (c) (k c w)))
                                 (fill-buffer (lambda () (kf "EOF while decoding utf8")) loop))))))
                      (eof? (k #f 0))
                      (else (fill-buffer (lambda () (set! eof? #t) (k #f 0)) loop))))))
          (define (next-separator i k)
            (let loop ((i i)) (peek i (lambda (c w) (if (separator? c) (k i c) (loop (+ i w)))))))
          (define (next-separator-pos i k) (next-separator i (lambda (i c) (k i))))
          (define (seq i b* kt kf)
            (let loop ((i i) (b* b*))
              (if (null? b*) (kt) (peek i (lambda (c w)
                                            (if (eqv? c (car b*)) (loop (+ i w) (cdr b*)) (kf)))))))
          (define (seq-alt* i kf . b*k*)
            (let loop ((b*k* b*k*))
              (if (null? b*k*) (kf) (let ((b* (car b*k*)) (k (cadr b*k*)))
                                      (seq i b* k (lambda () (loop (cddr b*k*))))))))
          (define (atom size x) (let ((text (buf-span size)))
                                  (reader-atom reader (pos++ size) text x)))
          (define (comment size) (let ((text (buf-span size)))
                                   (reader-comment reader (pos++ size) text)))
          (define (lbrack size shape type len)
            (let ((text (buf-span size)))
              (reader-left-bracket reader (pos++ size) text shape type len)))
          (define (rbrack size shape)
            (let ((text (buf-span size))) (reader-right-bracket reader (pos++ size) text shape)))
          (define (prefix size type)
            (let ((text (buf-span size))) (reader-prefix reader (pos++ size) text type)))
          (define (nline i c) (reader-newline reader (+ pos.abs i) c))
          (define (Line c width) (reader-newline reader (pos++ width) c))
          (define (EOF pos) (reader-eof reader pos))
          (define (Space width) (pos++ width) (Any))
          (define (Dot) (peek 1 (lambda (c w)
                                  (if (separator? c)
                                      (let ((text (buf-span 1))) (reader-dot reader (pos++ 1) text))
                                      (Number^Symbol)))))
          (define (Comment:datum) (let ((text (buf-span 2)))
                                    (reader-datum-comment-prefix reader (pos++ 2) text)))
          (define (Comment:block)
            (let loop ((i 2) (level 0))
              (seq-alt*
                i (lambda ()
                    (peek i (lambda (c width)
                              (if c
                                  (and (or (not (unicode-vspace? c)) (nline i c))
                                       (loop (+ i width) level))
                                  (fail i (buf-span i) "EOF before end of block comment")))))
                (list byte:pipe byte:hash) (lambda ()
                                             (let ((i (+ i 2)))
                                               (if (< 0 level) (loop i (- level 1)) (comment i))))
                (list byte:hash byte:pipe) (lambda () (loop (+ i 2) (+ level 1))))))
          (define (Comment:line start)
            (let loop ((i start)) (peek i (lambda (c w) (if (or (not c) (unicode-vspace? c))
                                                            (comment i)
                                                            (loop (+ i w)))))))
          (define (Boolean x)
            (peek 2 (lambda (c w)
                      (if (separator? c) (atom 2 x) (fail 2 (buf-span 3)
                                                          "boolean followed by a non-separator")))))
          (define Text
            (mlet ((buf.text (make-mbytevector 64 0)))
              (lambda (i byte:delim return/k)
                (mlet ((pos.text 0) (fail? #f))
                  (define (grow pos end)
                    (let ((len (mbytevector-length buf.text)))
                      (when (< len end) (let ((new (make-mbytevector (* len 2) 0)))
                                          (mbytevector-copy! new 0 buf.text 0 pos)
                                          (set! buf.text new)))))
                  (define (push-byte b) (let* ((pos pos.text) (end (+ pos 1)))
                                          (grow pos end)
                                          (mbytevector-set! buf.text pos b)
                                          (set! pos.text end)))
                  (define (push c) (let* ((w (utf8-encode-width c)) (pos pos.text) (end (+ pos w)))
                                     (grow pos end)
                                     (utf8-set!/width buf.text pos c w)
                                     (set! pos.text end)))
                  (let loop ((i i))
                    (define (fail/next i . x*) (set! fail? #t) (and (apply fail-local x*) (loop i)))
                    (define (push/next next c) (push c) (loop next))
                    (define (push/skip skip c) (push/next (+ i skip) c))
                    (define (decode-escape i k)
                      (next-separator
                        i (lambda (i.sep c.sep)
                            (if (eqv? c.sep byte:semicolon)
                                (if (= i.sep i)
                                    (fail/next i.sep (buf-span+1 i.sep) "missing escape code")
                                    (let ((pos pos.buf))
                                      (let loop ((c 0) (i i))
                                        (if (< i i.sep)
                                            (let* ((b (mbytevector-ref buf (+ pos i)))
                                                   (x (undigit16 b)))
                                              (if (< -1 x 16)
                                                  (loop (+ (* c 16) x) (+ i 1))
                                                  (fail/next i (buf-span+1 i)
                                                             "not a base-16 digit")))
                                            (k (+ i.sep 1) c)))))
                                (fail/next i.sep (buf-span+1 i.sep)
                                           "not an escape code terminator")))))
                    (define (k.escape c w)
                      (cond ((unicode-vspace? c)     (and (nline (+ i 1) c) (loop (+ i 1 w))))
                            ((eqv? c byte:a)         (push/skip 2 byte:bell))
                            ((eqv? c byte:b)         (push/skip 2 byte:backspace))
                            ((eqv? c byte:t)         (push/skip 2 byte:tab))
                            ((eqv? c byte:n)         (push/skip 2 byte:newline))
                            ((eqv? c byte:v)         (push/skip 2 byte:vtab))
                            ((eqv? c byte:f)         (push/skip 2 byte:feed))
                            ((eqv? c byte:r)         (push/skip 2 byte:return))
                            ((eqv? c byte:e)         (push/skip 2 byte:escape))
                            ((eqv? c byte:dquote)    (push/skip 2 byte:dquote))
                            ((eqv? c byte:pipe)      (push/skip 2 byte:pipe))
                            ((eqv? c byte:backslash) (push/skip 2 byte:backslash))
                            ((eqv? c byte:u)
                             (decode-escape
                               (+ i 2) (lambda (next c)
                                         (if (unicode? c)
                                             (push/next next c)
                                             (fail/next next (buf-span next)
                                                        "escaped value is not a codepoint" c)))))
                            ((eqv? c byte:x)
                             (decode-escape
                               (+ i 2)
                               (lambda (next b)
                                 (if (<= 0 b 255)
                                     (begin (push-byte b) (loop next))
                                     (fail/next next (buf-span next)
                                                "escaped value is not a byte" b)))))
                            (else (fail/next (+ i 1) (buf-span (+ i 2))
                                             "invalid escape sequence"))))
                    (define (k.next c w)
                      (cond ((not c) (fail i (buf-span i) "EOF before text delimiter"))
                            ((eqv? c byte:backslash) (peek (+ i 1) k.escape))
                            ((eqv? c byte:delim)
                             (if fail?
                                 (fail (+ i 1) (buf-span (+ i 1)) "invalid text")
                                 (return/k (+ i 1) (mbytevector->bytevector buf.text 0 pos.text)
                                           (lambda (x) (atom (+ i 1) x)))))
                            (else (and (or (not (unicode-vspace? c)) (nline i c))
                                       (push/skip w c)))))
                    (peek i k.next))))))
          (define (Bytevector i len)
            (Text i byte:dquote
                  (if len
                      (lambda (next text k)
                        (let ((len.text (bytevector-length text)))
                          (cond ((< len len.text)
                                 (fail next (buf-span next) "bytevector longer than length-prefix"
                                       (cons 'length len.text) (cons 'length-prefix len)))
                                ((< len.text len)
                                 (if (< 0 len.text)
                                     (let* ((b.pad (bytevector-ref text (- len.text 1)))
                                            (mbv   (make-mbytevector len b.pad)))
                                       (mbytevector-copy! mbv 0 text 0 (- len.text 1))
                                       (k (mbytevector->bytevector mbv)))
                                     (fail next (buf-span next) "empty length-prefixed bytevector"
                                           len)))
                                (else (k text)))))
                      (lambda (next text k) (k text)))))
          (define (String)      (Text 1 byte:dquote (lambda (_ t k) (k (bytevector->string t)))))
          (define (Symbol/pipe) (Text 1 byte:pipe   (lambda (_ t k) (k (bytevector->symbol t)))))
          (define (Number^Symbol)
            (next-separator-pos 1 (lambda (i.sep)
                                    (let ((text (buf-span i.sep)))
                                      (if (eqv? (bytevector-ref text 0) byte:@)
                                          (fail i.sep text "symbol cannot begin with @")
                                          (atom i.sep (or (utf8->n text) (bytevector->symbol text))))))))
          (define (Number)
            (next-separator-pos 2 (lambda (i.sep)
                                    (let* ((text (buf-span i.sep)) (n (utf8->n text)))
                                      (if n (atom i.sep n) (fail i.sep text "not a numeral"))))))
          (define (Length-prefix len)
            (let loop ((i 2) (len len))
              (peek i (lambda (c width)
                        (let ((j (+ i width)) (n (undigit10 c)))
                          (cond (n                     (loop j (+ (* len 10) n)))
                                ((eqv? c byte:dquote)  (Bytevector j len))
                                ((eqv? c byte:lparen)  (lbrack j 'round  'vector len))
                                ((eqv? c byte:lsquare) (lbrack j 'square 'vector len))
                                ((eqv? c byte:lcurly)  (lbrack j 'curly  'vector len))
                                (else (seq-alt*
                                        i (lambda () (fail i (buf-span+1 i)
                                                           "misplaced length-prefix"))
                                        (list byte:v byte:u byte:8 byte:lparen)
                                        (lambda () (lbrack (+ i 4) 'round  'bytevector len))
                                        (list byte:v byte:u byte:8 byte:lsquare)
                                        (lambda () (lbrack (+ i 4) 'square 'bytevector len))
                                        (list byte:v byte:u byte:8 byte:lcurly)
                                        (lambda () (lbrack (+ i 4) 'curly  'bytevector len))))))))))
          (define (Here-bytevector)
            (let loop ((i 2))
              (peek i (lambda (c width)
                        (cond ((not c) (fail i (buf-span i) "EOF before start of here-bytevector"))
                              ((eqv? c byte:dquote)
                               (let ((delim-length (- i 1))
                                     (delim-text (bytevector-append (buf-slice 2 (- i 2)) #"#")))
                                 (let loop ((i (+ i 1)))
                                   (peek i (lambda (c width)
                                             (cond ((not c) (fail i (buf-span i) "EOF before end of here-bytevector"))
                                                   ((eqv? c byte:dquote)
                                                    (peek (+ i delim-length 1)
                                                          (lambda (c width)
                                                            (if (and c (eqv? c byte:hash)
                                                                     (eqv? (buf-slice (+ i 1) delim-length) delim-text))
                                                                (atom (+ i delim-length 2)
                                                                      (let ((value-start (+ delim-length 2)))
                                                                        (buf-slice value-start (- i value-start))))
                                                                (loop (+ i 1))))))
                                                   (else (and (or (not (unicode-vspace? c)) (nline i c))
                                                              (loop (+ i width))))))))))
                              ((separator? c) (fail i (buf-span i) "separator before start of here-bytevector"))
                              (else (loop (+ i width))))))))
          (define (Hash)
            (peek 1 (lambda (c _)
                      (cond ((memv c (list byte:F byte:f)) (Boolean #f))
                            ((memv c (list byte:T byte:t)) (Boolean #t))
                            ((eqv? c byte:lparen)    (lbrack 2 'round  'vector #f))
                            ((eqv? c byte:lsquare)   (lbrack 2 'square 'vector #f))
                            ((eqv? c byte:lcurly)    (lbrack 2 'curly  'vector #f))
                            ((eqv? c byte:dquote)    (Bytevector 2 #f))
                            ((eqv? c byte:semicolon) (Comment:datum))
                            ((eqv? c byte:pipe)      (Comment:block))
                            ((eqv? c byte:quote)     (prefix 2 'syntax))
                            ((eqv? c byte:backtick)  (prefix 2 'quasisyntax))
                            ((eqv? c byte:comma)     (peek 2 (lambda (c w)
                                                               (if (eqv? c byte:@)
                                                                   (prefix 3 'unsyntax-splicing)
                                                                   (prefix 2 'unsyntax)))))
                            ((eqv? c byte:hash)      (Here-bytevector))
                            ((memv c (list byte:B byte:D byte:O byte:X
                                           byte:b byte:d byte:o byte:x)) (Number))
                            ((undigit10 c) => Length-prefix)
                            (else (seq-alt* 1 (lambda () (fail 1 (buf-span+1 1) "invalid #"))
                                            (list byte:v byte:u byte:8 byte:lparen)
                                            (lambda () (lbrack 5 'round  'bytevector #f))
                                            (list byte:v byte:u byte:8 byte:lsquare)
                                            (lambda () (lbrack 5 'square 'bytevector #f))
                                            (list byte:v byte:u byte:8 byte:lcurly)
                                            (lambda () (lbrack 5 'curly  'bytevector #f))
                                            (list byte:! byte:e byte:o byte:f)
                                            (lambda () (EOF (pos++ 5)))
                                            (list byte:! byte:space)
                                            (lambda () (Comment:line 3))
                                            (list byte:! byte:/)
                                            (lambda () (Comment:line 3))))))))
          (define (Any)
            (peek 0 (lambda (c width)
                      (cond ((not c)                 (EOF pos.abs))
                            ((unicode-vspace? c)     (Line c width))
                            ((unicode-hspace? c)     (Space width))
                            ((eqv? c byte:lparen)    (lbrack 1 'round  'list #f))
                            ((eqv? c byte:lsquare)   (lbrack 1 'square 'list #f))
                            ((eqv? c byte:lcurly)    (lbrack 1 'curly  'list #f))
                            ((eqv? c byte:rparen)    (rbrack 1 'round))
                            ((eqv? c byte:rsquare)   (rbrack 1 'square))
                            ((eqv? c byte:rcurly)    (rbrack 1 'curly))
                            ((eqv? c byte:dquote)    (String))
                            ((eqv? c byte:pipe)      (Symbol/pipe))
                            ((eqv? c byte:hash)      (Hash))
                            ((eqv? c byte:.)         (Dot))
                            ((eqv? c byte:semicolon) (Comment:line 1))
                            ((eqv? c byte:quote)     (prefix 1 'quote))
                            ((eqv? c byte:backtick)  (prefix 1 'quasiquote))
                            ((eqv? c byte:comma)     (peek 1 (lambda (c w)
                                                               (if (eqv? c byte:@)
                                                                   (prefix 2 'unquote-splicing)
                                                                   (prefix 1 'unquote)))))
                            ((unicode-control? c)    (fail 0 (buf-span+1 0)
                                                           "misplaced control codepoint" c))
                            (else                    (Number^Symbol))))))
          (let loop () (if (Any) (loop) (unread-buffer)))
          pos.abs)))))
(define notate   (make-notate   notation.empty))
(define denotate (make-denotate notation.empty))

(define ((read/reader:data/k r:data) port kf keof k)
  (mlet ((return #f))
    (denotate 0 port (r:data (lambda (err) (set! return (lambda () (kf err))) #f)
                             (lambda ()    (set! return keof)                 #f)
                             (lambda (x)   (set! return (lambda () (k x)))    #f)))
    (return)))
(define ((read*/reader:data/k r:data) port kf k)
  (mlet ((x* '()))
    (mlet ((return (lambda () (k (reverse x*)))))
      (denotate 0 port (r:data (lambda (err) (set! return (lambda () (kf err))) #f)
                               (lambda ()                                       #f)
                               (lambda (x)   (set! x* (cons x x*))              #t)))
      (return))))
(define (((reader:data-track-line/start line-start) reader:data) . y*)
  ((reader-track-line/start 0) (apply reader:data y*)))

(define (make-number->string   notation) (let ((n->utf8 (make-number->utf8 notation)))
                                           (lambda (n) (bytevector->string (n->utf8 n)))))
(define (radix->number->string r)        (let ((n->utf8 (radix->number->utf8 r)))
                                           (lambda (n) (bytevector->string (n->utf8 n)))))
(define (number->string                n) (bytevector->string (number->utf8                n)))
(define (number->string/decimal        n) (bytevector->string (number->utf8/decimal        n)))
(define (number->string/decimal/repeat n) (bytevector->string (number->utf8/decimal/repeat n)))

(define (make-string->number   notation) (let ((utf8->n (make-utf8->number notation)))
                                           (lambda (s) (utf8->n (string->bytevector s)))))
(define (radix->string->number r)        (let ((utf8->n (radix->utf8->number r)))
                                           (lambda (s) (utf8->n (string->bytevector s)))))
(define (string->number s)               (utf8->number (string->bytevector s)))

(define (string-append* x*) (bytevector->string (bytevector-append* (map string->bytevector x*))))
(define (string-append . x*) (string-append* x*))
(define (string-join* separator x*)
  (bytevector->string (bytevector-join* (string->bytevector separator) (map string->bytevector x*))))
(define (string-join separator . x*) (string-join* separator x*))

(define (text? x) (or (bytevector? x) (string? x) (symbol? x)))
(define (text->bytevector x)
  (cond ((bytevector? x) x)
        ((string?     x) (string->bytevector x))
        ((symbol?     x) (symbol->bytevector x))
        (else            (mistake 'text->bytevector "not a symbol, string, or bytevector" x))))

(define (make-local-gensym)
  (mlet ((count -1))
    (lambda (name)
      (set! count (+ count 1))
      (let ((name (if (text? name)
                      (text->bytevector name)
                      (mistake 'gensym "not a symbol, string, or bytevector" name))))
        (string->symbol (bytevector->string (bytevector-append name #"." (number->utf8 count))))))))
