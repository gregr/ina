(define (caar  x) (car (car  x)))
(define (cadr  x) (car (cdr  x)))
(define (cdar  x) (cdr (car  x)))
(define (cddr  x) (cdr (cdr  x)))
(define (caaar x) (car (caar x)))
(define (caadr x) (car (cadr x)))
(define (cadar x) (car (cdar x)))
(define (caddr x) (car (cddr x)))
(define (cdaar x) (cdr (caar x)))
(define (cdadr x) (cdr (cadr x)))
(define (cddar x) (cdr (cdar x)))
(define (cdddr x) (cdr (cddr x)))

(define (list . x*)   x*)

(splicing-local
  ((define (append2 x* y)
     (define (fail) (mistake 'append "not a proper list" x*))
     (let loop ((x* x*))
       (cond ((pair? x*) (cons (car x*) (loop (cdr x*))))
             ((null? x*) y)
             (else       (fail))))))
  (define (append* x**)
    (if (null? x**)
        '()
        (let loop ((x* (car x**)) (x** (cdr x**)))
          (if (null? x**)
              x*
              (append2 x* (loop (car x**) (cdr x**)))))))
  (define (append . x**) (append* x**)))

(define (improper-list->list x*)
  (cond ((null? x*) '())
        ((pair? x*) (cons (car x*) (improper-list->list (cdr x*))))
        (else       (list x*))))

(define (improper-list-map f x*)
  (let loop ((x* x*))
    (cond ((null? x*) '())
          ((pair? x*) (cons (f (car x*)) (loop (cdr x*))))
          (else       (f x*)))))

(define (memp ? x*)
  (let loop ((x* x*))
    (and (not (null? x*))
         (cond ((? (car x*)) x*)
               (else         (loop (cdr x*)))))))
(define ((mem/= =?) y x*) (memp (lambda (x) (=? x y)) x*))
(define memv   (mem/= eqv?))
(define member (mem/= equal?))

(define (pmemp ? x*)
  (let loop ((x* x*))
    (and (not (null? x*))
         (cond ((? (car x*)) x*)
               (else         (loop (cddr x*)))))))
(define ((pmem/= =?) y x*) (pmemp (lambda (x) (=? x y)) x*))
(define pmemv   (pmem/= eqv?))
(define pmember (pmem/= equal?))

(define (rem1p ? x*)
  (let loop ((x* x*))
    (cond ((null? x*)   '())
          ((? (car x*)) (cdr x*))
          (else         (cons (car x*) (loop (cdr x*)))))))
(define ((rem/= =?) y x*) (rem1p (lambda (x) (=? x y)) x*))
(define remv1   (rem/= eqv?))
(define remove1 (rem/= equal?))

(define (assp ? alist)
  (let loop ((alist alist))
    (and (not (null? alist))
         (let ((kv (car alist)))
           (cond ((? (car kv)) kv)
                 (else         (loop (cdr alist))))))))
(define ((assoc/= =?) key alist) (assp (lambda (k) (=? k key)) alist))
(define assv  (assoc/= eqv?))
(define assoc (assoc/= equal?))

(define (plist->alist    p)   (cond ((null? p) '())
                                    ((pair? p) (cons (cons (car p) (cadr p))
                                                     (plist->alist (cddr p))))
                                    (else (mistake 'plist->alist "not a property list" p))))
(define (plist-key*      p)   (if (null? p) '() (cons (car  p) (plist-key*   (cddr p)))))
(define (plist-value*    p)   (if (null? p) '() (cons (cadr p) (plist-value* (cddr p)))))
(define (plist-map       p f) (alist-map (plist->alist p) f))
(define (plist-map-value p f) (alist->plist (alist-map-value (plist->alist p) f)))

(define (alist->plist a) (cond ((null? a) '())
                               ((pair? a) (let ((kv (car a)))
                                            (cons (car kv) (cons (cdr kv) (alist->plist (cdr a))))))
                               (else (mistake 'alist->plist "not an association list" a))))

(define (atree-merge a b merge)
  (let loop ((a a) (b b))
    (cond ((pair? a) (if (null? b)
                         a
                         (append
                           (map (lambda (kv.b)
                                  (let* ((key (car kv.b)) (value (cdr kv.b)) (kv.a (assoc key a)))
                                    (if kv.a (cons key (loop (cdr kv.a) value)) kv.b)))
                                b)
                           (filter (lambda (kv) (not (assoc (car kv) b))) a))))
          ((null? a) b)
          (else      (merge a b)))))
(define (atree-replace a b) (atree-merge a b (lambda (_ b) b)))
(define (atree-ref*/k a* key* kf k)
  (let loop-a* ((a* a*))
    (if (null? a*)
        (kf)
        (let loop-key* ((a (car a*)) (key* key*))
          (if (null? key*)
              (k a)
              (let ((kv (assoc (car key*) a)))
                (if kv (loop-key* (cdr kv) (cdr key*)) (loop-a* (cdr a*)))))))))
(define (atree-ref*/default a* key* default) (atree-ref*/k a* key* (lambda () default) (lambda (v) v)))
(define (atree-ref*         a* key*)
  (atree-ref*/k a* key* (lambda () (mistake 'atree-ref* "missing key*" key*)) (lambda (v) v)))
(define (atree-ref/k a key* kf k) (atree-ref*/k (list a) key* kf k))
(define (atree-ref/default a key* default) (atree-ref/k a key* (lambda () default) (lambda (v) v)))
(define (atree-ref         a key*)
  (atree-ref/k a key* (lambda () (mistake 'atree-ref "missing key*" key*)) (lambda (v) v)))
(define (atree-update/default a key* update default)
  (if (null? key*)
      (update a)
      (let loop ((a a) (key (car key*)) (key* (cdr key*)))
        (if (null? key*)
            (alist-update/default a key update default)
            (alist-update/default a key (lambda (a) (loop a (car key*) (cdr key*))) '())))))
(define (atree-set a key* value) (atree-update/default a key* (lambda (v) value) #t))

(define (alist-ref/k       a key kf k)    (atree-ref/k a (list key) kf k))
(define (alist-ref/default a key default) (alist-ref/k a key (lambda () default) (lambda (v) v)))
(define (alist-ref         a key)
  (alist-ref/k a key (lambda () (mistake 'alist-ref "missing key" key)) (lambda (v) v)))
(define (alist-modify/k a key modify kf k)
  (let loop ((i 0) (kv* a))
    (if (null? kv*)
        (kf)
        (let ((kv (car kv*)))
          (if (eqv? (car kv) key)
              (k (let loop ((i i) (a a))
                   (if (< 0 i)
                       (cons (car a) (loop (- i 1) (cdr a)))
                       (modify a))))
              (loop (+ i 1) (cdr kv*)))))))
(define (alist-update/k a key update kf k)
  (alist-modify/k a key (lambda (a) (cons (cons key (update (cdar a))) (cdr a))) kf k))
(define (alist-update/default a key update default)
  (alist-update/k a key update (lambda () (cons (cons key (update default)) a)) (lambda (a) a)))
(define (alist-update a key update)
  (alist-update/k a key update (lambda () (mistake 'alist-update "missing key" key)) (lambda (a) a)))
(define (alist-remove a key)       (alist-modify/k a key cdr (lambda () a) (lambda (a) a)))
(define (alist-set    a key value) (alist-modify/k a key
                                                   (lambda (a) (cons (cons key value) (cdr a)))
                                                   (lambda ()  (cons (cons key value) a))
                                                   (lambda (a) a)))
(define (alist-for-each  a f) (for-each (lambda (kv) (f (car kv) (cdr kv))) a))
(define (alist-map       a f) (map (lambda (kv) (f (car kv) (cdr kv))) a))
(define (alist-map-value a f) (alist-map a (lambda (k v) (cons k (f v)))))

(define range
  (let ((go (lambda (start end inc)
              (let ((? (if (< inc 0) > <)))
                (let loop ((i start)) (if (? i end) (cons i (loop (+ i inc))) '()))))))
    (case-lambda
      ((end)           (go 0 end 1))
      ((start end)     (go start end 1))
      ((start end inc) (go start end inc)))))

(define (list? x) (or (null? x) (and (pair? x) (list? (cdr x)))))

(define (length x*)
  (let loop ((x* x*) (l 0))
    (cond ((null? x*) l)
          (else (loop (cdr x*) (+ l 1))))))

(define (list-tail x* i)
  (nonnegative-integer?! i)
  (let loop ((x* x*) (i i))
    (cond ((= i 0) x*)
          (else    (loop (cdr x*) (- i 1))))))

(define (list-ref x* i) (car (list-tail x* i)))

(define (take n x*)
  (if (and (< 0 n) (pair? x*))
      (cons (car x*) (take (- n 1) (cdr x*)))
      '()))
(define (drop n x*) (if (and (< 0 n) (pair? x*)) (drop (- n 1) (cdr x*)) x*))
(define (take-drop n x*)
  (let loop ((n n) (x* x*) (rx* '()))
    (if (and (< 0 n) (pair? x*))
        (loop (- n 1) (cdr x*) (cons (car x*) rx*))
        (values (reverse rx*) x*))))

(define (cons* x . x*)
  (let loop ((x x) (x* x*))
    (cond ((null? x*) x)
          (else       (cons x (loop (car x*) (cdr x*)))))))

(define (reverse x*)
  (let loop ((x* x*) (acc '()))
    (cond ((null? x*) acc)
          (else       (loop (cdr x*) (cons (car x*) acc))))))

(define (filter ? x*)
  (let loop ((x* x*))
    (cond ((null? x*)   '())
          ((? (car x*)) (cons (car x*) (loop (cdr x*))))
          (else         (loop (cdr x*))))))

(splicing-local
  ((define (map1 f x*)
     (let loop ((x* x*))
       (cond ((null? x*) '())
             (else       (cons (f (car x*)) (loop (cdr x*)))))))
   (define (andmap1 f x*)
     (or (null? x*)
         (let loop ((x (car x*)) (x* (cdr x*)))
           (cond ((null? x*) (f x))
                 (else       (and (f x) (loop (car x*) (cdr x*))))))))
   (define (length=?! where x* y**)
     (let ((len (length x*)))
       (unless (andmap1 (lambda (y*) (= (length y*) len)) y**)
         (mistake where "lists differ in length" 'lengths (cons len (map1 length y**))
                  'lists (cons x* y**))))))

  (define map
    (case-lambda
      ((f x*)       (map1 f x*))
      ((f x* . y**) (length=?! 'map x* y**)
                    (let loop ((x* x*) (y** y**))
                      (cond ((null? x*) '())
                            (else (cons (apply f (car x*) (map1 car y**))
                                        (loop (cdr x*) (map1 cdr y**)))))))))

  (define for-each
    (case-lambda
      ((f x*)       (let loop ((x* x*)) (unless (null? x*) (f (car x*)) (loop (cdr x*)))))
      ((f x* . y**) (length=?! 'for-each x* y**)
                    (let loop ((x* x*) (y** y**))
                      (unless (null? x*)
                        (apply f (car x*) (map1 car y**))
                        (loop (cdr x*) (map1 cdr y**)))))))

  (define andmap
    (case-lambda
      ((f x*)       (andmap1 f x*))
      ((f x* . y**) (length=?! 'andmap x* y**)
                    (or (null? x*)
                        (let loop ((x (car x*)) (x* (cdr x*)) (y** y**))
                          (cond ((null? x*) (apply f x (map1 car y**)))
                                (else (and (apply f x (map1 car y**))
                                           (loop (car x*) (cdr x*) (map1 cdr y**))))))))))

  (define ormap
    (case-lambda
      ((f x*)       (and (not (null? x*))
                         (let loop ((x (car x*)) (x* (cdr x*)))
                           (cond ((null? x*) (f x))
                                 (else (or (f x) (loop (car x*) (cdr x*))))))))
      ((f x* . y**) (length=?! 'ormap x* y**)
                    (and (not (null? x*))
                         (let loop ((x (car x*)) (x* (cdr x*)) (y** y**))
                           (cond ((null? x*) (apply f x (map1 car y**)))
                                 (else (or (apply f x (map1 car y**))
                                           (loop (car x*) (cdr x*) (map1 cdr y**))))))))))

  (define (foldl f acc x*)
    (let loop ((x* x*) (acc acc))
      (cond ((null? x*) acc)
            (else       (loop (cdr x*) (f (car x*) acc))))))

  (define (foldr f acc x*)
    (let loop ((x* x*))
      (cond ((null? x*) acc)
            (else       (f (car x*) (loop (cdr x*)))))))

  (define fold-left
    (case-lambda
      ((f acc x*)       (let loop ((x* x*) (acc acc))
                          (if (null? x*) acc (loop (cdr x*) (f acc (car x*))))))
      ((f acc x* . y**) (let ((len (length x*)))
                          (unless (andmap1 (lambda (y*) (= (length y*) len)) y**)
                            (mistake "lists of different length" (cons (length x*) (map1 length y**)))))
                        (let loop ((x* x*) (y** y**) (acc acc))
                          (cond ((null? x*) acc)
                                (else       (loop (cdr x*) (map1 cdr y**)
                                                  (apply f acc (car x*) (map1 car y**)))))))))

  (define fold-right
    (case-lambda
      ((f acc x*)       (let loop ((x* x*))
                          (if (null? x*) acc (f (loop (cdr x*)) (car x*)))))
      ((f acc x* . y**) (let ((len (length x*)))
                          (unless (andmap1 (lambda (y*) (= (length y*) len)) y**)
                            (mistake "lists of different length" (cons (length x*) (map1 length y**)))))
                        (let loop ((x* x*) (y** y**))
                          (cond ((null? x*) acc)
                                (else (apply f (loop (cdr x*) (map1 cdr y**)) (car x*) (map1 car y**))))))))
  )
