;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Syntax with lazy mark propagation ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define current-mark-level (make-parameter 0))

(splicing-local
  ((define rtd.mark    (make-rtd 'mark 1 #f 'mark))
   (define make-mark   (rtd-constructor rtd.mark))
   (define mark?       (rtd-predicate   rtd.mark))
   (define access-mark (rtd-accessor    rtd.mark))
   (define (fresh-mark) (make-mark (current-mark-level)))
   (define (mark-level m) (access-mark m 0))
   (define mark=? eqv?)
   (define (mark*=? a* b*)
     (let loop ((a* a*) (b* b*))
       (if (pair? a*)
           (and (pair? b*)
                (mark=? (car a*) (car b*))
                (loop (cdr a*) (cdr b*)))
           (null? b*))))
   (define (mark*-append m*.outer m*.inner)
     (cond ((null? m*.inner) m*.outer)
           ((null? m*.outer) m*.inner)
           (else (let loop ((m*.outer (reverse m*.outer)) (m*.inner m*.inner))
                   (if (mark=? (car m*.outer) (car m*.inner))
                       (let ((m*.outer (cdr m*.outer)) (m*.inner (cdr m*.inner)))
                         (cond ((null? m*.outer) m*.inner)
                               ((null? m*.inner) (reverse m*.outer))
                               (else             (loop m*.outer m*.inner))))
                       (cons (car m*.outer)
                             (let loop ((m*.outer (cdr m*.outer)) (m* m*.inner))
                               (if (null? m*.outer)
                                   m*
                                   (loop (cdr m*.outer) (cons (car m*.outer) m*))))))))))
   (define (syntax-represent s)
     (let* ((repr        (list (list 'datum (syntax->datum s))))
            (note        (syntax-note s))
            (repr        (if (null? note) repr (cons (list 'note note) repr)))
            (mark-length (length (syntax-mark* s))))
       (cons 'syntax (if (< 0 mark-length) (cons (list 'marks mark-length) repr) repr))))
   (define rtd.annotated    (make-rtd 'syntax:annotated 2 #f syntax-represent))
   (define make-annotated   (rtd-constructor rtd.annotated))
   (define annotated?       (rtd-predicate   rtd.annotated))
   (define access-annotated (rtd-accessor    rtd.annotated))
   (define (annotated form note) (if (null? note) form (make-annotated form note)))
   (define (annotated-form s) (if (annotated? s) (access-annotated s 0) s))
   (define (annotated-note s) (if (annotated? s) (access-annotated s 1) '()))
   (define rtd.marked    (make-rtd 'syntax:marked 2 #f syntax-represent))
   (define make-marked   (rtd-constructor rtd.marked))
   (define marked?       (rtd-predicate   rtd.marked))
   (define access-marked (rtd-accessor    rtd.marked))
   (define (marked mark* form) (if (null? mark*) form (make-marked mark* form)))
   (define (marked-form  s) (access-marked s 1))
   (define (syntax-form  s) (annotated-form (if (marked? s) (marked-form s) s)))
   (define (syntax-mark* s) (if (marked? s) (access-marked s 0) '()))
   (define (syntax-wrap s m*)
     (if (marked? s)
         (marked (mark*-append m* (syntax-mark* s)) (marked-form s))
         (let ((form (annotated-form s)))
           (if (or (pair? form) (vector? form) (symbol? form)) (marked m* s) s))))
   (define (syntax-add-mark s m) (syntax-wrap s (list m)))
   (define (identifier-remove-mark id m)
     (identifier?! id)
     (let ((m* (syntax-mark* id)))
       (and (pair? m*) (mark=? (car m*) m) (marked (cdr m*) (marked-form id))))))

  (define (syntax-note     s)      (annotated-note (if (marked? s) (marked-form s) s)))
  (define (syntax-note-set s note) (marked (syntax-mark* s) (annotated (syntax-form s) note)))
  (define (syntax-note-add s note) (syntax-note-set s (atree-replace (syntax-note s) note)))

  (define (syntax-unwrap s)
    (if (marked? s)
        (let ((d (syntax-form s)) (m* (syntax-mark* s)))
          (define (wrap x) (syntax-wrap x m*))
          (cond ((pair?   d) (cons (wrap (car d)) (wrap (cdr d))))
                ((vector? d) (vector-map wrap d))
                (else        d)))
        (annotated-form s)))

  (define (syntax-prune-level s level)
    (let prune ((s s))
      (let loop ((m* (syntax-mark* s)))
        (if (null? m*)
            (annotated (let ((d (syntax-form s)))
                         (cond ((pair?   d) (cons (prune (car d)) (prune (cdr d))))
                               ((vector? d) (vector-map prune d))
                               (else        d)))
                       (syntax-note s))
            (let ((m (car m*)))
              (if (<= level (mark-level m))
                  (loop (cdr m*))
                  (marked m* (marked-form s))))))))

  (define (datum->syntax context datum)
    (identifier?! context)
    (if (marked? context)
        (syntax-wrap datum (syntax-mark* context))
        datum))

  (define (syntax->datum s)
    (let loop ((s s))
      (let ((x (syntax-form s)))
        (cond ((pair?   x) (cons (loop (car x)) (loop (cdr x))))
              ((vector? x) (vector-map loop x))
              (else        x)))))

  (define (identifier?  s) (symbol? (syntax-form s)))
  (define (identifier?! s) (unless (identifier? s) (mistake "not an identifier" s)))
  (define (identifier=? a b)
    (identifier?! a) (identifier?! b)
    (and (eqv? (syntax-form a) (syntax-form b))
         (mark*=? (syntax-mark* a) (syntax-mark* b))))

  ;;;;;;;;;;;;;;;;;;;;
  ;;; Environments ;;;
  ;;;;;;;;;;;;;;;;;;;;
  ;; NOTE: lookup is currently O(n), but may not be a problem in practice.  Consider more efficient
  ;; dictionary data structures if we need to harden this.
  (splicing-local
    ((define (alist-ref    kv* k)   (let ((kv (assv k kv*))) (and kv (cdr kv))))
     (define (alist-set    kv* k v) (cons (cons k v) (alist-remove kv* k)))
     (define (alist-remove kv* k)
       (let ((kv (assv k kv*)))
         (if kv
             (let loop ((kv* kv*))
               (cond ((eqv? (car kv*) kv) (cdr kv*))  ; assumes mark=? is eqv?
                     (else                (cons (car kv*) (loop (cdr kv*))))))
             kv*)))
     (define trie.empty '(() . ()))  ; trie : `(,sym=>x . ,mark=>trie)
     (define (trie-ref t m* sym)
       (let loop ((t t) (m* m*))
         (if (null? m*)
             (alist-ref (car t) sym)
             (let ((t.next (alist-ref (cdr t) (car m*))))
               (and t.next (loop t.next (cdr m*)))))))
     (define (trie-set t m* sym x)
       (let loop ((t t) (m* m*))
         (if (null? m*)
             (cons (alist-set (car t) sym x) (cdr t))
             (cons (car t)
                   (alist-set (cdr t) (car m*)  ; requires mark=? assumption in alist-remove
                              (loop (or (alist-ref (cdr t) (car m*)) trie.empty) (cdr m*)))))))
     (define id-dict.empty trie.empty)
     (define (id-dict-key* id=>x)
       (let loop ((t id=>x))
         (append (map car (car t))
                 (append* (map (lambda (kv)
                                 (let ((m (car kv)))
                                   (map (lambda (id) (syntax-add-mark id m))
                                        (map loop (cdr kv)))))
                               (cdr t))))))
     (define (id-dict-ref id=>x id)
       (identifier?! id)
       (trie-ref id=>x (syntax-mark* id) (syntax-form id)))
     (define (id-dict-set id=>x id x)
       (identifier?! id)
       (trie-set id=>x (syntax-mark* id) (syntax-form id) x))
     (define (env:mdict id=>x)
       (mlet ((id=>x id=>x) (frozen? #f))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k) (let ((x (id-dict-ref id=>x id))) (if x (k x) (kf)))))
             ((bind!/k)    (lambda (id x kf k)
                             (when frozen? (mistake "cannot bind!/k read-only environment" id))
                             (let ((x.existing (and kf (id-dict-ref id=>x id))))
                               (if x.existing
                                   (kf x.existing)
                                   (begin (set! id=>x (id-dict-set id=>x id x)) (k))))))
             ((read-only!) (set! frozen? id=>x))
             ((read-only)  (if frozen? self (let ((env (env:mdict id=>x)))
                                              (env-read-only! env)
                                              env)))
             ((frozen?)    frozen?)
             ((writable)   (and (not frozen?) self))
             ((describe)   (id-dict-key* id=>x))
             (else         (mistake "invalid environment operation" method))))
         self)))
    (define env.empty
      (lambda (method)
        (case method
          ((ref/k)      (lambda (id kf k) (kf)))
          ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k read-only environment" id)))
          ((read-only!) (values))
          ((read-only)  env.empty)
          ((frozen?)    id-dict.empty)
          ((writable)   #f)
          ((describe)   '())
          (else         (mistake "invalid environment operation" method)))))
    (define (make-env) (env:mdict id-dict.empty))
    ;; TODO: could combine adjacent frozen sub-dictionaries.  This will be rare in practice due to
    ;; env-read-only! typically being used on components after env-conjoin* has already been called.
    ;; We could mitigate bad timing by registering listeners that wait for an env to freeze.
    (define (env-conjoin* env*)
      (let ((env* (filter (lambda (env) (not (equal? (env 'frozen?) id-dict.empty))) env*)))
        (cond
          ((null? env*)       env.empty)
          ((null? (cdr env*)) (env-read-only (car env*)))
          (else (define (self method)
                  (case method
                    ((ref/k)      (lambda (id kf k)
                                    (let loop ((env* env*))
                                      (if (null? env*)
                                          (kf)
                                          (((car env*) 'ref/k) id (lambda () (loop (cdr env*))) k)))))
                    ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k env-conjoin environment" id)))
                    ((read-only!) (values))
                    ((read-only)  self)
                    ((frozen?)    #f)
                    ((writable)   #f)
                    ((describe)   (append* (map (lambda (env) (env 'describe)) env*)))
                    (else         (mistake "invalid environment operation" method))))
                self)))))
  (define (env-conjoin . env*) (env-conjoin* env*))

  ;; This enables a simple implementation of splicing definition forms.
  (define (env-read-and-write env.read env.write)
    (let ((env.read (env-read-only env.read)) (env.write (env.write 'writable)))
      (if env.write
          (mlet ((env.write env.write))
            (lambda (method)
              (case method
                ((ref/k)      (lambda (id kf k) ((env.read 'ref/k) id kf k)))
                ((bind!/k)    (lambda (id x kf k)
                                (let ((env.write env.write))
                                  (unless env.write (mistake "cannot bind!/k read-only environment" id))
                                  ((env.write 'bind!/k) id x kf k))))
                ((read-only!) (set! env.write #f))
                ((read-only)  env.read)
                ((frozen?)    (and (not env.write) (env.read 'frozen?)))
                ((writable)   env.write)
                ((describe)   (env.read 'describe))
                (else         (mistake "invalid environment operation" method)))))
          env.read)))

  (splicing-local
    ((define (env-unmark env.m m)
       (mlet ((read-only? #f))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k) ((env.m 'ref/k) (syntax-add-mark id m) kf k)))
             ((bind!/k)    (lambda (id x kf k)
                             (when read-only? (mistake "cannot bind!/k read-only environment" id))
                             ((env.m 'bind!/k) (syntax-add-mark id m) x kf k)))
             ((read-only!) (set! read-only? #t))
             ((read-only)  (if read-only? self (let ((env (env-unmark env.m m)))
                                                 (env-read-only! env)
                                                 env)))
             ((frozen?)    #f)
             ((writable)   (and (not read-only?) self))
             ((describe)   '())
             (else         (mistake "invalid environment operation" method))))
         self))
     (define (env-disjoin env.mark m env.no-mark)
       (mlet ((read-only? (not (env.no-mark 'writable))))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k)
                             (let ((i (identifier-remove-mark id m)))
                               (if i ((env.mark 'ref/k) i kf k) ((env.no-mark 'ref/k) id kf k)))))
             ((bind!/k)    (lambda (id x kf k)
                             (when read-only? (mistake "cannot bind!/k read-only environment" id))
                             (let ((i (identifier-remove-mark id m)))
                               (if i ((env.mark 'bind!/k) i x kf k) ((env.no-mark 'bind!/k) id x kf k)))))
             ((read-only!) (set! read-only? #t))
             ((read-only)  (if read-only? self (let ((env (env-disjoin env.mark m env.no-mark)))
                                                 (env-read-only! env)
                                                 env)))
             ((frozen?)    #f)
             ((writable)   (and (not read-only?) self))
             ((describe)   (env.no-mark 'describe))
             (else         (mistake "invalid environment operation" method))))
         self)))
    (define (syntax-transcribe stx op env.op env.use)
      (let* ((env.op   (if (env.use 'writable)
                           (let ((env.d (make-env))) (env-read-and-write (env-conjoin env.d env.op) env.d))
                           env.op))
             (m        (fresh-mark))
             (env      (env-disjoin env.op m env.use))
             (result   (op (syntax-add-mark stx m)))
             (result   (if (procedure? result)
                           (let ((env (env-unmark env m)))
                             (let loop ((result (result env)))
                               (if (procedure? result) (loop (result env)) result)))
                           result)))
        (values (syntax-add-mark result m) env))))

  (define (env-remove env id*)
    (define (self method)
      (case method
        ((ref/k)      (lambda (id kf k) (if (memv id id*) (kf) ((env 'ref/k) id kf k))))
        ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k env-remove environment" id)))
        ((read-only!) (values))
        ((read-only)  self)
        ((frozen?)    #f)
        ((writable)   #f)
        ((describe)   (filter (lambda (id) (not (memv id id*))) (env 'describe)))
        (else         (mistake "invalid environment operation" method))))
    self)

  (define (env:ref ref)
    (define (self method)
      (case method
        ((ref/k)      (lambda (id kf k) (let ((x (ref id))) (if x (k x) (kf)))))
        ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k read-only environment" id)))
        ((read-only!) (values))
        ((read-only)  self)
        ((frozen?)    #f)
        ((writable)   #f)
        ((describe)   '())
        (else         (mistake "invalid environment operation" method))))
    self)

  (define (env-ref          env id)        (env-ref/k    env id (lambda () #f) values))
  (define (env-ref/k        env id kf k)   ((env 'ref/k) id kf k))
  (define (env-read-only!   env)           (env 'read-only!))
  (define (env-read-only    env)           (env 'read-only))
  ;; TODO: sort and remove duplicates
  (define (env-describe     env)           (env 'describe))
  (define (env-bind!/k      env id x kf k) ((env 'bind!/k) id x kf k))
  (define (env-rebind!      env id x)      (env-bind!/k env id x #f values))
  (define (env-bind!        env id x)
    (env-bind!/k env id x (lambda (x) (mistake 'env-bind! "already bound" id x)) values))
  (define (env-identifier=? env a b)
    (or (identifier=? a b)
        (env-ref/k env a
                   (lambda ()  (env-ref/k env b
                                          (lambda () (eqv? (syntax-unwrap a) (syntax-unwrap b)))
                                          (lambda (b) #f)))
                   (lambda (a) (env-ref/k env b
                                          (lambda () #f)
                                          (lambda (b) (equal? a b))))))))
