;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Syntax with lazy mark propagation ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define current-mark-level (make-parameter 0))

(splicing-local
  ((define-values (unused-subtype-mark make-mark mark? access-mark unused-mutate-mark!)
     (make-record-type 'mark 1 '() #t #f #f))
   (define (fresh-mark) (make-mark (current-mark-level)))
   (define (mark-level m) (access-mark m 0))
   (define mark=? eqv?)
   (define (mark*=? a* b*)
     (let loop ((a* a*) (b* b*))
       (if (pair? a*)
           (and (pair? b*)
                (mark=? (car a*) (car b*))
                (loop (cdr a*) (cdr b*)))
           (null? b*))))
   (define (mark*-append m*.outer m*.inner)
     (cond ((null? m*.inner) m*.outer)
           ((null? m*.outer) m*.inner)
           (else (let loop ((m*.outer (reverse m*.outer)) (m*.inner m*.inner))
                   (if (mark=? (car m*.outer) (car m*.inner))
                       (let ((m*.outer (cdr m*.outer)) (m*.inner (cdr m*.inner)))
                         (cond ((null? m*.outer) m*.inner)
                               ((null? m*.inner) (reverse m*.outer))
                               (else             (loop m*.outer m*.inner))))
                       (cons (car m*.outer)
                             (let loop ((m*.outer (cdr m*.outer)) (m* m*.inner))
                               (if (null? m*.outer)
                                   m*
                                   (loop (cdr m*.outer) (cons (car m*.outer) m*))))))))))
   (define-values (unused-subtype-annotated make-annotated annotated? access-annotated unused-mutate-annotated!)
     (make-record-type 'syntax:annotated 2 #f #t #f #f))
   (define (annotated form note) (if (null? note) form (make-annotated form note)))
   (define (annotated-form s) (if (annotated? s) (access-annotated s 0) s))
   (define (annotated-note s) (if (annotated? s) (access-annotated s 1) '()))
   (define-values (unused-subtype-marked make-marked marked? access-marked unused-mutate-marked!)
     (make-record-type 'syntax:marked 2 #f #t #f #f))
   (define (marked mark* form) (if (null? mark*) form (make-marked mark* form)))
   (define (marked-form  s) (access-marked s 1))
   (define (syntax-form  s) (annotated-form (if (marked? s) (marked-form s) s)))
   (define (syntax-mark* s) (if (marked? s) (access-marked s 0) '()))
   (define (syntax-wrap s m*)
     (if (marked? s)
         (marked (mark*-append m* (syntax-mark* s)) (marked-form s))
         (let ((form (annotated-form s)))
           (if (or (pair? form) (vector? form) (symbol? form)) (marked m* s) s))))
   (define (syntax-add-mark s m) (syntax-wrap s (list m)))
   (define (identifier-remove-mark id m)
     (identifier?! id)
     (let ((m* (syntax-mark* id)))
       (and (pair? m*) (mark=? (car m*) m) (marked (cdr m*) (marked-form id))))))

  (define (syntax-note     s)       (annotated-note (if (marked? s) (marked-form s) s)))
  (define (syntax-note-set s note) (marked (syntax-mark* s) (annotated (syntax-form s) note)))
  (define (syntax-note-add s note) (syntax-note-set s (atree-replace (syntax-note s) note)))

  (define (syntax-unwrap s)
    (if (marked? s)
        (let ((d (syntax-form s)) (m* (syntax-mark* s)))
          (define (wrap x) (syntax-wrap x m*))
          (cond ((pair?   d) (cons (wrap (car d)) (wrap (cdr d))))
                ((vector? d) (vector-map wrap d))
                (else        d)))
        (annotated-form s)))

  (define (syntax-prune-level s level)
    (let prune ((s s))
      (let loop ((m* (syntax-mark* s)))
        (if (null? m*)
            (let ((d (syntax-form s)))
              (cond ((pair?   d) (cons (prune (car d)) (prune (cdr d))))
                    ((vector? d) (vector-map prune d))
                    (else        d)))
            (let ((m (car m*)))
              (if (<= level (mark-level m))
                  (loop (cdr m*))
                  (marked m* (marked-form s))))))))

  (define (datum->syntax context datum)
    (identifier?! context)
    (if (marked? context)
        (syntax-wrap datum (syntax-mark* context))
        datum))

  (define (syntax->datum s)
    (let loop ((s s))
      (let ((x (syntax-form s)))
        (cond ((pair?   x) (cons (loop (car x)) (loop (cdr x))))
              ((vector? x) (vector-map loop x))
              (else        x)))))

  (define (identifier?  s) (symbol? (syntax-form s)))
  (define (identifier?! s) (unless (identifier? s) (mistake "not an identifier" s)))
  (define (identifier=? a b)
    (identifier?! a) (identifier?! b)
    (and (eqv? (syntax-form a) (syntax-form b))
         (mark*=? (syntax-mark* a) (syntax-mark* b))))

  ;;;;;;;;;;;;;;;;;;;;
  ;;; Environments ;;;
  ;;;;;;;;;;;;;;;;;;;;
  ;; NOTE: lookup is currently O(n^2), but may not be a problem in practice.  Consider more efficient
  ;; dictionary data structures If we need to harden this.
  ;;
  ;; In order for a better dictionary structure to help, env-conjoin would have to combine
  ;; sub-dictionaries.  But this is only possible if the sub-dictionaries are frozen.
  ;;
  ;; TODO: experiment with replacing higher order env representation with records.
  (splicing-local
    ((define (alist-ref    kv* k)   (let ((kv (assv k kv*))) (and kv (cdr kv))))
     (define (alist-set    kv* k v) (cons (cons k v) (alist-remove kv* k)))
     (define (alist-remove kv* k)
       (let ((kv (assv k kv*)))
         (if kv
             (let loop ((kv* kv*))
               (cond ((eqv? (car kv*) kv) (cdr kv*))  ; assumes mark=? is eqv?
                     (else                (cons (car kv*) (loop (cdr kv*))))))
             kv*)))
     (define trie.empty '(() . ()))  ; trie : `(,sym=>x . ,mark=>trie)
     (define (trie-ref t m* sym)
       (let loop ((t t) (m* m*))
         (if (null? m*)
             (alist-ref (car t) sym)
             (let ((t.next (alist-ref (cdr t) (car m*))))
               (and t.next (loop t.next (cdr m*)))))))
     (define (trie-set t m* sym x)
       (let loop ((t t) (m* m*))
         (if (null? m*)
             (cons (alist-set (car t) sym x) (cdr t))
             (cons (car t)
                   (alist-set (cdr t) (car m*)  ; requires mark=? assumption in alist-remove
                              (loop (or (alist-ref (cdr t) (car m*)) trie.empty) (cdr m*)))))))
     (define id-dict.empty trie.empty)
     (define (id-dict-key* id=>x)
       (let loop ((t id=>x))
         (append (map car (car t))
                 (append* (map (lambda (kv)
                                 (let ((m (car kv)))
                                   (map (lambda (id) (syntax-add-mark id m))
                                        (map loop (cdr kv)))))
                               (cdr t))))))
     (define (id-dict-ref id=>x id)
       (identifier?! id)
       (trie-ref id=>x (syntax-mark* id) (syntax-form id)))
     (define (id-dict-set id=>x id x)
       (identifier?! id)
       (trie-set id=>x (syntax-mark* id) (syntax-form id) x))
     (define (env:mdict id=>x)
       (mlet ((id=>x id=>x) (frozen? #f))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k) (let ((x (id-dict-ref id=>x id)))
                                               (if x (k x) (kf)))))
             ((bind!/k)    (lambda (id x kf k)
                             (when frozen? (mistake "cannot bind!/k frozen environment" id))
                             (let ((x.existing (id-dict-ref id=>x id)))
                               (if x.existing
                                   (kf x.existing)
                                   (begin (set! id=>x (id-dict-set id=>x id x)) (k))))))
             ((freeze!)    (set! frozen? id=>x))
             ((freeze)     (if frozen? self (env:dict id=>x)))
             ((frozen?)    frozen?)
             ((read-only?) frozen?)
             ((writable)   (and (not frozen?) self))
             ((describe)   (id-dict-key* id=>x))
             (else         (mistake "invalid environment operation" method))))
         self))
     (define (env:dict id=>x) (let ((env (env:mdict id=>x))) (env 'freeze!) env)))
    (define (make-env) (env:mdict id-dict.empty))
    (define (env-conjoin* env*)
      (let ((env* (filter (lambda (env) (not (equal? (env 'frozen?) id-dict.empty))) env*)))
        (cond
          ((null? env*)       env.empty)
          ((null? (cdr env*)) (env-read-only (car env*)))
          (else (mlet ((frozen? #f))
                  (define (self method)
                    (case method
                      ((ref/k)      (lambda (id kf k)
                                      (let loop ((env* env*))
                                        (if (null? env*)
                                            (kf)
                                            (((car env*) 'ref/k) id (lambda () (loop (cdr env*))) k)))))
                      ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k env-conjoin environment" id)))
                      ;; TODO: combine dictionaries when possible
                      ((freeze!)    (unless frozen?
                                      (for-each (lambda (env) (env 'freeze!)) env*)
                                      (set! frozen? #t)))
                      ((freeze)     (if frozen?
                                        self
                                        (let ((new (env-conjoin* (map (lambda (env) (env 'freeze)) env*))))
                                          (when (andmap (lambda (env) (env 'frozen?)) env*) (set! frozen? #t))
                                          new)))
                      ((frozen?)    frozen?)
                      ((read-only?) #t)
                      ((writable)   #f)
                      ((describe)   (append* (map (lambda (env) (env 'describe)) env*)))
                      (else         (mistake "invalid environment operation" method))))
                  self))))))
  (define (env-conjoin . env*) (env-conjoin* env*))

  (define (env-read-only env)
    (if (env 'read-only?)
        env
        (lambda (method)
          (case method
            ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k read-only environment" id)))
            ((read-only?) #t)
            ((writable)   #f)
            (else         (env method))))))

  ;; This enables a simple implementation of splicing definition forms.
  (define (env-read-and-write env.read env.write)
    (let ((env.read (env-read-only env.read)) (env.write (env.write 'writable)))
      (if env.write
          (mlet ((env.write env.write))
            (lambda (method)
              (case method
                ((ref/k)      (lambda (id kf k) ((env.read 'ref/k) id kf k)))
                ((bind!/k)    (lambda (id x kf k)
                                (let ((env.write env.write))
                                  (unless env.write (mistake "cannot bind!/k frozen environment" id))
                                  ((env.write 'bind!/k) id x kf k))))
                ((freeze!)    (env.read 'freeze!) (set! env.write #f))
                ((freeze)     (env.read 'freeze))
                ((frozen?)    (and (not env.write) (env.read 'frozen?)))
                ((read-only?) (not env.write))
                ((writable)   env.write)
                ((describe)   (env.read 'describe))
                (else         (mistake "invalid environment operation" method)))))
          env.read)))

  (splicing-local
    ((define (env-unmark env.m m)
       (mlet ((frozen? #f))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k) ((env.m 'ref/k) (syntax-add-mark id m) kf k)))
             ((bind!/k)    (lambda (id x kf k) ((env.m 'bind!/k) (syntax-add-mark id m) x kf k)))
             ((freeze!)    (unless frozen?
                             (env.m 'freeze!)
                             (set! frozen? #t)))
             ((freeze)     (if frozen? self (let ((new (env-unmark (env.m 'freeze) m)))
                                              (when (env.m 'frozen?) (set! frozen? #t))
                                              new)))
             ((frozen?)    frozen?)
             ((read-only?) frozen?)
             ((writable)   (and (not frozen?) self))
             ((describe)   '())
             (else         (mistake "invalid environment operation" method))))
         self))
     (define (env-disjoin env.mark m env.no-mark)
       (mlet ((frozen? #f))
         (define (self method)
           (case method
             ((ref/k)      (lambda (id kf k)
                             (let ((i (identifier-remove-mark id m)))
                               (if i ((env.mark 'ref/k) i kf k) ((env.no-mark 'ref/k) id kf k)))))
             ((bind!/k)    (lambda (id x kf k)
                             (let ((i (identifier-remove-mark id m)))
                               (if i ((env.mark 'bind!/k) i x kf k) ((env.no-mark 'bind!/k) id x kf k)))))
             ((freeze!)    (unless frozen?
                             (env.mark 'freeze!)
                             (env.no-mark 'freeze!)
                             (set! frozen? #t)))
             ((freeze)     (if frozen?
                               self
                               (let ((new (env-disjoin (env.mark 'freeze) m (env.no-mark 'freeze))))
                                 (when (and (env.mark 'frozen?) (env.no-mark 'frozen?)) (set! frozen? #t))
                                 new)))
             ((frozen?)    frozen? (or frozen? (and (env.mark 'frozen?) (env.no-mark 'frozen?)
                                                    (begin (set! frozen? #t) #t))))
             ((read-only?) frozen?)
             ((writable)   (and (not frozen?) self))
             ((describe)   (env.no-mark 'describe))
             (else         (mistake "invalid environment operation" method))))
         self)))
    (define (syntax-transcribe stx op env.op env.use . env*)
      (let* ((m       (fresh-mark))
             (disjoin (lambda (env.op env.use) (env-disjoin env.op m env.use)))
             (env     (disjoin env.op env.use))
             (env*    (alist-map (plist->alist env*) disjoin))
             (result  (op (syntax-add-mark stx m)))
             (result  (if (procedure? result) (result (env-unmark env m)) result)))
        (apply values (syntax-add-mark result m) env env*))))

  (define (env-remove env id*)
    (mlet ((frozen? #f))
      (define (self method)
        (case method
          ((ref/k)      (lambda (id kf k) (if (memv id id*) (kf) ((env 'ref/k) id kf k))))
          ((bind!/k)    (lambda (id x kf k) (mistake "cannot bind!/k env-remove environment" id)))
          ((freeze!)    (unless frozen? (env 'freeze!) (set! frozen? #t)))
          ((freeze)     (if frozen? self (let ((new (env-remove (env 'freeze) id*)))
                                           (when (env 'frozen?) (set! frozen? #t))
                                           new)))
          ((frozen?)    frozen?)
          ((read-only?) #t)
          ((writable)   #f)
          ((describe)   (filter (lambda (id) (not (memv id id*))) (env 'describe)))
          (else         (mistake "invalid environment operation" method))))
      self))

  (define env.empty (let ((env (make-env))) (env 'freeze!) env))

  (define (env-ref      env id)        (env-ref/k    env id (lambda () #f) values))
  (define (env-ref/k    env id kf k)   ((env 'ref/k) id kf k))
  (define (env-freeze!  env)           (env 'freeze!))
  (define (env-freeze   env)           (env 'freeze))
  ;; TODO: sort and remove duplicates
  (define (env-describe env)           (env 'describe)))
  (define (env-bind!/k  env id x kf k) ((env 'bind!/k) id x kf k))
  (define (env-bind!    env id x)
    (env-bind!/k env id x (lambda (x) (mistake 'env-bind! "already bound" id x)) values))
