;;;;;;;;;;;
;;; LLL ;;;
;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Location Expr)
;;              | (set! Location Label)
;;              | (jump-if (Compare-op Expr Expr) Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Call
;;              | Label
;; Expr       ::= S64 | Location | (Binary-op Expr Expr) | Call
;; Call       ::= (call Label Expr ...) | (call Expr Expr ...)
;; Binary-op  ::= + | - | * | and | ior | xor | asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; Location   ::= Var | Memory
;; Var        ::= <symbol>
;; Memory     ::= #(mloc Width Expr Expr Expr)
;; Width      ::= 1 | 2 | 4 | 8
;; S64        ::= <signed 64-bit integer>
;; Label      ::= <string>

(define (mloc w b d i) (vector 'mloc w b d i))
(define (mloc? x) (and (vector? x) (= (vector-length x) 5) (eqv? (vector-ref x 0) 'mloc)))
(define (mloc-width x) (vector-ref x 1))
(define (mloc-base  x) (vector-ref x 2))
(define (mloc-disp  x) (vector-ref x 3))
(define (mloc-index x) (vector-ref x 4))

(splicing-local
  ((define Label? string?)
   (define 2^63 #x8000000000000000)
   (define 2^64 #x10000000000000000)
   (define s64-min (- 2^63))
   (define s64-max #x7FFFFFFFFFFFFFFF)
   (define (s64 x) (if (<= s64-min x s64-max) x (let ((x (integer-floor-mod x 2^64)))
                                                  (if (< x 2^63) x (+ (- x 2^63) s64-min)))))
   (define (u64 x) (if (< x 0) (+ (- x s64-min) s64-max) x))
   (define (cmp-nand a b) (= (bitwise-and a b) 0))
   (define (cmp-and a b) (not (cmp-nand a b)))
   (define (u< a b) (< (u64 a) (u64 b)))
   (define (u<= a b) (<= (u64 a) (u64 b)))
   (define (u> a b) (> (u64 a) (u64 b)))
   (define (u>= a b) (>= (u64 a) (u64 b)))
   (define cmpop=>procedure
     `((and . ,cmp-and)
       (nand . ,cmp-nand) (= . ,=) (=/= . ,(lambda (a b) (not (= a b))))
       (< . ,<) (<= . ,<=) (> . ,>) (>= . ,>=) (u< . ,u<) (u<= . ,u<=) (u> . ,u>) (u>= . ,u>=)))
   (define binop=>procedure
     `((lsr . ,(lambda (n k) (bitwise-and (bitwise-asr n k) (- (bitwise-asl 1 (- 64 k)) 1))))
       (lsl . ,bitwise-asl) (asr . ,bitwise-asr) (asl . ,bitwise-asl)
       (and . ,bitwise-and) (ior . ,bitwise-ior) (xor . ,bitwise-xor)
       (+ . ,+) (- . ,-) (* . ,*))))

  (define (LLL-validate P)
    (define (Memory? x) (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1))
                                           (mistake "invalid mloc width" x))
                             (Expr?! (mloc-base x)) (Expr?! (mloc-disp x)) (Expr?! (mloc-index x))))
    (define (Location? x) (or (symbol? x) (Memory? x)))
    (define (S64? x) (and (integer? x) (or (<= s64-min x s64-max)
                                           (mistake "not a signed 64-bit integer" x))))
    (define ((Arity2-op?/op=>procedure op=>procedure) x)
      (and (pair? x) (assv (car x) op=>procedure)
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda ((a b) (and (Expr?! a) (Expr?! b)))
                               (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (define Binary-op? (Arity2-op?/op=>procedure binop=>procedure))
    (define Comparison? (Arity2-op?/op=>procedure cmpop=>procedure))
    (define (Call? x) (and (pair? x) (eqv? (car x) 'call) (pair? (cdr x))
                           (let ((rator (cadr x)) (rand* (cddr x)))
                             (and (or (Label? rator) (Expr? rator) (mistake "not callable" rator x))
                                  (or (list? rand*) (mistake "not a list" x))
                                  (andmap Expr?! rand*)))))
    (define (Expr? x) (or (Location? x) (S64? x) (Binary-op? x) (Call? x)))
    (define (Expr?! x) (or (Expr? x) (mistake "not an expression" x)))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs)
                           (unless (Location? lhs) (mistake "not a location" lhs S))
                           (unless (or (Expr? rhs) (Label? rhs))
                             (mistake "not an expression or label" rhs S))))
                 ((jump-if) (lambda (cmp label)
                              (unless (Comparison? cmp) (mistake "not a comparison" cmp))
                              (unless (Label? label) (mistake "not a label" label))))
                 ((jump) (lambda (target) (unless (or (Location? target) (Label? target))
                                            (mistake "not a location or label" target S))))
                 ((call) (lambda _ (unless (Call? S) (mistake "invalid call" S))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (or (Label? S) (mistake "not a Statement" S))))
               (cdr S)))))

  (define (LLL-eval P loc=>x)
    (mlet ((loc=>x loc=>x))
      (define (mloc-addr x) (let ((width (mloc-width x)) (addr (+ (Expr (mloc-base x))
                                                                  (Expr (mloc-disp x))
                                                                  (Expr (mloc-index x)))))
                              (unless (= (integer-floor-mod addr width) 0)
                                (mistake "unaligned memory address for width" width addr))
                              addr))
      (define (loc-ref l) (let ((entry (assv l loc=>x)))
                            (unless entry (mistake "unassigned location" l))
                            (cdr entry)))
      (define (loc-set! l x)
        (set! loc=>x (cons (cons l (if (integer? x) (s64 x) x)) (aremv l loc=>x))))
      (define (Arity2-op op a b)
        (cond ((assv op binop=>procedure) => (lambda (kop) (s64 ((cdr kop) (Expr a) (Expr b)))))
              ((assv op cmpop=>procedure) => (lambda (kop) ((cdr kop) (Expr a) (Expr b))))
              (else (mistake "invalid operator" op))))
      (define (Expr x)
        (cond ((symbol? x) (loc-ref x))
              ((integer? x) x)
              ((mloc? x) (let ((width (mloc-width x)) (addr (mloc-addr x)))
                           (if (= width 8)
                               (loc-ref addr)
                               (let* ((mask   (- (expt 2 (* width 8)) 1))
                                      (offset (integer-floor-mod addr 8))
                                      (shift  (* offset 8))
                                      (v      (loc-ref (- addr offset))))
                                 (bitwise-and (bitwise-asr v shift) mask)))))
              ((eqv? (car x) 'call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" x)))
              (else (apply (lambda (a b) (Arity2-op (car x) a b)) (cdr x)))))
      (define (Assign lhs rhs)
        (let ((rhs (if (Label? rhs) rhs (Expr rhs))))
          (if (symbol? lhs)
              (loc-set! lhs rhs)
              (let ((width (mloc-width lhs)) (addr (mloc-addr lhs)))
                (if (= width 8)
                    (loc-set! addr rhs)
                    (let* ((mask   (- (expt 2 (* width 8)) 1))
                           (offset (integer-floor-mod addr 8))
                           (shift  (* offset 8))
                           (v      (loc-ref (- addr offset))))
                      (loc-set! (- addr offset)
                                (bitwise-ior (bitwise-and (bitwise-not (bitwise-asl mask shift)) v)
                                             (bitwise-asl rhs shift)))))))))
      (mdefine label=>S* '())
      (mdefine pc (let loop ((S* (list P)))
                    (if (null? S*)
                        '()
                        (let ((S (car S*)) (S* (cdr S*)))
                          (cond ((Label? S) (let ((S* (loop S*)))
                                              (set! label=>S* (cons (cons S S*) label=>S*))
                                              S*))
                                ((eqv? (car S) 'begin) (loop (append (cdr S) S*)))
                                (else (cons S (loop S*))))))))
      (define (jump! x) (set! pc (cdr (or (assv x label=>S*) (mistake "missing jump target" x)))))
      (let loop ()
        (unless (null? pc)
          (let ((S (car pc)))
            (set! pc (cdr pc))
            (apply (case (car S)
                     ((set!) Assign)
                     ((jump-if) (lambda (cmp label) (when (Expr cmp) (jump! label))))
                     ((jump) (lambda (x) (jump! (if (Label? x) x (Expr x)))))
                     ((call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" S)))
                     ((begin) (lambda S* (for-each loop S*)))
                     (else (mistake "not a Statement" S)))
                   (cdr S)))
          (loop)))
      (append (afilter symbol? loc=>x) (afilter integer? loc=>x)))))
