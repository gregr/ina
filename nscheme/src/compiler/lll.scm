;;;;;;;;;;;
;;; LLL ;;;
;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Location Expr)
;;              | (set! Location Label)
;;              | (set! Location (CC-op Expr Expr))
;;              | (set! Location (cc CC))
;;              | (set! Location Call)
;;              | (set! Var1 (atomic-cas Memory8 Var1 Expr))
;;              | (jump-if (Compare-op Expr Expr) Label)
;;              | (jump-if (cc CC) Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Call
;;              | Label
;; Expr       ::= S64 | Location | (Binary-op Expr Expr) | (Compare-op Expr Expr)
;; Call       ::= (call Label Expr ...) | (call Expr Expr ...)
;; Binary-op  ::= + | - | * | and | ior | xor | asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; CC-op      ::= addc | subc | +/carry | -/carry | +/over | -/over | */over
;; CC         ::= carry | ncarry | over | nover  ; NOTE: carry is borrow, not inverted borrow
;; Location   ::= Var | Memory
;; Var        ::= <symbol>
;; Memory     ::= #(mloc Width Expr Expr Expr)
;; Memory8    ::= #(mloc 8     Expr Expr Expr)
;; Width      ::= 1 | 2 | 4 | 8
;; S64        ::= <signed 64-bit integer>
;; Label      ::= <string>

(define (mloc w b d i) (vector 'mloc w b d i))
(define (mloc? x) (and (vector? x) (= (vector-length x) 5) (eqv? (vector-ref x 0) 'mloc)))
(define (mloc-width x) (vector-ref x 1))
(define (mloc-base  x) (vector-ref x 2))
(define (mloc-disp  x) (vector-ref x 3))
(define (mloc-index x) (vector-ref x 4))

(splicing-let ((2^63 #x8000000000000000) (2^64 #x10000000000000000))
  (define s64-min (- 2^63))
  (define s64-max (- 2^63 1))
  (define u64-max (- 2^64 1))
  (define (s64 x) (let ((x (integer-floor-mod x 2^64))) (if (< x 2^63) x (- x 2^64))))
  (define (u64 x) (integer-floor-mod x 2^64)))

(splicing-local
  ((define Label? string?)
   (define (cmp-nand a b) (= (bitwise-and a b) 0))
   (define (cmp-and a b) (not (cmp-nand a b)))
   (define (u< a b) (< (u64 a) (u64 b)))
   (define (u<= a b) (<= (u64 a) (u64 b)))
   (define (u> a b) (> (u64 a) (u64 b)))
   (define (u>= a b) (>= (u64 a) (u64 b)))
   (define carryop=>procedure
     (local ((define ((/carry op) a b c)
               (let* ((x (op (u64 a) (u64 b) c)) (y (u64 x))) (values (s64 y) (not (= x y))))))
       `((addc . ,(/carry +))
         (subc . ,(/carry -))
         (+/carry . ,(/carry (lambda (a b _) (+ a b))))
         (-/carry . ,(/carry (lambda (a b _) (- a b)))))))
   (define overop=>procedure
     (local ((define ((/over op) a b) (let* ((x (op a b)) (y (s64 x))) (values y (not (= x y))))))
       `((+/over . ,(/over +))
         (-/over . ,(/over -))
         (*/over . ,(/over *)))))
   (define cmpop=>procedure
     `((and . ,cmp-and)
       (nand . ,cmp-nand) (= . ,=) (=/= . ,(lambda (a b) (not (= a b))))
       (< . ,<) (<= . ,<=) (> . ,>) (>= . ,>=) (u< . ,u<) (u<= . ,u<=) (u> . ,u>) (u>= . ,u>=)))
   (define binop=>procedure
     `((lsr . ,(lambda (n k) (bitwise-and (bitwise-asr n k) (- (bitwise-asl 1 (- 64 k)) 1))))
       (lsl . ,bitwise-asl) (asr . ,bitwise-asr) (asl . ,bitwise-asl)
       (and . ,bitwise-and) (ior . ,bitwise-ior) (xor . ,bitwise-xor)
       (+ . ,+) (- . ,-) (* . ,*))))

  (define (LLL-validate P)
    (define (Memory? x) (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1))
                                           (mistake "invalid mloc width" x))
                             (Expr?! (mloc-base x)) (Expr?! (mloc-disp x)) (Expr?! (mloc-index x))))
    (define (Memory?! x) (or (Memory? x) (mistake "not a memory location" x)))
    (define (Memory8?! x) (or (and (Memory?! x) (eqv? (mloc-width x) 8))
                              (mistake "memory width is not 8" x)))
    (define (Location? x) (or (symbol? x) (Memory? x)))
    (define (S64? x) (and (integer? x) (or (<= s64-min x s64-max)
                                           (mistake "not a signed 64-bit integer" x))))
    (define ((Arity2-op?/op=>procedure op=>procedure) x)
      (and (pair? x) (assv (car x) op=>procedure)
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda ((a b) (and (Expr?! a) (Expr?! b)))
                               (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (define Binary-op?  (Arity2-op?/op=>procedure binop=>procedure))
    (define Comparison? (Arity2-op?/op=>procedure cmpop=>procedure))
    (define Carry-op?   (Arity2-op?/op=>procedure carryop=>procedure))
    (define Over-op?    (Arity2-op?/op=>procedure overop=>procedure))
    (define (Call? x) (and (pair? x) (eqv? (car x) 'call) (pair? (cdr x))
                           (let ((rator (cadr x)) (rand* (cddr x)))
                             (and (or (Label? rator) (Expr? rator) (mistake "not callable" rator x))
                                  (or (list? rand*) (mistake "not a list" x))
                                  (andmap Expr?! rand*)))))
    (define (Expr? x) (or (Location? x) (S64? x) (Binary-op? x) (Comparison? x)))
    (define (Expr?! x) (or (Expr? x) (mistake "not an expression" x)))
    (define (CC?! x) (or (memv x '(carry ncarry over nover)) (mistake "not a condition code" x)))
    (define (cc? x) (and (pair? x) (eqv? (car x) 'cc) (list? (cdr x))
                         (apply (case-lambda ((x) (CC?! x))
                                             (_ (mistake "operator arity mismatch" x)))
                                (cdr x))))
    (define (CAS?/lhs lhs x)
      (and (pair? x) (eqv? (car x) 'atomic-cas)
           (apply (case-lambda
                    ((loc expected new)
                     (unless (symbol? lhs)
                       (mistake "atomic-cas is not assigned to a variable" lhs x))
                     (unless (eqv? expected lhs)
                       (mistake "atomic-cas expected value is not the assigned variable"
                                lhs expected))
                     (and (Memory8?! loc) (Expr?! new)))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs)
                           (unless (Location? lhs) (mistake "not a location" lhs S))
                           (unless (or (Expr? rhs) (Label? rhs) (Call? rhs) (cc? rhs)
                                       (Carry-op? rhs) (Over-op? rhs) (CAS?/lhs lhs rhs))
                             (mistake "invalid set! right-hand-side" S))))
                 ((jump-if) (lambda (x label)
                              (unless (or (Comparison? x) (cc? x)) (mistake "not a condition" x S))
                              (unless (Label? label) (mistake "not a label" label))))
                 ((jump) (lambda (target) (unless (or (Location? target) (Label? target))
                                            (mistake "not a location or label" target S))))
                 ((call) (lambda _ (unless (Call? S) (mistake "invalid call" S))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (or (Label? S) (mistake "not a Statement" S))))
               (cdr S)))))

  (define (LLL-eval P loc=>x)
    (mlet ((loc=>x loc=>x) (flag #f))
      (define (mloc-addr x) (let ((width (mloc-width x)) (addr (+ (Expr (mloc-base x))
                                                                  (Expr (mloc-disp x))
                                                                  (Expr (mloc-index x)))))
                              (unless (= (integer-floor-mod addr width) 0)
                                (mistake "unaligned memory address for width" width addr))
                              addr))
      (define (loc-ref l) (let ((entry (assv l loc=>x)))
                            (unless entry (mistake "unassigned location" l))
                            (cdr entry)))
      (define (loc-set! l x)
        (set! loc=>x (cons (cons l (if (integer? x) (s64 x) x)) (aremv l loc=>x))))
      (define (Arity2-op op a b)
        (cond ((assv op binop=>procedure)
               => (lambda (kop) (set! flag #f) (s64 ((cdr kop) (Expr a) (Expr b)))))
              ((assv op cmpop=>procedure)
               => (lambda (kop) (set! flag #f) (if ((cdr kop) (Expr a) (Expr b)) 1 0)))
              ((assv op overop=>procedure)
               => (lambda (kop)
                    (let-values (((x over?) ((cdr kop) (Expr a) (Expr b))))
                      (set! flag (and over? 'over))
                      x)))
              ((assv op carryop=>procedure)
               => (lambda (kop)
                    (let-values (((x carry?) ((cdr kop) (Expr a) (Expr b)
                                                        (if (eqv? flag 'carry) 1 0))))
                      (set! flag (and carry? 'carry))
                      x)))
              (else (mistake "invalid operator" op))))
      (define (Arity3-op op a b c)
        (case op
          ((atomic-cas) (let ((current (Expr a)) (expected (Expr b)) (new (Expr c)))
                          (when (eqv? current expected) (Assign! a new))
                          (set! flag #f)
                          current))
          (else (mistake "invalid operator" op))))
      (define (Expr x)
        (cond ((symbol? x) (loc-ref x))
              ((integer? x) x)
              ((mloc? x) (let ((width (mloc-width x)) (addr (mloc-addr x)))
                           (if (= width 8)
                               (loc-ref addr)
                               (let* ((mask   (- (expt 2 (* width 8)) 1))
                                      (offset (integer-floor-mod addr 8))
                                      (shift  (* offset 8))
                                      (v      (loc-ref (- addr offset))))
                                 (bitwise-and (bitwise-asr v shift) mask)))))
              ((eqv? (car x) 'call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" x)))
              ((eqv? (car x) 'cc) (case (cadr x)
                                    ((carry)  (if (eqv? flag 'carry) 1 0))
                                    ((ncarry) (if (eqv? flag 'carry) 0 1))
                                    ((over)   (if (eqv? flag 'over) 1 0))
                                    ((nover)  (if (eqv? flag 'over) 0 1))
                                    (else (mistake "not a condition code" (cadr x)))))
              (else (apply (case-lambda
                             ((a b)   (Arity2-op (car x) a b))
                             ((a b c) (Arity3-op (car x) a b c)))
                           (cdr x)))))
      (define (Assign! lhs rhs)
        (let ((rhs (if (Label? rhs) rhs (Expr rhs))))
          (if (symbol? lhs)
              (loc-set! lhs rhs)
              (let ((width (mloc-width lhs)) (addr (mloc-addr lhs)))
                (if (= width 8)
                    (loc-set! addr rhs)
                    (let* ((mask   (- (expt 2 (* width 8)) 1))
                           (offset (integer-floor-mod addr 8))
                           (shift  (* offset 8))
                           (v      (loc-ref (- addr offset))))
                      (loc-set! (- addr offset)
                                (bitwise-ior (bitwise-and (bitwise-not (bitwise-asl mask shift)) v)
                                             (bitwise-asl rhs shift)))))))))
      (mdefine label=>S* '())
      (mdefine pc (let loop ((S* (list P)))
                    (if (null? S*)
                        '()
                        (let ((S (car S*)) (S* (cdr S*)))
                          (cond ((Label? S) (let ((S* (loop S*)))
                                              (set! label=>S* (cons (cons S S*) label=>S*))
                                              S*))
                                ((eqv? (car S) 'begin) (loop (append (cdr S) S*)))
                                (else (cons S (loop S*))))))))
      (define (jump! x) (set! pc (cdr (or (assv x label=>S*) (mistake "missing jump target" x)))))
      (let loop ()
        (unless (null? pc)
          (let ((S (car pc)))
            (set! pc (cdr pc))
            (apply (case (car S)
                     ((set!) Assign!)
                     ((jump-if) (lambda (cmp label) (unless (= (Expr cmp) 0) (jump! label))))
                     ((jump) (lambda (x) (jump! (if (Label? x) x (Expr x)))))
                     ((call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" S)))
                     ((begin) (lambda S* (for-each loop S*)))
                     (else (mistake "not a Statement" S)))
                   (cdr S)))
          (loop)))
      (append (afilter symbol? loc=>x) (afilter integer? loc=>x)))))
