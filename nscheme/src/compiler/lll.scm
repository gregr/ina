;; TODO: express SIMD computations
;; - SSE registers and instructions for x86-64
;; - floating point literals and operations
;; - maybe distinguished operators of the form: vELEMENT-BYTE-SIZEop ? e.g., v4+, v8*

;;;;;;;;;;;
;;; LLL ;;;
;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Location Expr)
;;              | (set! Location (CC-op Expr Expr))
;;              | (set! Location (lea Memory))
;;              | (set! Location Call)
;;              | (set! Location Relocation)
;;              | (set! Var1 (atomic-cas Memory8 Var1 Expr))
;;              | (set2! Location Location (u128* Expr Expr))
;;              | (jump-if Condition Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Call
;;              | Label
;; Expr       ::= SU64 | Label | Location | (Binary-op Expr Expr) | Condition | (if Condition Expr Expr)
;; Call       ::= (call Expr Expr ...)
;; Binary-op  ::= + | - | * | and | ior | xor | asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; CC-op      ::= addc | subc | +/carry | -/carry | +/over | -/over | */over
;; CC         ::= carry | ncarry | over | nover  ; NOTE: carry is borrow, not inverted borrow
;; Condition  ::= (Compare-op Expr Expr) | (cc CC)
;; Location   ::= Var | Memory
;; Var        ::= <symbol>
;; Memory8    ::= #(mloc 8      Expr Expr Expr IShift)
;; Memory     ::= #(mloc MWidth Expr Expr Expr IShift)
;; MWidth     ::= 8 | 4 | 2 | 1
;; IShift     ::= 0 | 1 | 2 | 3
;; SU64       ::= <signed or unsigned 64-bit integer>
;; Label      ::= <string>
;; Relocation ::= <relocation>
(splicing-local
  ((define Label? string?)
   (define Var? symbol?)
   (define (cmp-nand a b) (= (bitwise-and a b) 0))
   (define (cmp-and a b) (not (cmp-nand a b)))
   (define (u< a b) (< (u64 a) (u64 b)))
   (define (u<= a b) (<= (u64 a) (u64 b)))
   (define (u> a b) (> (u64 a) (u64 b)))
   (define (u>= a b) (>= (u64 a) (u64 b)))
   (define carryop=>procedure
     (local ((define ((/carry op) a b c)
               (let* ((x (op (u64 a) (u64 b) c)) (y (u64 x))) (values (s64 y) (not (= x y))))))
       `((addc . ,(/carry +))
         (subc . ,(/carry -))
         (+/carry . ,(/carry (lambda (a b _) (+ a b))))
         (-/carry . ,(/carry (lambda (a b _) (- a b)))))))
   (define overop=>procedure
     (local ((define ((/over op) a b) (let* ((x (op a b)) (y (s64 x))) (values y (not (= x y))))))
       `((+/over . ,(/over +))
         (-/over . ,(/over -))
         (*/over . ,(/over *)))))
   (define cmpop=>procedure
     `((and . ,cmp-and)
       (nand . ,cmp-nand) (= . ,=) (=/= . ,(lambda (a b) (not (= a b))))
       (< . ,<) (<= . ,<=) (> . ,>) (>= . ,>=) (u< . ,u<) (u<= . ,u<=) (u> . ,u>) (u>= . ,u>=)))
   (define binop=>procedure
     `((lsr . ,(lambda (n k) (bitwise-and (bitwise-asr n k) (- (bitwise-asl 1 (- 64 k)) 1))))
       (lsl . ,bitwise-asl) (asr . ,bitwise-asr) (asl . ,bitwise-asl)
       (and . ,bitwise-and) (ior . ,bitwise-ior) (xor . ,bitwise-xor)
       (+ . ,+) (- . ,-) (* . ,*))))

  (define (LLL-validate P)
    (define (Memory? x)
      (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1)) (mistake "invalid mloc width" x))
           (let ((b (mloc-base x)) (d (mloc-disp x)) (i (mloc-index x)) (s (mloc-shift x)))
             (and (Expr?! b) (Expr?! d) (Expr?! i)
                  (or (memv s '(0 1 2 3)) (mistake "invalid mloc shift" x))))))
    (define (Memory?! x) (or (Memory? x) (mistake "not a memory location" x)))
    (define (Memory8?! x) (or (and (Memory?! x) (eqv? (mloc-width x) 8))
                              (mistake "memory width is not 8" x)))
    (define (Location? x) (or (Var? x) (Memory? x)))
    (define (Location?!/ctx ctx x) (unless (Location? x) (mistake "not a location" x ctx)))
    (define (SU64? x) (and (integer? x) (or (<= s64-min x u64-max)
                                            (mistake "not a signed or unsigned 64-bit integer" x))))
    (define (operation? x tag handle)
      (and (pair? x) (if (procedure? tag) (tag (car x)) (eqv? (car x) tag))
           (or (list? (cdr x)) (mistake "not a list" x)) (apply handle (cdr x))))
    (define ((Arity2-op?/op=>procedure op=>procedure) x)
      (operation? x (lambda (t) (assv t op=>procedure))
                  (case-lambda ((a b) (and (Expr?! a) (Expr?! b)))
                               (_ (mistake "operator arity mismatch" x)))))
    (define Binary-op?  (Arity2-op?/op=>procedure binop=>procedure))
    (define Comparison? (Arity2-op?/op=>procedure cmpop=>procedure))
    (define Carry-op?   (Arity2-op?/op=>procedure carryop=>procedure))
    (define Over-op?    (Arity2-op?/op=>procedure overop=>procedure))
    (define (Call? x) (operation? x 'call (case-lambda
                                            ((op . rand*) (and (or (Expr? op)
                                                                   (mistake "not callable" op x))
                                                               (andmap Expr?! rand*)))
                                            (_ (mistake "call arity mismatch" x)))))
    (define (If? x) (operation? x 'if (case-lambda
                                        ((c t f) (and (Condition?! c) (Expr?! t) (Expr?! f)))
                                        (_ (mistake "if arity mismatch" x)))))
    (define (Condition? x) (or (Comparison? x) (cc? x)))
    (define (Condition?! x) (or (Condition? x) (mistake "not a condition" x)))
    (define (Expr? x) (or (Location? x) (SU64? x) (Label? x) (Binary-op? x) (Condition? x) (If? x)))
    (define (Expr?! x) (or (Expr? x) (mistake "not an expression" x)))
    (define (cc? x) (operation? x 'cc (case-lambda ((x) (or (memv x '(carry ncarry over nover))
                                                            (mistake "not a condition code" x)))
                                                   (_ (mistake "operator arity mismatch" x)))))
    (define (LEA? x) (operation? x 'lea (case-lambda
                                          ((loc) (Memory?! loc))
                                          (_ (mistake "operator arity mismatch" x)))))
    (define (CAS?/lhs lhs x)
      (operation? x 'atomic-cas
                  (case-lambda
                    ((loc expected new)
                     (unless (Var? lhs) (mistake "atomic-cas is not assigned to a variable" lhs x))
                     (unless (eqv? expected lhs)
                       (mistake "atomic-cas expected value is not reassigned" lhs expected x))
                     (and (Memory8?! loc) (Expr?! new)))
                    (_ (mistake "operator arity mismatch" x)))))
    (define (u128*? x) (operation? x 'u128* (case-lambda
                                              ((a b) (Expr?! a) (Expr?! b))
                                              (_ (mistake "operator arity mismatch" x)))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs)
                           (Location?!/ctx S lhs)
                           (unless (or (Expr? rhs) (Call? rhs) (Carry-op? rhs) (Over-op? rhs)
                                       (LEA? rhs) (CAS?/lhs lhs rhs) (relocation? rhs))
                             (mistake "invalid set! right-hand-side" rhs S))))
                 ((set2!) (lambda (l1 l2 r) (Location?!/ctx S l1) (Location?!/ctx S l2) (u128*? r)))
                 ((jump-if) (lambda (x label)
                              (Condition?! x)
                              (unless (Label? label) (mistake "not a label" label))))
                 ((jump) (lambda (target) (unless (or (Location? target) (Label? target))
                                            (mistake "not a location or label" target S))))
                 ((call) (lambda _ (unless (Call? S) (mistake "invalid call" S))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (or (Label? S) (mistake "not a Statement" S))))
               (cdr S)))))

  (define (LLL-eval P loc=>x)
    (mlet ((loc=>x loc=>x) (flag #f))
      (define (mloc-addr x) (let ((width (mloc-width x))
                                  (addr (+ (Expr (mloc-base x)) (Expr (mloc-disp x))
                                           (* (Expr (mloc-index x))
                                              (bitwise-asl 1 (mloc-shift x))))))
                              (unless (= (integer-floor-mod addr width) 0)
                                (mistake "unaligned memory address for width" width addr))
                              addr))
      (define (loc-ref l) (let ((entry (assv l loc=>x)))
                            (unless entry (mistake "unassigned location" l))
                            (cdr entry)))
      (define (loc-set! l x)
        (set! loc=>x (cons (cons l (if (integer? x) (s64 x) x)) (aremv l loc=>x))))
      (define (Arity2-op op a b)
        (cond ((assv op binop=>procedure)
               => (lambda (kop) (set! flag #f) (s64 ((cdr kop) (Expr a) (Expr b)))))
              ((assv op cmpop=>procedure)
               => (lambda (kop) (set! flag #f) (if ((cdr kop) (Expr a) (Expr b)) 1 0)))
              ((assv op overop=>procedure)
               => (lambda (kop)
                    (let-values (((x over?) ((cdr kop) (Expr a) (Expr b))))
                      (set! flag (and over? 'over))
                      x)))
              ((assv op carryop=>procedure)
               => (lambda (kop)
                    (let-values (((x carry?) ((cdr kop) (Expr a) (Expr b)
                                                        (if (eqv? flag 'carry) 1 0))))
                      (set! flag (and carry? 'carry))
                      x)))
              (else (mistake "invalid operator" op))))
      (define (Arity3-op op a b c)
        (case op
          ((atomic-cas) (let ((current (Expr a)) (expected (Expr b)) (new (Expr c)))
                          (when (eqv? current expected) (Assign! a new))
                          (set! flag #f)
                          current))
          (else (mistake "invalid operator" op))))
      (define (Expr x)
        (cond ((Var? x) (loc-ref x))
              ((integer? x) (s64 x))
              ((mloc? x) (let ((width (mloc-width x)) (addr (mloc-addr x)))
                           (if (= width 8)
                               (loc-ref addr)
                               (let* ((mask   (- (expt 2 (* width 8)) 1))
                                      (offset (integer-floor-mod addr 8))
                                      (shift  (* offset 8))
                                      (v      (loc-ref (- addr offset))))
                                 (bitwise-and (bitwise-asr v shift) mask)))))
              ((Label? x) (mistake "cannot evaluate label" x))
              ((eqv? (car x) 'call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" x)))
              ((eqv? (car x) 'cc) (case (cadr x)
                                    ((carry)  (if (eqv? flag 'carry) 1 0))
                                    ((ncarry) (if (eqv? flag 'carry) 0 1))
                                    ((over)   (if (eqv? flag 'over) 1 0))
                                    ((nover)  (if (eqv? flag 'over) 0 1))
                                    (else (mistake "not a condition code" (cadr x)))))
              ((eqv? (car x) 'lea) (mloc-addr (cadr x)))
              ((eqv? (car x) 'if) (apply (lambda (c t f) (Expr (if (= (Expr c) 0) f t))) (cdr x)))
              (else (apply (case-lambda
                             ((a b)   (Arity2-op (car x) a b))
                             ((a b c) (Arity3-op (car x) a b c)))
                           (cdr x)))))
      (define (Expr128 x)
        (case (car x)
          ((u128*) (apply (lambda (a b) (let ((r (* (u64 (Expr a)) (u64 (Expr b)))))
                                          (values (s64 (bitwise-asr r 64))
                                                  (s64 (bitwise-and r #xFFFFFFFFFFFFFFFF)))))
                          (cdr x)))
          (else (mistake "invalid Expr128" x))))
      (define (assign! l x)
        (if (Var? l)
            (loc-set! l x)
            (let ((width (mloc-width l)) (addr (mloc-addr l)))
              (if (= width 8)
                  (loc-set! addr x)
                  (let* ((mask   (- (expt 2 (* width 8)) 1))
                         (offset (integer-floor-mod addr 8))
                         (shift  (* offset 8))
                         (v      (loc-ref (- addr offset))))
                    (loc-set! (- addr offset)
                              (bitwise-ior (bitwise-and (bitwise-not (bitwise-asl mask shift)) v)
                                           (bitwise-asl x shift))))))))
      (define (Assign! lhs rhs)
        (when (relocation? rhs) (mistake "cannot evaluate relocation" lhs rhs))
        (assign! lhs (if (Label? rhs) rhs (Expr rhs))))
      (define (Assign2! lhs1 lhs2 rhs) (let-values (((r1 r2) (Expr128 rhs)))
                                         (assign! lhs1 r1)
                                         (assign! lhs2 r2)))
      (mdefine label=>S* '())
      (mdefine pc (let loop ((S* (list P)))
                    (if (null? S*)
                        '()
                        (let ((S (car S*)) (S* (cdr S*)))
                          (cond ((Label? S) (let ((S* (loop S*)))
                                              (set! label=>S* (cons (cons S S*) label=>S*))
                                              S*))
                                ((eqv? (car S) 'begin) (loop (append (cdr S) S*)))
                                (else (cons S (loop S*))))))))
      (define (jump! x) (set! pc (cdr (or (assv x label=>S*) (mistake "missing jump target" x)))))
      (let loop ()
        (unless (null? pc)
          (let ((S (car pc)))
            (set! pc (cdr pc))
            (apply (case (car S)
                     ((set!) Assign!)
                     ((set2!) Assign2!)
                     ((jump-if) (lambda (cmp label) (unless (= (Expr cmp) 0) (jump! label))))
                     ((jump) (lambda (x) (jump! (if (Label? x) x (Expr x)))))
                     ((call) (lambda _ (mistake 'LLL-eval "cannot evaluate call" S)))
                     ((begin) (lambda S* (for-each loop S*)))
                     (else (mistake "not a Statement" S)))
                   (cdr S)))
          (loop)))
      (append (afilter Var? loc=>x) (afilter integer? loc=>x)))))
