;;;;;;;;;;;
;;; LLL ;;;
;;;;;;;;;;;
;; Statement ::= (begin Statement ...)
;;             | (set! Location Expr)
;;             | (set! Location Label)
;;             | (jump Label)
;;             | (jump Location)
;;             | Label
;; Expr      ::= S64 | Location | (Binary-op Expr Expr)
;; Binary-op ::= + | - | * | and | ior | xor | asl | asr | lsl | lsr
;; Location  ::= Var | Memory
;; Var       ::= <symbol>
;; Memory    ::= (memory Width Expr)
;; Width     ::= 1 | 2 | 4 | 8
;; S64       ::= <signed 64-bit integer>
;; Label     ::= <string>
(splicing-local
  ((define Label? string?)
   (define s64-min -9223372036854775808)
   (define s64-max 9223372036854775807)
   (define 2^63 9223372036854775808)
   (define 2^64 18446744073709551616)
   (define (s64 x) (if (<= s64-min x s64-max) x (let ((x (integer-floor-mod x 2^64)))
                                                  (if (< x 2^63) x (+ (- x 2^63) s64-min)))))
   (define binop=>procedure
     `((lsr . ,(lambda (n k) (bitwise-and (bitwise-asr n k) (- (bitwise-asl 1 (- 64 k)) 1))))
       (lsl . ,bitwise-asl) (asr . ,bitwise-asr) (asl . ,bitwise-asl)
       (and . ,bitwise-and) (ior . ,bitwise-ior) (xor . ,bitwise-xor)
       (+ . ,+) (- . ,-) (* . ,*))))

  (define (LLL-validate P)
    (define (Memory? x) (and (pair? x) (eqv? (car x) 'memory) (list? (cdr x))
                             (apply (case-lambda
                                      ((width expr) (unless (memv width '(1 2 4 8))
                                                      (mistake "invalid memory width" width))
                                                    (Expr?! expr))
                                      (_ (mistake "memory arity mismatch" x)))
                                    (cdr x))))
    (define (Location? x) (or (symbol? x) (Memory? x)))
    (define (S64? x) (and (integer? x) (or (<= s64-min x s64-max)
                                           (mistake "not a signed 64-bit integer" x))))
    (define (Binary-op? x) (and (pair? x) (assv (car x) binop=>procedure)
                                (or (list? (cdr x)) (mistake "not a list" x))
                                (apply (case-lambda ((a b) (and (Expr?! a) (Expr?! b)))
                                                    (_ (mistake "operator arity mismatch" x)))
                                       (cdr x))))
    (define (Expr? x) (or (Location? x) (S64? x) (Binary-op? x)))
    (define (Expr?! x) (or (Expr? x) (mistake "not an expression" x)))
    (let loop ((S P))
      (unless (Label? S)
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs)
                           (unless (Location? lhs) (mistake "not a location" lhs S))
                           (unless (or (Expr? rhs) (Label? rhs))
                             (mistake "not an expression or label" rhs S))))
                 ((jump) (lambda (target) (unless (or (Location? target) (Label? target))
                                            (mistake "not a location or label" target S))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (or (Label? S) (mistake "not a Statement" S))))
               (cdr S)))))

  (define (LLL-eval P loc=>x)
    (mlet ((loc=>x loc=>x))
      (define (Memory->width x) (cadr x))
      (define (Memory->addr x) (let ((width (cadr x)) (addr (Expr (caddr x))))
                                 (unless (= (integer-floor-mod addr width) 0)
                                   (mistake "unaligned memory address for width" width addr))
                                 addr))
      (define (loc-ref l) (let ((entry (assv l loc=>x)))
                            (unless entry (mistake "unassigned location" l))
                            (cdr entry)))
      (define (loc-set! l x)
        (set! loc=>x (cons (cons l (if (integer? x) (s64 x) x)) (aremv l loc=>x))))
      (define (Binary-op op a b) (s64 ((cdr (assv op binop=>procedure)) (Expr a) (Expr b))))
      (define (Expr x)
        (cond ((symbol? x) (loc-ref x))
              ((integer? x) x)
              ((eqv? (car x) 'memory) (let ((width (Memory->width x)) (addr (Memory->addr x)))
                                        (if (= width 8)
                                            (loc-ref addr)
                                            (let* ((mask   (- (expt 2 (* width 8)) 1))
                                                   (offset (integer-floor-mod addr 8))
                                                   (shift  (* offset 8))
                                                   (v      (loc-ref (- addr offset))))
                                              (bitwise-and (bitwise-asr v shift) mask)))))
              (else (apply (lambda (a b) (Binary-op (car x) a b)) (cdr x)))))
      (define (Assign lhs rhs)
        (let ((rhs (if (Label? rhs) rhs (Expr rhs))))
          (if (symbol? lhs)
              (loc-set! lhs rhs)
              (let ((width (Memory->width lhs)) (addr (Memory->addr lhs)))
                (if (= width 8)
                    (loc-set! addr rhs)
                    (let* ((mask   (- (expt 2 (* width 8)) 1))
                           (offset (integer-floor-mod addr 8))
                           (shift  (* offset 8))
                           (v      (loc-ref (- addr offset))))
                      (loc-set! (- addr offset)
                                (bitwise-ior (bitwise-and (bitwise-not (bitwise-asl mask shift)) v)
                                             (bitwise-asl rhs shift)))))))))
      (mdefine label=>S* '())
      (mdefine pc (let loop ((S* (list P)))
                    (if (null? S*)
                        '()
                        (let ((S (car S*)) (S* (cdr S*)))
                          (cond ((Label? S) (let ((S* (loop S*)))
                                              (set! label=>S* (cons (cons S S*) label=>S*))
                                              S*))
                                ((eqv? (car S) 'begin) (loop (append (cdr S) S*)))
                                (else (cons S (loop S*))))))))
      (let loop ()
        (unless (null? pc)
          (let ((S (car pc)))
            (set! pc (cdr pc))
            (apply (case (car S)
                     ((set!) Assign)
                     ((jump) (lambda (x) (let ((x (if (Label? x) x (Expr x))))
                                           (set! pc (cdr (or (assv x label=>S*)
                                                             (mistake "missing jump target" x)))))))
                     ((begin) (lambda S* (for-each loop S*)))
                     (else (mistake "not a Statement" S)))
                   (cdr S)))
          (loop)))
      (append (afilter symbol? loc=>x) (afilter integer? loc=>x)))))
