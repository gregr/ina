;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement ::= (begin Statement ...)
;;             | (set! Register S64)
;;             | (set! Register Register)
;;             | (set! Register Memory)
;;             | (set! Memory S32)
;;             | (set! Memory Register)
;;             | (set! Location1 (Binary-op Location1 S32))
;;             | (set! Location1 (Binary-op Location1 Register))
;;             | (set! Register1 (Binary-op Register1 Memory8))
;;             | (set! Register1 (* Register1 S32))
;;             | (set! Register1 (* Register1 Register))
;;             | (set! Register1 (* Register1 Memory8))
;; Binary-op ::= + | -  ; * destination must be a register
;; Location  ::= Register | Memory8
;; Register  ::= rax | rcx | rdx | rbx | rbp | rsi | rdi  ; omit rsp
;;             | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory    ::= (memory Width Address)
;; Memory8   ::= (memory 8 Address)
;; Address   ::= Register | (+ Register S32) | (+ Register Register)
;; Width     ::= 1 | 2 | 4 | 8
;; S64       ::= <signed 64-bit integer>
;; S32       ::= <signed 32-bit integer>
(splicing-local
  ((define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (register/width r w)
     (case r
       ((rax) (case w ((1) 'al)   ((2) 'ax)   ((4) 'eax)))
       ((rcx) (case w ((1) 'cl)   ((2) 'cx)   ((4) 'ecx)))
       ((rdx) (case w ((1) 'dl)   ((2) 'dx)   ((4) 'edx)))
       ((rsi) (case w ((1) 'sil)  ((2) 'si)   ((4) 'esi)))
       ((rdi) (case w ((1) 'dil)  ((2) 'di)   ((4) 'edi)))
       ((r8)  (case w ((1) 'r8b)  ((2) 'r8w)  ((4) 'r8d)))
       ((r9)  (case w ((1) 'r9b)  ((2) 'r9w)  ((4) 'r9d)))
       ((r10) (case w ((1) 'r10b) ((2) 'r10w) ((4) 'r10d)))
       ((r11) (case w ((1) 'r11b) ((2) 'r11w) ((4) 'r11d)))
       ((rbx) (case w ((1) 'bl)   ((2) 'bx)   ((4) 'ebx)))
       ((rbp) (case w ((1) 'bpl)  ((2) 'bp)   ((4) 'ebp)))
       ((r12) (case w ((1) 'r12b) ((2) 'r12w) ((4) 'r12d)))
       ((r13) (case w ((1) 'r13b) ((2) 'r13w) ((4) 'r13d)))
       ((r14) (case w ((1) 'r14b) ((2) 'r14w) ((4) 'r14d)))
       ((r15) (case w ((1) 'r15b) ((2) 'r15w) ((4) 'r15d)))
       (else (mistake "not a register" r))))
   (define (x/width x w) (if (symbol? x) (register/width x w) x))
   (define (binop->op op) (case op ((+) "addq") ((-) "subq") ((*) "imulq") (else #f)))
   (define (Memory-width x) (cadr x)))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x)
      (and (pair? x) (eqv? (car x) 'memory) (list? (cdr x))
           (apply (case-lambda
                    ((width x) (unless (memv width '(1 2 4 8))
                                 (mistake "invalid memory width" width))
                               (or (Register? x)
                                   (and (pair? x) (eqv? (car x) '+) (list? (cdr x))
                                        (apply (case-lambda
                                                 ((a b) (Register?! a) (or (Register? b) (S32? b)))
                                                 (_ (mistake "operator arity mismatch" x)))
                                               (cdr x)))
                                   (mistake "invalid memory address expression" x)))
                    (_ (mistake "memory arity mismatch" x)))
                  (cdr x))))
    (define (S32? x) (and (integer? x) (or (<= -2147483648 x 2147483647)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (S64? x) (and (integer? x) (or (<= -9223372036854775808 x 9223372036854775807)
                                           (mistake "not a signed 64-bit integer" x))))
    (define (Binary-op?/lhs lhs rhs)
      (and (pair? rhs) (or (binop->op (car rhs)) (mistake "invalid binary operator" rhs))
           (or (list? (cdr rhs)) (mistake "not a list" rhs))
           (apply (case-lambda
                    ((a b)
                     (or (equal? a lhs)
                         (mistake "left-hand-side mismatch in binary operation" lhs rhs))
                     (or (Register? b) (S32? b)
                         (and (Memory? b) (or (eqv? (Memory-width b) 8)
                                              (mistake "binary operand memory width is not 8" rhs)))
                         (mistake "invalid argument to binary operation" b rhs)))
                    (_ (mistake "operator arity mismatch" rhs)))
                  (cdr rhs))))
    (let loop ((S P))
      (apply
        (case (car S)
          ((set!) (lambda (lhs rhs)
                    (cond ((Memory? lhs)
                           (unless (or (Register? rhs) (S32? rhs)
                                       (and (Binary-op?/lhs lhs rhs)
                                            (or (eqv? (Memory-width lhs) 8)
                                                (mistake "binary op set! memory width is not 8" S))
                                            (or (not (eqv? (car rhs) '*))
                                                (mistake "memory left-hand-side of *" S))
                                            (or (not (Memory? (caddr rhs)))
                                                (mistake "too many memory operands" S))))
                             (mistake "invalid set! right-hand-side for memory" S)))
                          ((Register? lhs) (unless (or (Register? rhs) (S64? rhs) (Memory? rhs)
                                                       (Binary-op?/lhs lhs rhs))
                                             (mistake "invalid set! right-hand-side" rhs)))
                          (else (mistake "not a location" lhs)))))
          ((begin) (lambda S* (for-each loop S*)))
          (else (mistake "not a Statement" S)))
        (cdr S))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x) (cond ((integer? x) (string-append "$" (number->string x)))
                              ((symbol? x) (Reg x))
                              ((eqv? (car x) 'memory)
                               (let ((x (caddr x)))
                                 (if (symbol? x)
                                     (string-append "(" (Reg x) ")")
                                     (let ((a (cadr x)) (b (caddr x)))
                                       (if (symbol? b)
                                           (string-append "(" (Reg a) "," (Reg b) ")")
                                           (string-append (number->string b) "(" (Reg a) ")"))))))
                              (else (mistake "not an operand" x))))
    (define (Operand-width x) (if (pair? x) (Memory-width x) 8))
    (define (Instruction op . rand*)
      (string-append " " op " " (string-join* "," (map Operand rand*)) "\n"))
    (define (Assign lhs rhs)
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (Instruction "movq" rhs lhs))
                 ((4) (Instruction "movl" rhs (register/width lhs 4)))
                 ((2) (Instruction "movzwl" rhs (register/width lhs 4)))
                 (else (Instruction "movzbl" rhs (register/width lhs 4)))))
          ((4) (Instruction "movl" (x/width rhs 4) lhs))
          ((2) (Instruction "movw" (x/width rhs 2) lhs))
          (else (Instruction "movb" (x/width rhs 1) lhs)))))
    (define (Binary-op binop a b) (Instruction (binop->op binop) b a))
    (let loop ((S P))
      (apply (case (car S)
               ((set!) (lambda (lhs rhs)
                         (if (and (pair? rhs) (not (eqv? (car rhs) 'memory)))
                             (apply (lambda (a b) (emit (Binary-op (car rhs) a b))) (cdr rhs))
                             (emit (Assign lhs rhs)))))
               ((begin) (lambda S* (for-each loop S*)))
               (else (mistake "not a Statement" S)))
             (cdr S)))))
