;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Register SU64)
;;              | (set! Register Register)
;;              | (set! Register Memory)
;;              | (set! Memory Register)
;;              | (set! Memory8 SU64/32)
;;              | (set! Memory4 SU32)
;;              | (set! Memory2 SU16)
;;              | (set! Memory1 SU8)
;;              | (set! Location1 (Binary-op Location1 SU64/32))
;;              | (set! Location1 (Binary-op Location1 Register))
;;              | (set! Register1 (Binary-op Register1 Memory8))
;;              | (set! Location1 (Shift-op Location1 U6))
;;              | (set! Location1 (Shift-op Location1 rcx))
;;              | (set! Register  (+ Register Register))
;;              | (set! Register  (+ Register SU64/32))
;;              | (set! Register1 (- 0 Register1))
;;              | (set! Register1 (* Register1 SU64/32))
;;              | (set! Register1 (* Register1 Location))
;;              | (set! Register1 (*/over Register1 SU64/32))
;;              | (set! Register1 (*/over Register1 Location))
;;              | (set! Register Condition)
;;              | (set! Register (lea Memory))
;;              | (set! Register Label)
;;              | (set! rax (atomic-cas Memory8 rax Register))
;;              | (set! Register1 (if Condition Location Register1))
;;              | (set2! rdx rax (u128* rax Location))
;;              | (jump-if Condition Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Label
;; Binary-op  ::= + | - | and | ior | xor | CC-op  ; * destination must be a register
;; Shift-op   ::= asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; CC-op      ::= addc | subc | +/carry | -/carry | +/over | -/over
;; CC         ::= carry | ncarry | over | nover  ; NOTE: carry is borrow, not inverted borrow
;; Condition  ::= (Compare-op Location SU64/32)
;;              | (Compare-op Location Register)
;;              | (cc CC)
;; Location   ::= Register | Memory8
;; Register   ::= rax | rcx | rdx | rsi | rdi | rbx | rbp | rsp
;;              | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory     ::= Memory8 | Memory4 | Memory2 | Memory1
;; Memory8    ::= #(mloc 8 Register S32 Index IShift) | #(mloc 8 0 S32 Register IShift) | #(mloc 8 rip Label 0 0)
;; Memory4    ::= #(mloc 4 Register S32 Index IShift) | #(mloc 4 0 S32 Register IShift) | #(mloc 4 rip Label 0 0)
;; Memory2    ::= #(mloc 2 Register S32 Index IShift) | #(mloc 2 0 S32 Register IShift) | #(mloc 2 rip Label 0 0)
;; Memory1    ::= #(mloc 1 Register S32 Index IShift) | #(mloc 1 0 S32 Register IShift) | #(mloc 1 rip Label 0 0)
;; Index      ::= Register | 0
;; IShift     ::= 0 | 1 | 2 | 3
;; SU64       ::= <signed or unsigned 64-bit integer>
;; SU64/32    ::= <sign-extended-32-bit-representable signed or unsigned 64-bit integer>
;; SU32       ::= <signed or unsigned 32-bit integer>
;; SU16       ::= <signed or unsigned 16-bit integer>
;; SU8        ::= <signed or unsigned 8-bit integer>
;; S32        ::= <signed 32-bit integer>
;; U6         ::= <unsigned 6-bit integer>  ; 0 through 63
;; Label      ::= <string>
;; NOTE:
;; - (set! Register 0) invalidates condition flags (via xor R R) clearing carry and overflow
;; - (set! X (+ X 1)) and (set! X (- X 1)) do not alter the carry flag.
;; - (set! X (xor X -1)) does not alter flags.
(splicing-local
  ((define Label? string?)
   (define register* '(rax rcx rdx rsi rdi r8 r9 r10 r11 rbx rbp rsp r12 r13 r14 r15))
   (define (U8? x) (and (integer? x) (<= 0 x #xFF)))
   (define (U32? x) (and (integer? x) (<= 0 x #xFFFFFFFF)))
   (define (Shift? op) (memv op '(asl asr lsl lsr)))
   (define (binop->op op) (case op ((+ +/carry +/over) 'add) ((- -/carry -/over) 'sub)
                            ((* */over) 'imul) ((and) 'and) ((ior) 'or) ((xor) 'xor)
                            ((asl lsl) 'sal) ((asr) 'sar) ((lsr) 'shr)
                            ((addc) 'adc) ((subc) 'sbb)
                            (else #f)))
   (define (flagcc cc) (case cc ((carry) 'c) ((ncarry) 'nc) ((over) 'o) ((nover) 'no)
                         (else (mistake "not a flag condition code" cc))))
   (define (cmpop->cc op) (case op ((and) 'nz) ((nand) 'z) ((=) 'e) ((=/=)  'ne)
                            ((<) 'l) ((<=) 'le) ((>) 'g) ((>=) 'ge)
                            ((u<) 'b) ((u<=) 'be) ((u>) 'a) ((u>=) 'ae)
                            (else #f))))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?!/ctx ctx x) (or (Register? x) (mistake "not a register" x ctx)))
    (define (Memory? x)
      (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1)) (mistake "invalid mloc width" x))
           (let ((b (mloc-base x)) (d (mloc-disp x)) (i (mloc-index x)) (s (mloc-shift x)))
             (if (eqv? b 'rip)
                 (and (or (Label? d) (S32? d) (mistake "invalid rip-relative mloc displacement" x))
                      (or (eqv? i 0) (mistake "invalid rip-relative mloc index" x))
                      (or (eqv? s 0) (mistake "invalid rip-relative mloc shift" x)))
                 (and (or (eqv? b 0) (Register?!/ctx x b))
                      (or (S32? d) (mistake "invalid mloc displacement" x))
                      (or (and (eqv? i 0) (or (not (eqv? b 0))
                                              (mistake "mloc must have non-zero base or index" x)))
                          (Register? i) (mistake "invalid mloc index" x))
                      (or (memv s '(0 1 2 3)) (mistake "invalid mloc shift" x)))))))
    (define (Memory?! x) (or (Memory? x) (mistake "not a memory location" x)))
    (define (U6? x) (and (integer? x) (or (<= 0 x 63) (mistake "not an unsigned 6-bit integer" x))))
    (define (S32? x) (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (SU64/32? x)
      (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                            (<= #xFFFFFFFF80000000 x #xFFFFFFFFFFFFFFFF)
                            (mistake "not a sign-extended-32-bit-representable 64-bit integer" x))))
    (define (SU64? x) (and (integer? x) (or (<= #x-8000000000000000 x #xFFFFFFFFFFFFFFFF)
                                            (mistake "not a signed or unsigned 64-bit integer" x))))
    (define (SU32? x) (and (integer? x) (or (<= #x-80000000 x #xFFFFFFFF)
                                            (mistake "not a signed or unsigned 32-bit integer" x))))
    (define (SU16? x) (and (integer? x) (or (<= #x-8000 x #xFFFF)
                                            (mistake "not a signed or unsigned 16-bit integer" x))))
    (define (SU8? x) (and (integer? x) (or (<= #x-80 x #xFF)
                                           (mistake "not a signed or unsigned 8-bit integer" x))))
    (define (Memory8?/ctx ctx x)
      (and (Memory? x) (or (eqv? (mloc-width x) 8) (mistake "memory width is not 8" x ctx))))
    (define (Location?!/ctx ctx x) (or (Register? x) (Memory8?/ctx ctx x)
                                       (mistake "not a location" x ctx)))
    (define (operation? x tag handle)
      (and (pair? x) (if (procedure? tag) (tag (car x)) (eqv? (car x) tag))
           (or (list? (cdr x)) (mistake "not a list" x)) (apply handle (cdr x))))
    (define (Binary-op?/lhs lhs rhs)
      (operation?
        rhs binop->op
        (case-lambda
          ((a b) (or (and (eqv? (car rhs) '-) (eqv? a 0) (Register?!/ctx rhs b)
                          (or (equal? b lhs)
                              (mistake "set! left-hand-side is not the subtrahend" lhs rhs)))
                     (and (or (equal? a lhs) (and (eqv? (car rhs) '+) (Register? lhs) (Register? a)
                                                  (or (Register? b) (SU64/32? b)))
                              (mistake "set! left-hand-side mismatch in binary operation" lhs rhs))
                          (Location?!/ctx rhs a)
                          (or (not (Shift? (car rhs))) (U6? b) (eqv? b 'rcx)
                              (mistake "shift operand is neither a 6-bit integer nor rcx" b rhs))
                          (or (Register? b) (SU64/32? b)
                              (and (Memory8?/ctx rhs b)
                                   (or (Register? lhs) (mistake "too many memory operands" rhs)))
                              (mistake "invalid argument to binary operation" b rhs))
                          (or (not (memv (car rhs) '(* */over))) (Register? a)
                              (mistake "left operand of multiply is not a register" a rhs)))))
          (_ (mistake "operator arity mismatch" rhs)))))
    (define (Condition? x)
      (or (operation? x cmpop->cc
                      (case-lambda
                        ((a b) (Location?!/ctx x a)
                               (or (SU64/32? b) (Register? b)
                                   (mistake "not a register or signed 32-bit integer" b x)))
                        (_ (mistake "operator arity mismatch" x))))
          (operation? x 'cc (case-lambda ((x) (or (memv x '(carry ncarry over nover))
                                                  (mistake "not a condition code" x)))
                                         (_ (mistake "operator arity mismatch" x))))))
    (define (LEA? x) (operation? x 'lea (case-lambda
                                          ((loc) (Memory?! loc))
                                          (_ (mistake "operator arity mismatch" x)))))
    (define (If?/ctx&lhs ctx lhs x)
      (operation? x 'if (case-lambda
                          ((c t f) (Register?!/ctx ctx lhs)
                                   (unless (Condition? c) (mistake "not a condition" c x))
                                   (unless (equal? lhs f)
                                     (mistake "set! left-hand-side is not the alternative" lhs ctx))
                                   (Location?!/ctx x t))
                          (_ (mistake "if arity mismatch" x)))))
    (define (CAS?/lhs lhs x)
      (operation? x 'atomic-cas
                  (case-lambda
                    ((loc expected new)
                     (and (or (Memory8?/ctx x loc) (mistake "not a memory location" loc x))
                          (or (eqv? expected 'rax)
                              (mistake "atomic-cas 'expected' operand is not rax" expected))
                          (or (eqv? lhs 'rax) (mistake "atomic-cas is not set! to rax" lhs x))
                          (Register?!/ctx x new)))
                    (_ (mistake "operator arity mismatch" x)))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply
          (case (car S)
            ((set!) (lambda (lhs rhs)
                      (cond ((or (Binary-op?/lhs lhs rhs) (CAS?/lhs lhs rhs)))
                            ((Label? rhs) (Register?!/ctx S lhs))
                            ((Register? lhs) (unless (or (Register? rhs) (SU64? rhs) (Memory? rhs)
                                                         (Condition? rhs) (LEA? rhs)
                                                         (If?/ctx&lhs S lhs rhs))
                                               (mistake "invalid set! right-hand-side" rhs)))
                            ((Memory? lhs) (unless (or (Register? rhs) (case (mloc-width lhs)
                                                                         ((8) (SU64/32? rhs))
                                                                         ((4) (SU32? rhs))
                                                                         ((2) (SU16? rhs))
                                                                         (else (SU8? rhs))))
                                             (mistake "invalid set! memory right-hand-side" rhs S)))
                            (else (mistake "not a location" lhs)))))
            ((set2!) (lambda (l1 l2 rhs)
                       (unless (operation? rhs 'u128*
                                           (case-lambda
                                             ((a b) (unless (eqv? l1 'rdx) (mistake "not rdx" l1 S))
                                                    (unless (eqv? l2 'rax) (mistake "not rax" l2 S))
                                                    (unless (eqv? a  'rax) (mistake "not rax" a S))
                                                    (Location?!/ctx rhs b))
                                             (_ (mistake "operator arity mismatch" rhs))))
                         (mistake "not a set2! right-hand-side" rhs S))))
            ((jump-if) (lambda (x label)
                         (unless (Condition? x) (mistake "not a condition" x S))
                         (unless (Label? label) (mistake "not a label" label))))
            ((jump) (lambda (x) (unless (or (Label? x) (Register? x) (Memory8?/ctx S x))
                                  (mistake "not a jump target" x S))))
            ((begin) (lambda S* (for-each loop S*)))
            (else (mistake "not a Statement" S)))
          (cdr S)))))

  (define (LLL-generate-x86-64 P asm)
    (mdefine carry? #f) (mdefine current-cmp #f) (mdefine current-cmp-type #f)
    (define (clear-cmp!) (set! current-cmp #f))
    (define (set-cmp! cmp type) (set! current-cmp cmp) (set! current-cmp-type type))
    (define Register? symbol?)
    (define (Jump-cc cc label) (asm 'jcc cc label))
    (define (Jump x) (asm 'jmp x))
    (define (Conditional-assign-cc cc lhs rhs) (asm 'cmov cc 8 lhs rhs))
    (define (Assign lhs rhs)
      (define (Operand-width x) (if (mloc? x) (mloc-width x) 8))
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (cond ((and (Register? lhs) (eqv? rhs 0)) (Assign-0 lhs))
                            ((and (Register? lhs) (U32? rhs)) (asm 'mov 4 lhs rhs))
                            ((and (Register? lhs) (integer? rhs)
                                  (not (or (<= #x-80000000 rhs #x7FFFFFFF)
                                           (<= #xFFFFFFFF80000000 rhs #xFFFFFFFFFFFFFFFF))))
                             (asm 'mov 'abs8 lhs rhs))
                            (else (asm 'mov 8 lhs rhs))))
                 ((4) (asm 'mov 4 lhs rhs))
                 ((2) (asm 'mov 'zx2-4 lhs rhs))
                 (else (Assign-zx1 lhs rhs))))
          ((4) (asm 'mov 4 lhs rhs))
          ((2) (asm 'mov 2 lhs rhs))
          (else (asm 'mov 1 lhs rhs)))))
    (define (Assign-0 reg) (clear-cmp!) (set! carry? 0) (asm 'xor 4 reg reg))
    (define (Assign-zx1 lhs x) (asm 'mov 'zx1-4 lhs x))
    (define (Set-cc lhs cc) (asm 'setcc cc lhs))
    (define (Assign-cc lhs cc) (Set-cc lhs cc) (Assign-zx1 lhs lhs))
    (define (weak-cc cmp) (case cmp ((=) 'z) ((=/=) 'nz) ((<) 's) ((>=) 'ns) ((u>) 'nz) (else #f)))
    (define (choose-cc cmp) (if (and current-cmp (eqv? current-cmp-type 'result))
                                (weak-cc cmp)
                                (cmpop->cc cmp)))
    (define (redundant-cmp? op a b)
      (define (cmp-subsumed? op a b) (and (equal? current-cmp (cons a b))
                                          (or (eqv? current-cmp-type 'cmp)
                                              (and (eqv? current-cmp-type 'result) (weak-cc op)))))
      (case op
        ((and nand) (if (equal? a b) (cmp-subsumed? '= a 0) (and (equal? current-cmp (cons a b))
                                                                 (eqv? current-cmp-type 'test))))
        (else (cmp-subsumed? op a b))))
    (define (Compare! op a b)
      (define (Test width a b) (set! carry? 0) (asm 'test width a b))
      (case op
        ((and nand) (if (equal? a b)
                        (set-cmp! (cons a 0) 'cmp)
                        (set-cmp! (cons a b) 'test))
                    ;; NOTE: we skip 16-bit to avoid 66h LCP stalls
                    (Test (if (and (U32? b) (Register? a)) (if (U8? b) 1 4) 8) a b))
        (else (set-cmp! (cons a b) 'cmp)
              (if (and (eqv? b 0) (Register? a))
                  (Test 8 a a)
                  (begin (set! carry? #f) (asm 'cmp 8 a b))))))
    (define (Compare op a b) (unless (redundant-cmp? op a b) (Compare! op a b)))
    (define (Cmp-op lhs op a b)
      (define (k op)
        (cond ((redundant-cmp? op a b) (Assign-cc lhs (choose-cc op)))
              ((and (not (eqv? lhs a)) (not (eqv? lhs b)))
               (Assign-0 lhs) (Compare! op a b) (Set-cc lhs (choose-cc op)))
              (else (Compare! op a b) (Assign-cc lhs (choose-cc op)))))
      (if (eqv? b 0)
          (case op
            ((u>=) (Assign lhs 1))
            ((u<) (Assign lhs 0))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (Compare-jump op a b l)
      (define (k op) (Compare op a b) (Jump-cc (choose-cc op) l))
      (if (eqv? b 0)
          (case op
            ((u>=) (Jump l))
            ((u<) (No-op))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (Conditional-assign op a b lhs rhs)
      (define (k op) (Compare op a b) (Conditional-assign-cc (choose-cc op) lhs rhs))
      (if (eqv? b 0)
          (case op
            ((u>=) (Assign lhs rhs))
            ((u<) (No-op))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (No-op) (values))
    (define (Binary-op op a b)
      (let ((iop (binop->op op)))
        (and iop (let ((simple (lambda () (set! carry? #f) (asm iop 8 a b)))
                       (I/a (lambda (iop) (asm iop 8 a))))
                   (set-cmp! (cons a 0) 'result)
                   (case op
                     ((+ +/over) (case b ((1) (I/a 'inc)) ((-1) (I/a 'dec)) (else (simple))))
                     ((- -/over) (case b ((1) (I/a 'dec)) ((-1) (I/a 'inc)) (else (simple))))
                     ((* */over) (clear-cmp!) (if (eqv? b -1) (Negate a) (simple)))
                     ((+/carry -/carry) (case b
                                          ((0) (if (eqv? carry? 0)
                                                   (No-op)
                                                   (begin (set! carry? 0) (asm 'clc))))
                                          (else (simple))))
                     ((xor) (cond ((eqv? b -1) (clear-cmp!) (I/a 'not))
                                  ((eqv? a b) (Assign-0 a))
                                  (else (simple) (set! carry? 0))))
                     ((and) (if (and (Register? a) (U32? b)) (asm 'and 4 a b) (simple))
                            (set! carry? 0))
                     ((ior) (simple) (set! carry? 0))
                     ((asl asr lsl lsr) (unless (and (integer? b) (not (= b 0))) (clear-cmp!))
                                        (unless (eqv? b 0) (set! carry? #f))
                                        (asm iop 8 a b))
                     (else (simple)))
                   #t))))
    (define (Assign-op2 lhs op a b)
      (cond ((and (eqv? op '+) (not (equal? a lhs)))
             (asm 'lea 8 lhs (if (integer? b) (mloc 8 a (s64 b) 0 0) (mloc 8 a 0 b 0))))
            ((and (eqv? op '-) (eqv? a 0)) (Negate lhs))
            (else (or (Binary-op op a b) (Cmp-op lhs op a b)))))
    (define (Assign-op1 lhs op x) (case op
                                    ((cc) (Assign-cc lhs (flagcc x)))
                                    ((lea) (asm 'lea 8 lhs x))
                                    (else (mistake "invalid operator" op))))
    (define (Assign-op3 lhs op a b c)
      (case op
        ((if) (let ((op (car a)))
                (if (eqv? op 'cc)
                    (Conditional-assign-cc (flagcc (cadr a)) lhs b)
                    (Conditional-assign op (cadr a) (caddr a) lhs b))))
        ((atomic-cas) (CAS a c))
        (else "invalid operator" op)))
    (define (Negate x) (set! carry? #f) (asm 'neg 8 x))
    (define (CAS loc new) (clear-cmp!) (set! carry? #f) (asm 'lock-cmpxchg 8 loc new))
    (let loop ((S P))
      (if (Label? S)
          (begin (clear-cmp!) (set! carry? #f) (asm 'label S))
          (apply
            (case (car S)
              ((set!) (lambda (lhs rhs)
                        (cond ((Label? rhs) (asm 'lea 8 lhs (mloc 8 'rip rhs 0 0)))
                              ((pair? rhs) (apply (case-lambda
                                                    ((a b) (Assign-op2 lhs (car rhs) a b))
                                                    ((x) (Assign-op1 lhs (car rhs) x))
                                                    ((a b c) (Assign-op3 lhs (car rhs) a b c)))
                                                  (cdr rhs)))
                              (else (Assign lhs rhs)))))
              ((set2!) (lambda (l1 l2 rhs)
                         (case (car rhs)
                           ((u128*) (set! carry? #f) (asm 'mul 8 (caddr rhs)))
                           (else (mistake "not a set2! right-hand-side" rhs S)))))
              ((jump-if) (lambda (x l) (let ((op (car x)))
                                         (if (eqv? op 'cc)
                                             (Jump-cc (flagcc (cadr x)) l)
                                             (Compare-jump op (cadr x) (caddr x) l)))))
              ((jump) Jump)
              ((begin) (lambda S* (for-each loop S*)))
              (else (mistake "not a Statement" S)))
            (cdr S)))))

  (define (LLL-emit-x86-64-at&t P)
    (LLL-generate-x86-64 P (oport->x86-64-emit-at&t (current-output-port)))))
