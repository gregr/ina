;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Register SU64)
;;              | (set! Register Register)
;;              | (set! Register Memory)
;;              | (set! Memory Register)
;;              | (set! Memory8 SU64/32)
;;              | (set! Memory4 SU32)
;;              | (set! Memory2 SU16)
;;              | (set! Memory1 SU8)
;;              | (set! Location1 (Binary-op Location1 S32))
;;              | (set! Location1 (Binary-op Location1 Register))
;;              | (set! Register1 (Binary-op Register1 Memory8))
;;              | (set! Location1 (Shift-op Location1 U6))
;;              | (set! Location1 (Shift-op Location1 rcx))
;;              | (set! Register1 (* Register1 S32))
;;              | (set! Register1 (* Register1 Location))
;;              | (set! Register1 (*/over Register1 S32))
;;              | (set! Register1 (*/over Register1 Location))
;;              | (set! Register Comparison)
;;              | (set! Register (cc CC))
;;              | (set! rax (atomic-cas Memory8 rax Register))
;;              | (set! Location Label)
;;              | (jump-if Comparison Label)
;;              | (jump-if (cc CC) Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | (call Label)
;;              | (call Location)
;;              | Label
;; Binary-op  ::= + | - | and | ior | xor | CC-op  ; * destination must be a register
;; Shift-op   ::= asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; CC-op      ::= addc | subc | +/carry | -/carry | +/over | -/over
;; CC         ::= carry | ncarry | over | nover  ; NOTE: carry is borrow, not inverted borrow
;; Comparison ::= (Compare-op Location S32)
;;              | (Compare-op Location Register)
;; Location   ::= Register | Memory8
;; Register   ::= rax | rcx | rdx | rsi | rdi | rbx | rbp | rsp
;;              | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory     ::= #(mloc Width Register S32 Index)
;; Memory8    ::= #(mloc 8     Register S32 Index)
;; Memory4    ::= #(mloc 4     Register S32 Index)
;; Memory2    ::= #(mloc 2     Register S32 Index)
;; Memory1    ::= #(mloc 1     Register S32 Index)
;; Index      ::= Register | 0
;; Width      ::= 1 | 2 | 4 | 8
;; SU64       ::= <signed or unsigned 64-bit integer>
;; SU64/32    ::= <sign-extended-32-bit-representable signed or unsigned 64-bit integer>
;; SU32       ::= <signed or unsigned 32-bit integer>
;; SU16       ::= <signed or unsigned 16-bit integer>
;; SU8        ::= <signed or unsigned 8-bit integer>
;; S32        ::= <signed 32-bit integer>
;; U6         ::= <unsigned 6-bit integer>  ; 0 through 63
;; Label      ::= <string>
(splicing-local
  ((define Label? string?)
   (define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp rsp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (register/width r w)
     (case r
       ((rax) (case w ((1) 'al)   ((2) 'ax)   ((4) 'eax)))
       ((rcx) (case w ((1) 'cl)   ((2) 'cx)   ((4) 'ecx)))
       ((rdx) (case w ((1) 'dl)   ((2) 'dx)   ((4) 'edx)))
       ((rsi) (case w ((1) 'sil)  ((2) 'si)   ((4) 'esi)))
       ((rdi) (case w ((1) 'dil)  ((2) 'di)   ((4) 'edi)))
       ((r8)  (case w ((1) 'r8b)  ((2) 'r8w)  ((4) 'r8d)))
       ((r9)  (case w ((1) 'r9b)  ((2) 'r9w)  ((4) 'r9d)))
       ((r10) (case w ((1) 'r10b) ((2) 'r10w) ((4) 'r10d)))
       ((r11) (case w ((1) 'r11b) ((2) 'r11w) ((4) 'r11d)))
       ((rbx) (case w ((1) 'bl)   ((2) 'bx)   ((4) 'ebx)))
       ((rbp) (case w ((1) 'bpl)  ((2) 'bp)   ((4) 'ebp)))
       ((r12) (case w ((1) 'r12b) ((2) 'r12w) ((4) 'r12d)))
       ((r13) (case w ((1) 'r13b) ((2) 'r13w) ((4) 'r13d)))
       ((r14) (case w ((1) 'r14b) ((2) 'r14w) ((4) 'r14d)))
       ((r15) (case w ((1) 'r15b) ((2) 'r15w) ((4) 'r15d)))
       (else (mistake "not a register" r))))
   (define (x/width x w) (if (symbol? x) (register/width x w) x))
   (define (U8? x) (and (integer? x) (<= 0 x #xFF)))
   (define (U32? x) (and (integer? x) (<= 0 x #xFFFFFFFF)))
   (define (Shift? op) (memv op '(asl asr lsl lsr)))
   (define (binop->op op) (case op ((+ +/carry +/over) "addq") ((- -/carry -/over) "subq")
                            ((* */over) "imulq") ((and) "andq") ((ior) "orq") ((xor) "xorq")
                            ((asl lsl) "salq") ((asr) "sarq") ((lsr) "shrq")
                            ((addc) "adcq") ((subc) "sbbq")
                            (else #f)))
   (define (flagcc cc) (case cc ((carry) "c") ((ncarry) "nc") ((over) "o") ((nover) "no")
                         (else (mistake "not a flag condition code" cc))))
   (define (cmpop->cc op) (case op ((and) "nz") ((nand) "z") ((=) "e") ((=/=)  "ne")
                            ((<) "l") ((<=) "le") ((>) "g") ((>=) "ge")
                            ((u<) "b") ((u<=) "be") ((u>) "a") ((u>=) "ae")
                            (else #f)))
   (define (cmpop->test op) (case op ((and nand) "testq") (else "cmpq"))))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x) (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1))
                                           (mistake "invalid mloc width" x))
                             (Register?! (mloc-base x))
                             (or (S32? (mloc-disp x)) (mistake "mloc with invalid displacement" x))
                             (or (eqv? (mloc-index x) 0) (Register? (mloc-index x))
                                 (mistake "mloc with invalid index" x))))
    (define (U6? x) (and (integer? x) (or (<= 0 x 63) (mistake "not an unsigned 6-bit integer" x))))
    (define (S32? x) (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (SU64/32? x)
      (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                            (<= #xFFFFFFFF80000000 x #xFFFFFFFFFFFFFFFF)
                            (mistake "not a sign-extended-32-bit-representable 64-bit integer" x))))
    (define (SU64? x) (and (integer? x) (or (<= #x-8000000000000000 x #xFFFFFFFFFFFFFFFF)
                                            (mistake "not a signed or unsigned 64-bit integer" x))))
    (define (SU32? x) (and (integer? x) (or (<= #x-80000000 x #xFFFFFFFF)
                                            (mistake "not a signed or unsigned 32-bit integer" x))))
    (define (SU16? x) (and (integer? x) (or (<= #x-8000 x #xFFFF)
                                            (mistake "not a signed or unsigned 16-bit integer" x))))
    (define (SU8? x) (and (integer? x) (or (<= #x-80 x #xFF)
                                           (mistake "not a signed or unsigned 8-bit integer" x))))
    (define (Memory8?/ctx ctx x)
      (and (Memory? x) (or (eqv? (mloc-width x) 8) (mistake "memory width is not 8" x ctx))))
    (define (Location?!/ctx ctx x) (or (Register? x) (Memory8?/ctx ctx x)
                                       (mistake "not a location" x ctx)))
    (define (Binary-op?/lhs lhs rhs)
      (and (pair? rhs) (binop->op (car rhs))
           (or (list? (cdr rhs)) (mistake "not a list" rhs))
           (apply (case-lambda
                    ((a b) (unless (equal? a lhs)
                             (mistake "set! left-hand-side mismatch in binary operation" lhs rhs))
                           (Location?!/ctx rhs a)
                           (or (not (Shift? (car rhs))) (U6? b) (eqv? b 'rcx)
                               (mistake "shift operand is neither a 6-bit integer nor rcx" b rhs))
                           (or (Register? b) (SU64/32? b)
                               (and (Memory8?/ctx rhs b)
                                    (or (Register? lhs) (mistake "too many memory operands" rhs)))
                               (mistake "invalid argument to binary operation" b rhs))
                           (or (not (memv (car rhs) '(* */over))) (Register? a)
                               (mistake "left operand of multiply is not a register" a rhs)))
                    (_ (mistake "operator arity mismatch" rhs)))
                  (cdr rhs))))
    (define (Comparison? x)
      (and (pair? x) (cmpop->cc (car x))
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda
                    ((a b) (Location?!/ctx x a)
                           (or (SU64/32? b) (Register? b)
                               (mistake "not a register or signed 32-bit integer" b x)))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (define (CC?! x) (or (memv x '(carry ncarry over nover)) (mistake "not a condition code" x)))
    (define (cc? x) (and (pair? x) (eqv? (car x) 'cc) (list? (cdr x))
                         (apply (case-lambda ((x) (CC?! x))
                                             (_ (mistake "operator arity mismatch" x)))
                                (cdr x))))
    (define (CAS?/lhs lhs x)
      (and (pair? x) (eqv? (car x) 'atomic-cas)
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda
                    ((loc expected new)
                     (and (or (Memory8?/ctx x loc) (mistake "not a memory location" loc x))
                          (or (eqv? expected 'rax)
                              (mistake "atomic-cas 'expected' operand is not rax" expected))
                          (or (eqv? lhs 'rax) (mistake "atomic-cas is not set! to rax" lhs x))
                          (Register?! new)))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply
          (case (car S)
            ((set!) (lambda (lhs rhs)
                      (cond ((or (Binary-op?/lhs lhs rhs) (CAS?/lhs lhs rhs)))
                            ((Label? rhs) (Location?!/ctx S lhs))
                            ((Register? lhs) (unless (or (Register? rhs) (SU64? rhs) (Memory? rhs)
                                                         (Comparison? rhs) (cc? rhs))
                                               (mistake "invalid set! right-hand-side" rhs)))
                            ((Memory? lhs) (unless (or (Register? rhs) (case (mloc-width lhs)
                                                                         ((8) (SU64/32? rhs))
                                                                         ((4) (SU32? rhs))
                                                                         ((2) (SU16? rhs))
                                                                         (else (SU8? rhs))))
                                             (mistake "invalid set! memory right-hand-side" rhs S)))
                            (else (mistake "not a location" lhs)))))
            ((jump-if) (lambda (x label)
                         (unless (or (Comparison? x) (cc? x)) (mistake "not a condition" x S))
                         (unless (Label? label) (mistake "not a label" label))))
            ((jump) (lambda (x) (unless (or (Label? x) (Register? x) (Memory8?/ctx S x))
                                  (mistake "not a jump target" x S))))
            ((call) (lambda (rator)
                      (unless (or (Label? rator) (Register? rator) (Memory8?/ctx S rator))
                        (mistake "not callable" rator))))
            ((begin) (lambda S* (for-each loop S*)))
            (else (mistake "not a Statement" S)))
          (cdr S)))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (mdefine current-cmp #f) (mdefine shift-cmp? #f)
    (define Register? symbol?)
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x)
      (cond ((integer? x) (string-append "$" (number->string (s64 x))))
            ((Register? x) (Reg x))
            ((string? x) x)
            ((mloc? x) (let ((base (mloc-base x)) (disp (mloc-disp x)) (idx (mloc-index x)))
                         (string-append (cond ((eqv? disp 0)   "")
                                              ((integer? disp) (number->string disp))
                                              (else            disp))
                                        "(" (Reg base)
                                        (if (eqv? idx 0) "" (string-append "," (Reg idx))) ")")))
            (else (mistake "not an operand" x))))
    (define (Operand-width x) (if (mloc? x) (mloc-width x) 8))
    (define (Instruction op . rand*)
      (emit (string-append " " op " " (string-join* "," (map Operand rand*)) "\n")))
    (define (Jump op rand)
      (emit (string-append " " op (if (Label? rand) " " " *") (Operand rand) "\n")))
    (define (Jump-cc cc label) (Instruction (string-append "j" cc) label))
    (define (Assign lhs rhs)
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (if (and (U32? rhs) (Register? lhs))
                          (Instruction "movl" rhs (register/width lhs 4))
                          (Instruction "movq" rhs lhs)))
                 ((4) (Instruction "movl" rhs (register/width lhs 4)))
                 ((2) (Instruction "movzwl" rhs (register/width lhs 4)))
                 (else (Assign-zx1 lhs rhs))))
          ((4) (Instruction "movl" (x/width rhs 4) lhs))
          ((2) (Instruction "movw" (x/width rhs 2) lhs))
          (else (Instruction "movb" (x/width rhs 1) lhs)))))
    (define (Assign-0 reg) (let ((w4 (register/width reg 4))) (Instruction "xorl" w4 w4)))
    (define (Assign-zx1 lhs x) (Instruction "movzbl" x (register/width lhs 4)))
    (define (Set-cc w1 cc) (Instruction (string-append "set" cc) w1))
    (define (Assign-cc lhs cc) (let ((w1 (register/width lhs 1)))
                                 (Set-cc w1 cc) (Assign-zx1 lhs w1)))
    (define (shift-cc cmp) (case cmp ((=) "z") ((=/=)  "nz") ((<) "s") ((>=) "ns") ((u>) "nz")
                             (else #f)))
    (define (choose-cc cmp) (if (and shift-cmp? current-cmp) (shift-cc cmp) (cmpop->cc cmp)))
    (define (redundant-cmp? op a b)
      (and (equal? current-cmp (cons a b)) (or (not shift-cmp?) (shift-cc op))))
    (define (Compare! op a b)
      (set! current-cmp (cons a b)) (set! shift-cmp? #f)
      (cond ((and (eqv? b 0) (Register? a)) (Instruction "testq" a a))
            ((and (U32? b) (Register? a) (memv op '(and nand)))
             (if (U8? b)  ; NOTE: we skip 16-bit to avoid 66h LCP stalls
                 (Instruction "testb" b (register/width a 1))
                 (Instruction "testl" b (register/width a 4))))
            (else (Instruction (cmpop->test op) b a))))
    (define (Compare op a b) (unless (redundant-cmp? op a b) (Compare! op a b)))
    (define (Cmp-op lhs op a b)
      (define (k op)
        (cond ((redundant-cmp? op a b) (Assign-cc lhs (choose-cc op)))
              ((and (not (eqv? lhs a)) (not (eqv? lhs b)))
               (Assign-0 lhs) (Compare! op a b) (Set-cc (register/width lhs 1) (choose-cc op)))
              (else (Compare! op a b) (Assign-cc lhs (choose-cc op)))))
      (if (eqv? b 0)
          (case op
            ((u>=) (Assign lhs 1))
            ((u<) (Assign lhs 0))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (Compare-jump op a b l)
      (define (k op) (Compare op a b) (Jump-cc (choose-cc op) l))
      (if (eqv? b 0)
          (case op
            ((u>=) (Jump "jmp" l))
            ((u<) (No-op))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (No-op) (values))
    (define (Binary-op op a b)
      (let ((iop (binop->op op)))
        (and iop (let ((simple (lambda () (Instruction iop b a)))
                       (I/a (lambda (iop) (Instruction iop a))))
                   (case op
                     ((* */over) (set! current-cmp #f))
                     (else (cond ((not (Shift? op)) (set! current-cmp (cons a 0))
                                                    (set! shift-cmp? #f))
                                 ((integer? b) (unless (= b 0)
                                                 (set! current-cmp (cons a 0))
                                                 (set! shift-cmp? #t)))
                                 (else (set! current-cmp #f)))))
                   (case op
                     ;; NOTE: inc and dec do not update the CF flag, which would normally
                     ;; invalidate redundant-comparison elision for a subsequent unsigned
                     ;; comparison between the register and zero, because unsigned comparison
                     ;; condition codes rely on CF.  However, our simplifier for zero-based
                     ;; unsigned comparisons eliminates the problematic condition codes,
                     ;; maintaining soundness.
                     ((+) (case b ((1) (I/a "incq")) ((-1) (I/a "decq")) (else (simple))))
                     ((-) (case b ((1) (I/a "decq")) ((-1) (I/a "incq")) (else (simple))))
                     ((and) (if (and (Register? a) (U32? b))
                                (Instruction "andl" b (register/width a 4))
                                (simple)))
                     ((asl asr lsl lsr) (Instruction iop (if (eqv? b 'rcx) 'cl b) a))
                     (else (simple)))
                   #t))))
    (define (CAS loc new) (set! current-cmp #f) (Instruction "lock cmpxchgq" new loc))
    (let loop ((S P))
      (if (Label? S)
          (begin (set! current-cmp #f) (emit (string-append S ":\n")))
          (apply
            (case (car S)
              ((set!) (lambda (lhs rhs)
                        (cond ((Label? rhs) (Instruction "leaq" `#(mloc 8 rip ,rhs 0) lhs))
                              ((pair? rhs) (apply (case-lambda
                                                    ((a b) (let ((op (car rhs)))
                                                             (or (Binary-op op a b)
                                                                 (Cmp-op lhs op a b))))
                                                    ((cc) (Assign-cc lhs (flagcc cc)))
                                                    ((a b c) (CAS a c)))
                                                  (cdr rhs)))
                              (else (Assign lhs rhs)))))
              ((jump-if) (lambda (x l) (let ((op (car x)))
                                         (if (eqv? op 'cc)
                                             (Jump-cc (flagcc (cadr x)) l)
                                             (Compare-jump op (cadr x) (caddr x) l)))))
              ((jump) (lambda (x) (Jump "jmp" x)))
              ((call) (lambda (x) (set! current-cmp #f) (Jump "call" x)))
              ((begin) (lambda S* (for-each loop S*)))
              (else (mistake "not a Statement" S)))
            (cdr S))))))
