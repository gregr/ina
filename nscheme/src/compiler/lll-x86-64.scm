;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Register SU64)
;;              | (set! Register Register)
;;              | (set! Register Memory)
;;              | (set! Memory Register)
;;              | (set! Memory8 SU64/32)
;;              | (set! Memory4 SU32)
;;              | (set! Memory2 SU16)
;;              | (set! Memory1 SU8)
;;              | (set! Location1 (Binary-op Location1 SU64/32))
;;              | (set! Location1 (Binary-op Location1 Register))
;;              | (set! Register1 (Binary-op Register1 Memory8))
;;              | (set! Location1 (Shift-op Location1 U6))
;;              | (set! Location1 (Shift-op Location1 rcx))
;;              | (set! Register  (+ Register Register))
;;              | (set! Register  (+ Register SU64/32))
;;              | (set! Register1 (- 0 Register1))
;;              | (set! Register1 (* Register1 SU64/32))
;;              | (set! Register1 (* Register1 Location))
;;              | (set! Register1 (*/over Register1 SU64/32))
;;              | (set! Register1 (*/over Register1 Location))
;;              | (set! Register Comparison)
;;              | (set! Register (cc CC))
;;              | (set! Register (lea Memory))
;;              | (set! rax (atomic-cas Memory8 rax Register))
;;              | (set! Location Label)
;;              | (jump-if Comparison Label)
;;              | (jump-if (cc CC) Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Label
;; Binary-op  ::= + | - | and | ior | xor | CC-op  ; * destination must be a register
;; Shift-op   ::= asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; CC-op      ::= addc | subc | +/carry | -/carry | +/over | -/over
;; CC         ::= carry | ncarry | over | nover  ; NOTE: carry is borrow, not inverted borrow
;; Comparison ::= (Compare-op Location SU64/32)
;;              | (Compare-op Location Register)
;; Location   ::= Register | Memory8
;; Register   ::= rax | rcx | rdx | rsi | rdi | rbx | rbp | rsp
;;              | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory     ::= #(mloc Width Register S32 Index IShift)
;; Memory8    ::= #(mloc 8     Register S32 Index IShift)
;; Memory4    ::= #(mloc 4     Register S32 Index IShift)
;; Memory2    ::= #(mloc 2     Register S32 Index IShift)
;; Memory1    ::= #(mloc 1     Register S32 Index IShift)
;; Width      ::= 1 | 2 | 4 | 8
;; Index      ::= Register | 0
;; IShift     ::= 0 | 1 | 2 | 3
;; SU64       ::= <signed or unsigned 64-bit integer>
;; SU64/32    ::= <sign-extended-32-bit-representable signed or unsigned 64-bit integer>
;; SU32       ::= <signed or unsigned 32-bit integer>
;; SU16       ::= <signed or unsigned 16-bit integer>
;; SU8        ::= <signed or unsigned 8-bit integer>
;; S32        ::= <signed 32-bit integer>
;; U6         ::= <unsigned 6-bit integer>  ; 0 through 63
;; Label      ::= <string>
;; NOTE:
;; - (set! Register 0) invalidates condition flags (via xor R R) clearing carry and overflow
;; - (set! X (+ X 1)) and (set! X (- X 1)) do not alter the carry flag.
;; - (set! X (xor X -1)) does not alter flags.
(splicing-local
  ((define Label? string?)
   (define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp rsp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (register/width r w)
     (case r
       ((rax) (case w ((1) 'al)   ((2) 'ax)   ((4) 'eax)))
       ((rcx) (case w ((1) 'cl)   ((2) 'cx)   ((4) 'ecx)))
       ((rdx) (case w ((1) 'dl)   ((2) 'dx)   ((4) 'edx)))
       ((rsi) (case w ((1) 'sil)  ((2) 'si)   ((4) 'esi)))
       ((rdi) (case w ((1) 'dil)  ((2) 'di)   ((4) 'edi)))
       ((r8)  (case w ((1) 'r8b)  ((2) 'r8w)  ((4) 'r8d)))
       ((r9)  (case w ((1) 'r9b)  ((2) 'r9w)  ((4) 'r9d)))
       ((r10) (case w ((1) 'r10b) ((2) 'r10w) ((4) 'r10d)))
       ((r11) (case w ((1) 'r11b) ((2) 'r11w) ((4) 'r11d)))
       ((rbx) (case w ((1) 'bl)   ((2) 'bx)   ((4) 'ebx)))
       ((rbp) (case w ((1) 'bpl)  ((2) 'bp)   ((4) 'ebp)))
       ((r12) (case w ((1) 'r12b) ((2) 'r12w) ((4) 'r12d)))
       ((r13) (case w ((1) 'r13b) ((2) 'r13w) ((4) 'r13d)))
       ((r14) (case w ((1) 'r14b) ((2) 'r14w) ((4) 'r14d)))
       ((r15) (case w ((1) 'r15b) ((2) 'r15w) ((4) 'r15d)))
       (else (mistake "not a register" r))))
   (define (x/width x w) (if (symbol? x) (register/width x w) x))
   (define (U8? x) (and (integer? x) (<= 0 x #xFF)))
   (define (U32? x) (and (integer? x) (<= 0 x #xFFFFFFFF)))
   (define (Shift? op) (memv op '(asl asr lsl lsr)))
   (define (binop->op op) (case op ((+ +/carry +/over) "addq") ((- -/carry -/over) "subq")
                            ((* */over) "imulq") ((and) "andq") ((ior) "orq") ((xor) "xorq")
                            ((asl lsl) "salq") ((asr) "sarq") ((lsr) "shrq")
                            ((addc) "adcq") ((subc) "sbbq")
                            (else #f)))
   (define (flagcc cc) (case cc ((carry) "c") ((ncarry) "nc") ((over) "o") ((nover) "no")
                         (else (mistake "not a flag condition code" cc))))
   (define (cmpop->cc op) (case op ((and) "nz") ((nand) "z") ((=) "e") ((=/=)  "ne")
                            ((<) "l") ((<=) "le") ((>) "g") ((>=) "ge")
                            ((u<) "b") ((u<=) "be") ((u>) "a") ((u>=) "ae")
                            (else #f))))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x) (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1))
                                           (mistake "invalid mloc width" x))
                             (Register?! (mloc-base x))
                             (or (S32? (mloc-disp x)) (mistake "mloc with invalid displacement" x))
                             (or (eqv? (mloc-index x) 0) (Register? (mloc-index x))
                                 (mistake "mloc with invalid index" x))
                             (or (memv (mloc-shift x) '(0 1 2 3)) (mistake "invalid mloc shift" x))))
    (define (Memory?! x) (or (Memory? x) (mistake "not a memory location" x)))
    (define (U6? x) (and (integer? x) (or (<= 0 x 63) (mistake "not an unsigned 6-bit integer" x))))
    (define (S32? x) (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (SU64/32? x)
      (and (integer? x) (or (<= #x-80000000 x #x7FFFFFFF)
                            (<= #xFFFFFFFF80000000 x #xFFFFFFFFFFFFFFFF)
                            (mistake "not a sign-extended-32-bit-representable 64-bit integer" x))))
    (define (SU64? x) (and (integer? x) (or (<= #x-8000000000000000 x #xFFFFFFFFFFFFFFFF)
                                            (mistake "not a signed or unsigned 64-bit integer" x))))
    (define (SU32? x) (and (integer? x) (or (<= #x-80000000 x #xFFFFFFFF)
                                            (mistake "not a signed or unsigned 32-bit integer" x))))
    (define (SU16? x) (and (integer? x) (or (<= #x-8000 x #xFFFF)
                                            (mistake "not a signed or unsigned 16-bit integer" x))))
    (define (SU8? x) (and (integer? x) (or (<= #x-80 x #xFF)
                                           (mistake "not a signed or unsigned 8-bit integer" x))))
    (define (Memory8?/ctx ctx x)
      (and (Memory? x) (or (eqv? (mloc-width x) 8) (mistake "memory width is not 8" x ctx))))
    (define (Location?!/ctx ctx x) (or (Register? x) (Memory8?/ctx ctx x)
                                       (mistake "not a location" x ctx)))
    (define (operation? x tag handle)
      (and (pair? x) (if (procedure? tag) (tag (car x)) (eqv? (car x) tag))
           (or (list? (cdr x)) (mistake "not a list" x)) (apply handle (cdr x))))
    (define (Binary-op?/lhs lhs rhs)
      (operation?
        rhs binop->op
        (case-lambda
          ((a b) (or (and (eqv? (car rhs) '-) (eqv? a 0) (Register?! lhs)
                          (or (equal? b lhs)
                              (mistake "set! left-hand-side is not the subtrahend" lhs rhs)))
                     (and (or (equal? a lhs) (and (eqv? (car rhs) '+) (Register? lhs) (Register? a)
                                                  (or (Register? b) (SU64/32? b)))
                              (mistake "set! left-hand-side mismatch in binary operation" lhs rhs))
                          (Location?!/ctx rhs a)
                          (or (not (Shift? (car rhs))) (U6? b) (eqv? b 'rcx)
                              (mistake "shift operand is neither a 6-bit integer nor rcx" b rhs))
                          (or (Register? b) (SU64/32? b)
                              (and (Memory8?/ctx rhs b)
                                   (or (Register? lhs) (mistake "too many memory operands" rhs)))
                              (mistake "invalid argument to binary operation" b rhs))
                          (or (not (memv (car rhs) '(* */over))) (Register? a)
                              (mistake "left operand of multiply is not a register" a rhs)))))
          (_ (mistake "operator arity mismatch" rhs)))))
    (define (Comparison? x)
      (operation? x cmpop->cc
                  (case-lambda
                    ((a b) (Location?!/ctx x a)
                           (or (SU64/32? b) (Register? b)
                               (mistake "not a register or signed 32-bit integer" b x)))
                    (_ (mistake "operator arity mismatch" x)))))
    (define (CC?! x) (or (memv x '(carry ncarry over nover)) (mistake "not a condition code" x)))
    (define (cc? x) (operation? x 'cc (case-lambda ((x) (CC?! x))
                                                   (_ (mistake "operator arity mismatch" x)))))
    (define (LEA? x) (operation? x 'lea (case-lambda
                                          ((loc) (Memory?! loc))
                                          (_ (mistake "operator arity mismatch" x)))))
    (define (CAS?/lhs lhs x)
      (operation? x 'atomic-cas
                  (case-lambda
                    ((loc expected new)
                     (and (or (Memory8?/ctx x loc) (mistake "not a memory location" loc x))
                          (or (eqv? expected 'rax)
                              (mistake "atomic-cas 'expected' operand is not rax" expected))
                          (or (eqv? lhs 'rax) (mistake "atomic-cas is not set! to rax" lhs x))
                          (Register?! new)))
                    (_ (mistake "operator arity mismatch" x)))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply
          (case (car S)
            ((set!) (lambda (lhs rhs)
                      (cond ((or (Binary-op?/lhs lhs rhs) (CAS?/lhs lhs rhs)))
                            ((Label? rhs) (Location?!/ctx S lhs))
                            ((Register? lhs) (unless (or (Register? rhs) (SU64? rhs) (Memory? rhs)
                                                         (Comparison? rhs) (cc? rhs) (LEA? rhs))
                                               (mistake "invalid set! right-hand-side" rhs)))
                            ((Memory? lhs) (unless (or (Register? rhs) (case (mloc-width lhs)
                                                                         ((8) (SU64/32? rhs))
                                                                         ((4) (SU32? rhs))
                                                                         ((2) (SU16? rhs))
                                                                         (else (SU8? rhs))))
                                             (mistake "invalid set! memory right-hand-side" rhs S)))
                            (else (mistake "not a location" lhs)))))
            ((jump-if) (lambda (x label)
                         (unless (or (Comparison? x) (cc? x)) (mistake "not a condition" x S))
                         (unless (Label? label) (mistake "not a label" label))))
            ((jump) (lambda (x) (unless (or (Label? x) (Register? x) (Memory8?/ctx S x))
                                  (mistake "not a jump target" x S))))
            ((begin) (lambda S* (for-each loop S*)))
            (else (mistake "not a Statement" S)))
          (cdr S)))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (mdefine current-cmp #f) (mdefine current-cmp-type #f)
    (define (clear-cmp!) (set! current-cmp #f))
    (define (set-cmp! cmp type) (set! current-cmp cmp) (set! current-cmp-type type))
    (define Register? symbol?)
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x)
      (cond ((integer? x) (string-append "$" (number->string (s64 x))))
            ((Register? x) (Reg x))
            ((string? x) x)
            ((mloc? x)
             (let ((b (mloc-base x)) (d (mloc-disp x)) (i (mloc-index x)) (s (mloc-shift x)))
               (string-append
                 (cond ((eqv? d 0)   "")
                       ((integer? d) (number->string d))
                       (else         d))
                 "(" (Reg b)
                 (if (eqv? i 0) "" (string-append
                                     "," (Reg i)
                                     (if (= s 0) "" (string-append
                                                      "," (number->string (bitwise-asl 1 s))))))
                 ")")))
            (else (mistake "not an operand" x))))
    (define (Operand-width x) (if (mloc? x) (mloc-width x) 8))
    (define (Instruction op . rand*)
      (emit (string-append " " op " " (string-join* "," (map Operand rand*)) "\n")))
    (define (Jump op rand)
      (emit (string-append " " op (if (Label? rand) " " " *") (Operand rand) "\n")))
    (define (Jump-cc cc label) (Instruction (string-append "j" cc) label))
    (define (Assign lhs rhs)
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (if (and (U32? rhs) (Register? lhs))
                          (if (eqv? rhs 0)
                              (Assign-0 lhs)
                              (Instruction "movl" rhs (register/width lhs 4)))
                          (Instruction "movq" rhs lhs)))
                 ((4) (Instruction "movl" rhs (register/width lhs 4)))
                 ((2) (Instruction "movzwl" rhs (register/width lhs 4)))
                 (else (Assign-zx1 lhs rhs))))
          ((4) (Instruction "movl" (x/width rhs 4) lhs))
          ((2) (Instruction "movw" (x/width rhs 2) lhs))
          (else (Instruction "movb" (x/width rhs 1) lhs)))))
    (define (Assign-0 reg) (clear-cmp!) (let ((w4 (register/width reg 4)))
                                          (Instruction "xorl" w4 w4)))
    (define (Assign-zx1 lhs x) (Instruction "movzbl" x (register/width lhs 4)))
    (define (Set-cc w1 cc) (Instruction (string-append "set" cc) w1))
    (define (Assign-cc lhs cc) (let ((w1 (register/width lhs 1)))
                                 (Set-cc w1 cc) (Assign-zx1 lhs w1)))
    (define (weak-cc cmp) (case cmp ((=) "z") ((=/=)  "nz") ((<) "s") ((>=) "ns") ((u>) "nz")
                            (else #f)))
    (define (choose-cc cmp) (if (and current-cmp (eqv? current-cmp-type 'result))
                                (weak-cc cmp)
                                (cmpop->cc cmp)))
    (define (redundant-cmp? op a b)
      (define (cmp-subsumed? op a b) (and (equal? current-cmp (cons a b))
                                          (or (eqv? current-cmp-type 'cmp)
                                              (and (eqv? current-cmp-type 'result) (weak-cc op)))))
      (case op
        ((and nand) (if (equal? a b) (cmp-subsumed? '= a 0) (and (equal? current-cmp (cons a b))
                                                                 (eqv? current-cmp-type 'test))))
        (else (cmp-subsumed? op a b))))
    (define (Compare! op a b)
      (case op
        ((and nand) (if (equal? a b)
                        (set-cmp! (cons a 0) 'cmp)
                        (set-cmp! (cons a b) 'test))
                    (cond ((and (U32? b) (Register? a))
                           (if (U8? b)  ; NOTE: we skip 16-bit to avoid 66h LCP stalls
                               (Instruction "testb" b (register/width a 1))
                               (Instruction "testl" b (register/width a 4))))
                          (else (Instruction "testq" b a))))
        (else (set-cmp! (cons a b) 'cmp)
              (if (and (eqv? b 0) (Register? a))
                  (Instruction "testq" a a)
                  (Instruction "cmpq" b a)))))
    (define (Compare op a b) (unless (redundant-cmp? op a b) (Compare! op a b)))
    (define (Cmp-op lhs op a b)
      (define (k op)
        (cond ((redundant-cmp? op a b) (Assign-cc lhs (choose-cc op)))
              ((and (not (eqv? lhs a)) (not (eqv? lhs b)))
               (Assign-0 lhs) (Compare! op a b) (Set-cc (register/width lhs 1) (choose-cc op)))
              (else (Compare! op a b) (Assign-cc lhs (choose-cc op)))))
      (if (eqv? b 0)
          (case op
            ((u>=) (Assign lhs 1))
            ((u<) (Assign lhs 0))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (Compare-jump op a b l)
      (define (k op) (Compare op a b) (Jump-cc (choose-cc op) l))
      (if (eqv? b 0)
          (case op
            ((u>=) (Jump "jmp" l))
            ((u<) (No-op))
            ((u<=) (k '=))
            ((u>) (k '=/=))
            (else (k op)))
          (k op)))
    (define (No-op) (values))
    (define (Binary-op op a b)
      (let ((iop (binop->op op)))
        (and iop (let ((simple (lambda () (Instruction iop b a)))
                       (I/a (lambda (iop) (Instruction iop a))))
                   (set-cmp! (cons a 0) 'result)
                   (case op
                     ((+ +/over) (case b ((1) (I/a "incq")) ((-1) (I/a "decq")) (else (simple))))
                     ((- -/over) (case b ((1) (I/a "decq")) ((-1) (I/a "incq")) (else (simple))))
                     ((* */over) (clear-cmp!) (if (eqv? b -1) (I/a "negq") (simple)))
                     ((xor) (cond ((eqv? b -1) (clear-cmp!) (I/a "notq"))
                                  ((eqv? a b) (Assign-0 a))
                                  (else (simple))))
                     ((and) (if (and (Register? a) (U32? b))
                                (Instruction "andl" b (register/width a 4))
                                (simple)))
                     ((asl asr lsl lsr) (unless (and (integer? b) (not (= b 0))) (clear-cmp!))
                                        (Instruction iop (if (eqv? b 'rcx) 'cl b) a))
                     (else (simple)))
                   #t))))
    (define (Assign-op2 lhs op a b)
      (cond ((and (eqv? op '+) (not (equal? a lhs)))
             (Instruction "leaq" (if (integer? b) (mloc 8 a (s64 b) 0 0) (mloc 8 a 0 b 0)) lhs))
            ((and (eqv? op '-) (eqv? a 0)) (Instruction "negq" lhs))
            (else (or (Binary-op op a b) (Cmp-op lhs op a b)))))
    (define (Assign-op1 lhs op x) (case op
                                    ((cc) (Assign-cc lhs (flagcc x)))
                                    ((lea) (Instruction "leaq" x lhs))
                                    (else (mistake "invalid operator" op))))
    (define (CAS loc new) (clear-cmp!) (Instruction "lock cmpxchgq" new loc))
    (let loop ((S P))
      (if (Label? S)
          (begin (clear-cmp!) (emit (string-append S ":\n")))
          (apply
            (case (car S)
              ((set!) (lambda (lhs rhs)
                        (cond ((Label? rhs) (Instruction "leaq" (mloc 8 'rip rhs 0 0) lhs))
                              ((pair? rhs) (apply (case-lambda
                                                    ((a b) (Assign-op2 lhs (car rhs) a b))
                                                    ((x) (Assign-op1 lhs (car rhs) x))
                                                    ((a b c) (CAS a c)))
                                                  (cdr rhs)))
                              (else (Assign lhs rhs)))))
              ((jump-if) (lambda (x l) (let ((op (car x)))
                                         (if (eqv? op 'cc)
                                             (Jump-cc (flagcc (cadr x)) l)
                                             (Compare-jump op (cadr x) (caddr x) l)))))
              ((jump) (lambda (x) (Jump "jmp" x)))
              ((begin) (lambda S* (for-each loop S*)))
              (else (mistake "not a Statement" S)))
            (cdr S))))))
