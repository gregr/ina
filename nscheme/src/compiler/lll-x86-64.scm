;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Register S64)
;;              | (set! Register Register)
;;              | (set! Register Memory)
;;              | (set! Memory S32)
;;              | (set! Memory Register)
;;              | (set! Location1 (Binary-op Location1 S32))
;;              | (set! Location1 (Binary-op Location1 Register))
;;              | (set! Register1 (Binary-op Register1 Memory8))
;;              | (set! Location1 (Shift-op Location1 U6))
;;              | (set! Location1 (Shift-op Location1 rcx))
;;              | (set! Register1 (* Register1 S32))
;;              | (set! Register1 (* Register1 Register))
;;              | (set! Register1 (* Register1 Memory8))
;;              | (set! Location Label)
;;              | (jump-when (Compare-op Location S32) Label)
;;              | (jump-when (Compare-op Location Register) Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | Label
;; Binary-op  ::= + | - | and | ior | xor  ; * destination must be a register
;; Shift-op   ::= asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; Location   ::= Register | Memory8
;; Register   ::= rax | rcx | rdx | rbx | rbp | rsi | rdi  ; omit rsp
;;              | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory     ::= (memory Width Address)
;; Memory8    ::= (memory 8 Address)
;; Address    ::= Register | (+ Register S32) | (+ Register Register)
;; Width      ::= 1 | 2 | 4 | 8
;; S64        ::= <signed 64-bit integer>
;; S32        ::= <signed 32-bit integer>
;; U6         ::= <unsigned 6-bit integer>  ; 0 through 63
;; Label      ::= <string>
(splicing-local
  ((define Label? string?)
   (define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (register/width r w)
     (case r
       ((rax) (case w ((1) 'al)   ((2) 'ax)   ((4) 'eax)))
       ((rcx) (case w ((1) 'cl)   ((2) 'cx)   ((4) 'ecx)))
       ((rdx) (case w ((1) 'dl)   ((2) 'dx)   ((4) 'edx)))
       ((rsi) (case w ((1) 'sil)  ((2) 'si)   ((4) 'esi)))
       ((rdi) (case w ((1) 'dil)  ((2) 'di)   ((4) 'edi)))
       ((r8)  (case w ((1) 'r8b)  ((2) 'r8w)  ((4) 'r8d)))
       ((r9)  (case w ((1) 'r9b)  ((2) 'r9w)  ((4) 'r9d)))
       ((r10) (case w ((1) 'r10b) ((2) 'r10w) ((4) 'r10d)))
       ((r11) (case w ((1) 'r11b) ((2) 'r11w) ((4) 'r11d)))
       ((rbx) (case w ((1) 'bl)   ((2) 'bx)   ((4) 'ebx)))
       ((rbp) (case w ((1) 'bpl)  ((2) 'bp)   ((4) 'ebp)))
       ((r12) (case w ((1) 'r12b) ((2) 'r12w) ((4) 'r12d)))
       ((r13) (case w ((1) 'r13b) ((2) 'r13w) ((4) 'r13d)))
       ((r14) (case w ((1) 'r14b) ((2) 'r14w) ((4) 'r14d)))
       ((r15) (case w ((1) 'r15b) ((2) 'r15w) ((4) 'r15d)))
       (else (mistake "not a register" r))))
   (define (x/width x w) (if (symbol? x) (register/width x w) x))
   (define (Shift? op) (memv op '(asl asr lsl lsr)))
   (define (binop->op op) (case op ((+) "addq") ((-) "subq") ((*) "imulq")
                            ((and) "andq") ((ior) "orq") ((xor) "xorq")
                            ((asl lsl) "salq") ((asr) "sarq") ((lsr) "shrq")
                            (else #f)))
   (define (cmpop->jcc op) (case op ((and) "jnz") ((nand) "jz") ((=) "je") ((=/=)  "jne")
                             ((<) "jl") ((<=) "jle") ((>) "jg") ((>=) "jge")
                             ((u<) "jb") ((u<=) "jbe") ((u>) "ja") ((u>=) "jae")
                             (else #f)))
   (define (Memory-width x) (cadr x)))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x)
      (and (pair? x) (eqv? (car x) 'memory) (list? (cdr x))
           (apply (case-lambda
                    ((width x) (unless (memv width '(1 2 4 8))
                                 (mistake "invalid memory width" width))
                               (or (Register? x)
                                   (and (pair? x) (eqv? (car x) '+) (list? (cdr x))
                                        (apply (case-lambda
                                                 ((a b) (Register?! a) (or (Register? b) (S32? b)))
                                                 (_ (mistake "operator arity mismatch" x)))
                                               (cdr x)))
                                   (mistake "invalid memory address expression" x)))
                    (_ (mistake "memory arity mismatch" x)))
                  (cdr x))))
    (define (U6? x) (and (integer? x) (or (<= 0 x 63) (mistake "not an unsigned 6-bit integer" x))))
    (define (S32? x) (and (integer? x) (or (<= -2147483648 x 2147483647)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (S64? x) (and (integer? x) (or (<= -9223372036854775808 x 9223372036854775807)
                                           (mistake "not a signed 64-bit integer" x))))
    (define (Binary-op?/lhs lhs rhs)
      (and (pair? rhs) (or (binop->op (car rhs)) (mistake "invalid binary operator" rhs))
           (or (list? (cdr rhs)) (mistake "not a list" rhs))
           (apply (case-lambda
                    ((a b)
                     (or (equal? a lhs)
                         (mistake "left-hand-side mismatch in binary operation" lhs rhs))
                     (or (Register? b) (S32? b)
                         (and (Memory? b) (or (eqv? (Memory-width b) 8)
                                              (mistake "memory width is not 8" b rhs)))
                         (mistake "invalid argument to binary operation" b rhs))
                     (or (not (Shift? (car rhs))) (U6? b) (eqv? b 'rcx)
                         (mistake "shift operand is neither a 6-bit integer nor rcx" b rhs)))
                    (_ (mistake "operator arity mismatch" rhs)))
                  (cdr rhs))))
    (define (Comparison? x)
      (and (pair? x) (or (cmpop->jcc (car x)) (mistake "invalid comparison operator" x))
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda
                    ((a b) (or (Register? a)
                               (and (Memory? a) (or (eqv? (Memory-width a) 8)
                                                    (mistake "memory width is not 8" a x)))
                               (mistake "not a location" a x))
                           (or (S32? b) (Register? b)
                               (mistake "not a register or signed 32-bit integer" b x)))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (let loop ((S P))
      (unless (Label? S)
        (apply
          (case (car S)
            ((set!) (lambda (lhs rhs)
                      (cond ((Memory? lhs)
                             (unless (or (Register? rhs) (S32? rhs)
                                         (and (Label? rhs)
                                              (or (eqv? (Memory-width lhs) 8)
                                                  (mistake "label set! memory width is not 8" S)))
                                         (and (Binary-op?/lhs lhs rhs)
                                              (or (eqv? (Memory-width lhs) 8)
                                                  (mistake "binary op set! memory width is not 8" S))
                                              (or (not (eqv? (car rhs) '*))
                                                  (mistake "memory left-hand-side of *" S))
                                              (or (not (Memory? (caddr rhs)))
                                                  (mistake "too many memory operands" S))))
                               (mistake "invalid set! right-hand-side for memory" S)))
                            ((Register? lhs) (unless (or (Register? rhs) (S64? rhs) (Label? rhs)
                                                         (Memory? rhs) (Binary-op?/lhs lhs rhs))
                                               (mistake "invalid set! right-hand-side" rhs)))
                            (else (mistake "not a location" lhs)))))
            ((jump-when) (lambda (cmp label)
                           (unless (Comparison? cmp) (mistake "not a comparison" cmp))
                           (unless (Label? label) (mistake "not a label" label))))
            ((jump) (lambda (x)
                      (unless (or (Label? x) (Register? x)
                                  (and (Memory? x)
                                       (or (eqv? (Memory-width x) 8)
                                           (mistake "jump target memory width is not 8" S))))
                        (mistake "not a jump target" x S))))
            ((begin) (lambda S* (for-each loop S*)))
            (else (mistake "not a Statement" S)))
          (cdr S)))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x)
      (cond ((integer? x) (string-append "$" (number->string x)))
            ((symbol? x) (Reg x))
            ((string? x) x)
            ((eqv? (car x) 'memory)
             (let ((x (caddr x)))
               (if (symbol? x)
                   (string-append "(" (Reg x) ")")
                   (let ((a (cadr x)) (b (caddr x)))
                     (cond ((symbol? b) (string-append "(" (Reg a) "," (Reg b) ")"))
                           ((integer? b) (string-append (number->string b) "(" (Reg a) ")"))
                           (else (string-append b "(" (Reg a) ")")))))))
            (else (mistake "not an operand" x))))
    (define (Operand-width x) (if (pair? x) (Memory-width x) 8))
    (define (Instruction op . rand*)
      (string-append " " op " " (string-join* "," (map Operand rand*)) "\n"))
    (define (Assign lhs rhs)
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (Instruction "movq" rhs lhs))
                 ((4) (Instruction "movl" rhs (register/width lhs 4)))
                 ((2) (Instruction "movzwl" rhs (register/width lhs 4)))
                 (else (Instruction "movzbl" rhs (register/width lhs 4)))))
          ((4) (Instruction "movl" (x/width rhs 4) lhs))
          ((2) (Instruction "movw" (x/width rhs 2) lhs))
          (else (Instruction "movb" (x/width rhs 1) lhs)))))
    (define (Binary-op binop a b)
      (Instruction (binop->op binop) (if (and (eqv? b 'rcx) (Shift? binop)) 'cl b) a))
    (let loop ((S P))
      (if (Label? S)
          (emit (string-append S ":\n"))
          (apply
            (case (car S)
              ((set!) (lambda (lhs rhs)
                        (emit (cond ((Label? rhs) (Instruction "leaq" `(memory 8 (+ rip ,rhs)) lhs))
                                    ((and (pair? rhs) (not (eqv? (car rhs) 'memory)))
                                     (apply (lambda (a b) (Binary-op (car rhs) a b)) (cdr rhs)))
                                    (else (Assign lhs rhs))))))
              ((jump-when) (lambda (cmp label)
                             (let* ((cmpop (car cmp))
                                    (tcop (case cmpop ((and nand) "testq") (else "cmpq"))))
                               (emit (Instruction tcop (caddr cmp) (cadr cmp)))
                               (emit (Instruction (cmpop->jcc cmpop) label)))))
              ((jump) (lambda (x) (emit (if (Label? x)
                                            (Instruction "jmp" x)
                                            (string-append " jmp *" (Operand x) "\n")))))
              ((begin) (lambda S* (for-each loop S*)))
              (else (mistake "not a Statement" S)))
            (cdr S))))))
