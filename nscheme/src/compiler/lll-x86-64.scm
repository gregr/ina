;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement  ::= (begin Statement ...)
;;              | (set! Register S64)
;;              | (set! Register Register)
;;              | (set! Register Memory)
;;              | (set! Memory S32)
;;              | (set! Memory Register)
;;              | (set! Location1 (Binary-op Location1 S32))
;;              | (set! Location1 (Binary-op Location1 Register))
;;              | (set! Register1 (Binary-op Register1 Memory8))
;;              | (set! Location1 (Shift-op Location1 U6))
;;              | (set! Location1 (Shift-op Location1 rcx))
;;              | (set! Register1 (* Register1 S32))
;;              | (set! Register1 (* Register1 Location))
;;              | (set! Register Comparison)
;;              | (set! rax (atomic-cas Memory8 rax Register))
;;              | (set! Location Label)
;;              | (jump-if Comparison Label)
;;              | (jump Label)
;;              | (jump Location)
;;              | (call Label)
;;              | (call Location)
;;              | Label
;; Binary-op  ::= + | - | and | ior | xor  ; * destination must be a register
;; Shift-op   ::= asl | asr | lsl | lsr
;; Compare-op ::= and | nand | = | =/= | < | <= | > | >= | u< | u<= | u> | u>=
;; Comparison ::= (Compare-op Location S32)
;;              | (Compare-op Location Register)
;; Location   ::= Register | Memory8
;; Register   ::= rax | rcx | rdx | rsi | rdi | rbx | rbp | rsp
;;              | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory     ::= #(mloc Width Register S32 Index)
;; Memory8    ::= #(mloc 8     Register S32 Index)
;; Index      ::= Register | 0
;; Width      ::= 1 | 2 | 4 | 8
;; S64        ::= <signed 64-bit integer>
;; S32        ::= <signed 32-bit integer>
;; U6         ::= <unsigned 6-bit integer>  ; 0 through 63
;; Label      ::= <string>
(splicing-local
  ((define Label? string?)
   (define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp rsp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (register/width r w)
     (case r
       ((rax) (case w ((1) 'al)   ((2) 'ax)   ((4) 'eax)))
       ((rcx) (case w ((1) 'cl)   ((2) 'cx)   ((4) 'ecx)))
       ((rdx) (case w ((1) 'dl)   ((2) 'dx)   ((4) 'edx)))
       ((rsi) (case w ((1) 'sil)  ((2) 'si)   ((4) 'esi)))
       ((rdi) (case w ((1) 'dil)  ((2) 'di)   ((4) 'edi)))
       ((r8)  (case w ((1) 'r8b)  ((2) 'r8w)  ((4) 'r8d)))
       ((r9)  (case w ((1) 'r9b)  ((2) 'r9w)  ((4) 'r9d)))
       ((r10) (case w ((1) 'r10b) ((2) 'r10w) ((4) 'r10d)))
       ((r11) (case w ((1) 'r11b) ((2) 'r11w) ((4) 'r11d)))
       ((rbx) (case w ((1) 'bl)   ((2) 'bx)   ((4) 'ebx)))
       ((rbp) (case w ((1) 'bpl)  ((2) 'bp)   ((4) 'ebp)))
       ((r12) (case w ((1) 'r12b) ((2) 'r12w) ((4) 'r12d)))
       ((r13) (case w ((1) 'r13b) ((2) 'r13w) ((4) 'r13d)))
       ((r14) (case w ((1) 'r14b) ((2) 'r14w) ((4) 'r14d)))
       ((r15) (case w ((1) 'r15b) ((2) 'r15w) ((4) 'r15d)))
       (else (mistake "not a register" r))))
   (define (x/width x w) (if (symbol? x) (register/width x w) x))
   (define (Shift? op) (memv op '(asl asr lsl lsr)))
   (define (binop->op op) (case op ((+) "addq") ((-) "subq") ((*) "imulq")
                            ((and) "andq") ((ior) "orq") ((xor) "xorq")
                            ((asl lsl) "salq") ((asr) "sarq") ((lsr) "shrq")
                            (else #f)))
   (define (cmpop->cc op) (case op ((and) "nz") ((nand) "z") ((=) "e") ((=/=)  "ne")
                            ((<) "l") ((<=) "le") ((>) "g") ((>=) "ge")
                            ((u<) "b") ((u<=) "be") ((u>) "a") ((u>=) "ae")
                            (else #f)))
   (define (cmpop->test op) (case op ((and nand) "testq") (else "cmpq"))))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x) (and (mloc? x) (or (memv (mloc-width x) '(8 4 2 1))
                                           (mistake "invalid mloc width" x))
                             (Register?! (mloc-base x))
                             (or (S32? (mloc-disp x)) (mistake "mloc with invalid displacement" x))
                             (or (eqv? (mloc-index x) 0) (Register? (mloc-index x))
                                 (mistake "mloc with invalid index" x))))
    (define (U6? x) (and (integer? x) (or (<= 0 x 63) (mistake "not an unsigned 6-bit integer" x))))
    (define (S32? x) (and (integer? x) (or (<= (- #x80000000) x #x7FFFFFFF)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (S64? x) (and (integer? x) (or (<= (- #x8000000000000000) x #x7FFFFFFFFFFFFFFF)
                                           (mistake "not a signed 64-bit integer" x))))
    (define (Memory8?/ctx ctx x)
      (and (Memory? x) (or (eqv? (mloc-width x) 8) (mistake "memory width is not 8" x ctx))))
    (define (Binary-op?/lhs lhs rhs)
      (and (pair? rhs) (binop->op (car rhs))
           (or (list? (cdr rhs)) (mistake "not a list" rhs))
           (apply (case-lambda
                    ((a b)
                     (or (equal? a lhs)
                         (mistake "left-hand-side mismatch in binary operation" lhs rhs))
                     (or (Register? b) (S32? b) (Memory8?/ctx rhs b)
                         (mistake "invalid argument to binary operation" b rhs))
                     (or (not (Shift? (car rhs))) (U6? b) (eqv? b 'rcx)
                         (mistake "shift operand is neither a 6-bit integer nor rcx" b rhs)))
                    (_ (mistake "operator arity mismatch" rhs)))
                  (cdr rhs))))
    (define (Comparison? x)
      (and (pair? x) (cmpop->cc (car x))
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda
                    ((a b) (or (Register? a) (Memory8?/ctx x a) (mistake "not a location" a x))
                           (or (S32? b) (Register? b)
                               (mistake "not a register or signed 32-bit integer" b x)))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (define (CAS?/lhs lhs x)
      (and (pair? x) (eqv? (car x) 'atomic-cas)
           (or (list? (cdr x)) (mistake "not a list" x))
           (apply (case-lambda
                    ((loc expected new)
                     (and (or (Memory8?/ctx x loc) (mistake "not a memory location" loc x))
                          (Register?! new)
                          (or (eqv? expected 'rax)
                              (mistake "atomic-cas 'expected' operand is not rax" expected))
                          (or (eqv? lhs 'rax) (mistake "set! left-hand-side is not rax" lhs x))))
                    (_ (mistake "operator arity mismatch" x)))
                  (cdr x))))
    (let loop ((S P))
      (unless (Label? S)
        (unless (and (pair? S) (list? (cdr S))) (mistake "not a Statement" S))
        (apply
          (case (car S)
            ((set!) (lambda (lhs rhs)
                      (cond ((Memory? lhs)
                             (unless (or (Register? rhs) (S32? rhs)
                                         (and (Label? rhs)
                                              (or (eqv? (mloc-width lhs) 8)
                                                  (mistake "label set! memory width is not 8" S)))
                                         (and (Binary-op?/lhs lhs rhs)
                                              (or (eqv? (mloc-width lhs) 8)
                                                  (mistake "binary op set! memory width is not 8" S))
                                              (or (not (eqv? (car rhs) '*))
                                                  (mistake "memory left-hand-side of *" S))
                                              (or (not (Memory? (caddr rhs)))
                                                  (mistake "too many memory operands" S))))
                               (mistake "invalid set! right-hand-side for memory" S)))
                            ((Register? lhs) (unless (or (Register? rhs) (S64? rhs) (Label? rhs)
                                                         (Memory? rhs) (Binary-op?/lhs lhs rhs)
                                                         (Comparison? rhs) (CAS?/lhs lhs rhs))
                                               (mistake "invalid set! right-hand-side" rhs)))
                            (else (mistake "not a location" lhs)))))
            ((jump-if) (lambda (cmp label)
                         (unless (Comparison? cmp) (mistake "not a comparison" cmp))
                         (unless (Label? label) (mistake "not a label" label))))
            ((jump) (lambda (x) (unless (or (Label? x) (Register? x) (Memory8?/ctx S x))
                                  (mistake "not a jump target" x S))))
            ((call) (lambda (rator)
                      (unless (or (Label? rator) (Register? rator) (Memory8?/ctx S rator))
                        (mistake "not callable" rator))))
            ((begin) (lambda S* (for-each loop S*)))
            (else (mistake "not a Statement" S)))
          (cdr S)))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x)
      (cond ((integer? x) (string-append "$" (number->string x)))
            ((symbol? x) (Reg x))
            ((string? x) x)
            ((mloc? x) (let ((base (mloc-base x)) (disp (mloc-disp x)) (idx (mloc-index x)))
                         (string-append (cond ((eqv? disp 0)   "")
                                              ((integer? disp) (number->string disp))
                                              (else            disp))
                                        "(" (Reg base)
                                        (if (eqv? idx 0) "" (string-append "," (Reg idx))) ")")))
            (else (mistake "not an operand" x))))
    (define (Operand-width x) (if (mloc? x) (mloc-width x) 8))
    (define (Instruction op . rand*)
      (string-append " " op " " (string-join* "," (map Operand rand*)) "\n"))
    (define (Jump-instruction op rand)
      (string-append " " op (if (Label? rand) " " " *") (Operand rand) "\n"))
    (define (Assign lhs rhs)
      (let ((wl (Operand-width lhs)) (wr (Operand-width rhs)))
        (case wl
          ((8) (case wr
                 ((8) (Instruction "movq" rhs lhs))
                 ((4) (Instruction "movl" rhs (register/width lhs 4)))
                 ((2) (Instruction "movzwl" rhs (register/width lhs 4)))
                 (else (Instruction "movzbl" rhs (register/width lhs 4)))))
          ((4) (Instruction "movl" (x/width rhs 4) lhs))
          ((2) (Instruction "movw" (x/width rhs 2) lhs))
          (else (Instruction "movb" (x/width rhs 1) lhs)))))
    (define (Binary-op op a b)
      (let ((op (binop->op op)))
        (and op (Instruction op (if (and (eqv? b 'rcx) (Shift? op)) 'cl b) a))))
    (define (Cmp-op lhs op a b)
      (let ((lhs.w1 (register/width lhs 1)))
        (string-append (Instruction (cmpop->test op) b a)
                       (Instruction (string-append "set" (cmpop->cc op)) lhs.w1)
                       (Instruction "movzbl" lhs.w1 (register/width lhs 4)))))
    (define (CAS loc new) (Instruction "lock cmpxchgq" new loc))
    (let loop ((S P))
      (if (Label? S)
          (emit (string-append S ":\n"))
          (apply
            (case (car S)
              ((set!) (lambda (lhs rhs)
                        (emit (cond ((Label? rhs) (Instruction "leaq" `#(mloc 8 rip ,rhs 0) lhs))
                                    ((pair? rhs) (apply (case-lambda
                                                          ((a b) (let ((op (car rhs)))
                                                                   (or (Binary-op op a b)
                                                                       (Cmp-op lhs op a b))))
                                                          ((a b c) (CAS a c)))
                                                        (cdr rhs)))
                                    (else (Assign lhs rhs))))))
              ((jump-if) (lambda (cmp label)
                           (let ((op (car cmp)))
                             (emit (Instruction (cmpop->test op) (caddr cmp) (cadr cmp)))
                             (emit (Instruction (string-append "j" (cmpop->cc op)) label)))))
              ((jump) (lambda (x) (emit (Jump-instruction "jmp" x))))
              ((call) (lambda (x) (emit (Jump-instruction "call" x))))
              ((begin) (lambda S* (for-each loop S*)))
              (else (mistake "not a Statement" S)))
            (cdr S))))))
