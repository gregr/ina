;;;;;;;;;;;;;;;;;;;;;;
;;; LLL for x86-64 ;;;
;;;;;;;;;;;;;;;;;;;;;;
;; Statement ::= (begin Statement ...)
;;             | (set! Register S64)
;;             | (set! Register Register)
;;             | (set! Register Memory)
;;             | (set! Memory S32)
;;             | (set! Memory Register)
;;             | (set! Register1 (Binary-op Register1 S32))
;;             | (set! Register1 (Binary-op Register1 Register))
;;             | (set! Register1 (Binary-op Register1 (memory 8 Address)))
;; Binary-op ::= + | - | *
;; Register  ::= rax | rcx | rdx | rbx | rbp | rsi | rdi  ; omit rsp
;;             | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
;; Memory    ::= (memory Width Address)
;; Address   ::= Register | (+ Register S32) | (+ Register Register)
;; Width     ::= 8
;; S64       ::= <signed 64-bit integer>
;; S32       ::= <signed 32-bit integer>
(splicing-local
  ((define register*.caller-saved '(rax rcx rdx rsi rdi r8 r9 r10 r11))
   (define register*.callee-saved '(rbx rbp r12 r13 r14 r15))
   (define register* (append register*.caller-saved register*.callee-saved))
   (define (binop->op op) (case op ((+) "addq") ((-) "subq") ((*) "imulq") (else #f))))

  (define (LLL-validate-x86-64 P)
    (define (Register? x) (and (symbol? x) (or (memv x register*) (mistake "invalid register" x))))
    (define (Register?! x) (or (Register? x) (mistake "not a register" x)))
    (define (Memory? x)
      (and (pair? x) (eqv? (car x) 'memory) (list? (cdr x))
           (apply (case-lambda
                    ((width x) (unless (eqv? width 8) (mistake "invalid memory width" width))
                               (or (Register? x)
                                   (and (pair? x) (eqv? (car x) '+) (list? (cdr x))
                                        (apply (case-lambda
                                                 ((a b) (Register?! a) (or (Register? b) (S32? b)))
                                                 (_ (mistake "operator arity mismatch" x)))
                                               (cdr x)))
                                   (mistake "invalid memory address expression" x)))
                    (_ (mistake "memory arity mismatch" x)))
                  (cdr x))))
    (define (S32? x) (and (integer? x) (or (<= -2147483648 x 2147483647)
                                           (mistake "not a signed 32-bit integer" x))))
    (define (S64? x) (and (integer? x) (or (<= -9223372036854775808 x 9223372036854775807)
                                           (mistake "not a signed 64-bit integer" x))))
    (define (Binary-op?/lhs lhs rhs)
      (and (pair? rhs) (or (binop->op (car rhs)) (mistake "invalid binary operator" rhs))
           (or (list? (cdr rhs)) (mistake "not a list" rhs))
           (apply (case-lambda
                    ((a b)
                     (or (equal? a lhs)
                         (mistake "left-hand-side mismatch in binary operation" lhs rhs))
                     (or (Register? b) (S32? b) (Memory? b)
                         (mistake "invalid argument to binary operation" b rhs)))
                    (_ (mistake "operator arity mismatch" rhs)))
                  (cdr rhs))))
    (let loop ((S P))
      (apply
        (case (car S)
          ((set!) (lambda (lhs rhs)
                    (cond ((Memory? lhs) (unless (or (Register? rhs) (S32? rhs))
                                           (mistake "invalid set! right-hand-side for memory" S)))
                          ((Register? lhs) (unless (or (Register? rhs) (S64? rhs) (Memory? rhs)
                                                       (Binary-op?/lhs lhs rhs))
                                             (mistake "invalid set! right-hand-side" rhs)))
                          (else (mistake "not a location" lhs)))))
          ((begin) (lambda S* (for-each loop S*)))
          (else (mistake "not a Statement" S)))
        (cdr S))))

  (define (LLL-emit-x86-64-at&t P)
    (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
    (define (Reg x) (string-append "%" (symbol->string x)))
    (define (Operand x) (cond ((integer? x) (string-append "$" (number->string x)))
                              ((symbol? x) (Reg x))
                              ((eqv? (car x) 'memory)
                               (let ((x (caddr x)))
                                 (if (symbol? x)
                                     (string-append "(" (Reg x) ")")
                                     (let ((a (cadr x)) (b (caddr x)))
                                       (if (symbol? b)
                                           (string-append "(" (Reg a) "," (Reg b) ")")
                                           (string-append (number->string b) "(" (Reg a) ")"))))))
                              (else (mistake "not an operand" x))))
    (define (Instruction op . rand*)
      (string-append " " op " " (string-join* "," (map Operand rand*)) "\n"))
    (let loop ((S P))
      (apply (case (car S)
               ((set!) (lambda (lhs rhs)
                         (if (and (pair? rhs) (not (eqv? (car rhs) 'memory)))
                             (apply (lambda (a b) (emit (Instruction (binop->op (car rhs)) b a)))
                                    (cdr rhs))
                             (emit (Instruction "movq" rhs lhs)))))
               ((begin) (lambda S* (for-each loop S*)))
               (else (mistake "not a Statement" S)))
             (cdr S)))))
