;;;;;;;;;;;;;;;;;
;;; LLL for C ;;;
;;;;;;;;;;;;;;;;;
(define LLL-C-options-gcc "-fno-strict-aliasing")
(define LLL-C-prelude
  ##eos"typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef signed char s8;
typedef signed short s16;
typedef signed int s32;
typedef signed long long s64;
static inline u64 LLL_atomic_cas(u64* loc, u64 expected, u64 new) {
__atomic_compare_exchange_n(loc, &expected, new, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);
return expected; }
"eos##)
(define LLL-C-prelude-local "u64 LLL_flag_carry, LLL_flag_over;")

(define (LLL-emit-C P)
  (define u64-suffix "ull")
  (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
  (define Label? string?)
  (define (width->type w) (case w ((1) "u8") ((2) "u16") ((4) "u32") (else "u64")))
  (define (width-cast x) (let ((w (if (mloc? x) (mloc-width x) 8)))
                           (if (eqv? w 8) "" (string-append "(" (width->type w) ")"))))
  (define (Ref x)
    (define (addend x) (if (eqv? x 0) "" (string-append " + " (Subexpr x))))
    (string-append "(" (width->type (mloc-width x)) "*)(" (Subexpr (mloc-base x))
                   (addend (mloc-disp x)) (addend (mloc-index x)) ")"))
  (define (Location x)
    (if (symbol? x) (symbol->string x) (and (mloc? x) (string-append "*" (Ref x)))))
  (define (S64 x) (and (integer? x) (string-append (number->string x) u64-suffix)))
  (define (Binary-op x)
    (let ((op (car x)) (a (Subexpr (cadr x))) (b (Subexpr (caddr x))))
      (case op
        ((+ - *)   (string-append a " " (symbol->string op) " " b))
        ((and)     (string-append a " & " b))
        ((ior)     (string-append a " | " b))
        ((xor)     (string-append a " ^ " b))
        ((asl lsl) (string-append a " << " b))
        ((lsr)     (string-append a " >> " b))
        ((asr)     (string-append "((s64)" a ") < 0 ? " "~(~" a " >> " b ")" " : " a " >> " b))
        ((and)     (string-append "(" a " & " b ") != 0"))
        ((nand)    (string-append "(" a " & " b ") == 0"))
        ((=)       (string-append a " == " b))
        ((=/=)     (string-append a " != " b))
        ((<)       (string-append "(s64)" a " < (s64)" b))
        ((<=)      (string-append "(s64)" a " <= (s64)" b))
        ((>)       (string-append "(s64)" a " > (s64)" b))
        ((>=)      (string-append "(s64)" a " >= (s64)" b))
        ((u<)      (string-append a " < " b))
        ((u<=)     (string-append a " <= " b))
        ((u>)      (string-append a " > " b))
        ((u>=)     (string-append a " >= " b))
        (else (mistake "invalid binary operator" x)))))
  (define (Subexpr x) (if (pair? x) (string-append "(" (Expr x) ")") (Expr x)))
  (define (Expr x) (or (Location x) (S64 x) (Binary-op x)))
  (define (Call x) (let ((rator (car x)) (rand* (cdr x)))
                     (string-append (if (Label? rator) rator (Subexpr rator))
                                    "(" (string-join* "," (map Expr rand*)) ")")))
  (define (CC x) (case x
                   ((carry)  "LLL_flag_carry")
                   ((ncarry) "!LLL_flag_carry")
                   ((over)   "LLL_flag_overflow")
                   ((nover)  "!LLL_flag_overflow")
                   (else #f)))
  (define (Assign lhs x)
    (define (simple rhs) (string-append " " (Location lhs) " = " (width-cast lhs) rhs ";\n"))
    (define (overflow f op x) (let ((a (Expr (car x))) (b (Expr (cadr x))))
                                (string-append " LLL_flag_" f " = __builtin_" op "ll_overflow("
                                               a "," b ",&" (Location lhs) ");\n")))
    (cond ((Label? x) (simple (string-append "(u64*)&&" x)))
          ((or (Location x) (S64 x)) => simple)
          ((case (car x)
             ((call) (Call (cdr x)))
             ((cc) (or (CC (cadr x)) (mistake "not a condition code" (cadr x))))
             ((addc subc) (let ((a (Expr (cadr x))) (b (Expr (caddr x))))
                            (string-append "__builtin_" (if (eqv? (car x) 'addc) "add" "sub")
                                           "cll(" a "," b ",LLL_flag_carry,&LLL_flag_carry);")))
             ((atomic-cas)
              (let* ((x (cdr x)) (loc (car x)) (x (cdr x)) (expected (car x)) (new (cadr x)))
                (string-append "LLL_atomic_cas(" (Ref loc) "," (Expr expected) "," (Expr new) ")")))
             (else #f)) => simple)
          (else (case (car x)
                  ((+/carry) (overflow "carry" "uadd" (cdr x)))
                  ((-/carry) (overflow "carry" "usub" (cdr x)))
                  ((+/over) (overflow "overflow" "sadd" (cdr x)))
                  ((-/over) (overflow "overflow" "ssub" (cdr x)))
                  ((*/over) (overflow "overflow" "smul" (cdr x)))
                  (else (simple (Binary-op x)))))))
  (define (Condition x) (if (and (pair? x) (eqv? (car x) 'cc)) (CC (cadr x)) (Expr x)))
  (let loop ((S P))
    (if (Label? S)
        (emit (string-append S ":\n"))
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs) (emit (Assign lhs rhs))))
                 ((jump-if) (lambda (x label)
                              (emit (string-append " if (" (Condition x) ") goto " label ";\n"))))
                 ((jump) (lambda (x) (emit (if (Label? x)
                                               (string-append " goto " x ";\n")
                                               (string-append " goto *(void*)(" (Expr x) ");\n")))))
                 ((call) (lambda _ (emit (string-append " " (Call (cdr S)) ";\n"))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (mistake "not a Statement" S)))
               (cdr S)))))
