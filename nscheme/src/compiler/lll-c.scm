;;;;;;;;;;;;;;;;;
;;; LLL for C ;;;
;;;;;;;;;;;;;;;;;
(define (LLL-emit-C P)
  (define emit (let ((out (current-output-port))) (lambda (line) (display line out))))
  (define Label? string?)
  (define (Location x) (if (symbol? x)
                           (symbol->string x)
                           (and (pair? x) (eqv? (car x) 'memory)
                                (let ((type (case (cadr x)
                                              ((1) "unsigned char")
                                              ((2) "unsigned short")
                                              ((4) "unsigned int")
                                              (else "long"))))
                                  (string-append "*(" type "*)(" (Expr (caddr x)) ")")))))
  (define (Expr x)
    (define (Subexpr x) (if (pair? x) (string-append "(" (Expr x) ")") (Expr x)))
    (cond ((Location x))
          ((integer? x) (string-append (number->string x) "L"))
          (else (string-append (Subexpr (cadr x)) " " (symbol->string (car x)) " "
                               (Subexpr (caddr x))))))
  (let loop ((S P))
    (if (Label? S)
        (emit (string-append S ":\n"))
        (apply (case (car S)
                 ((set!) (lambda (lhs rhs)
                           (emit (if (Label? rhs)
                                     (string-append (Location lhs) " = (long*)&&" rhs ";\n")
                                     (string-append (Location lhs) " = " (Expr rhs) ";\n")))))
                 ((jump) (lambda (x) (emit (if (Label? x)
                                               (string-append "goto " x ";\n")
                                               (string-append "goto *(void*)(" (Expr x) ");\n")))))
                 ((begin) (lambda S* (for-each loop S*)))
                 (else (mistake "not a Statement" S)))
               (cdr S)))))
