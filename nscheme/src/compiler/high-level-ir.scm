(define (make-address name note) (vector (mvector) name note))
(define (address-name addr)      (vector-ref addr 1))
(define (address-note addr)      (vector-ref addr 2))
(define (address=?    a b)       (eqv? (vector-ref a 0) (vector-ref b 0)))
(define (address->local-gensym/default name.default)
  (let ((gensym (make-local-gensym)))
    (lambda (addr) (gensym (or (address-name addr) name.default)))))

(define (E:quote        v)              (vector 'E:quote        #f v))
(define (E:ref          address)        (vector 'E:ref          #f address))
(define (E:if           c t f)          (vector 'E:if           #f c t f))
(define (E:call         rator rand*)    (vector 'E:call         #f rator rand*))
(define (E:apply/values rator vrand)    (vector 'E:apply/values #f rator vrand))
(define (E:case-lambda  param*~* body*) (vector 'E:case-lambda  #f param*~* body*))
(define (E:letrec       lhs* rhs* body) (vector 'E:letrec       #f lhs* rhs* body))

(splicing-local
  ((define (E-tagged? E len tag)
     (and (vector? E) (= (vector-length E) len) (eqv? (vector-ref E 0) tag))))
  (define (E:quote?        E) (E-tagged? E 3 'E:quote))
  (define (E:ref?          E) (E-tagged? E 3 'E:ref))
  (define (E:if?           E) (E-tagged? E 5 'E:if))
  (define (E:call?         E) (E-tagged? E 4 'E:call))
  (define (E:apply/values? E) (E-tagged? E 4 'E:apply/values))
  (define (E:case-lambda?  E) (E-tagged? E 4 'E:case-lambda))
  (define (E:letrec?       E) (E-tagged? E 5 'E:letrec)))
(define (E-note E) (vector-ref E 1))
(define (E-annotate E note)
  (case (vector-length E)
    ((3) (vector (vector-ref E 0) note (vector-ref E 2)))
    ((4) (vector (vector-ref E 0) note (vector-ref E 2) (vector-ref E 3)))
    ((5) (vector (vector-ref E 0) note (vector-ref E 2) (vector-ref E 3) (vector-ref E 4)))
    (else (mistake 'E-annotate "not an E" E))))

(define (E-case  E kf . ?h*) (E-case* E kf ?h*))
(define (E-case* E kf ?h*)   (let ((?h* (pmemp (lambda (?) (? E)) ?h*)))
                               (if ?h* (apply (cadr ?h*) (vector->list E 2)) (kf E))))

(define (E-pretty E)
  (define address-pretty address-name)
  (let loop ((E E))
    (E-case
      E (lambda (E) (mistake 'E-pretty "not an E" E))
      E:quote?        (lambda (v)           (list 'quote v))
      E:ref?          (lambda (addr)        (list 'ref (address-pretty addr)))
      E:if?           (lambda (c t f)       (list 'if (loop c) (loop t) (loop f)))
      E:call?         (lambda (rator rand*) (cons* 'call (loop rator) (map loop rand*)))
      E:apply/values? (lambda (rator vrand) (list 'apply/values (loop rator) (loop vrand)))
      E:case-lambda?  (lambda (param*~* body*)
                        (cons 'case-lambda
                              (map (lambda (p*~ body) (list (improper-list-map address-pretty p*~) (loop body)))
                                   param*~* body*)))
      E:letrec?       (lambda (lhs* rhs* body)
                        (list 'letrec (map (lambda (lhs rhs) (list (address-pretty lhs) (loop rhs))) lhs* rhs*)
                              (loop body))))))

(define (E-eval E)
  (let ((primitive-evaluate (current-primitive-evaluate)))
    (let loop ((code-type* (primitive-evaluate)))
      (cond ((memv 'rkt-expr code-type*) (primitive-evaluate 'rkt-expr (E-compile-rkt E '()) loop))
            (else                        (E-eval-direct E))))))
(splicing-local
  ((define (param-arity param)
     (let loop ((param param) (arity 0))
       (cond ((null? param) arity)
             ((pair? param) (loop (cdr param) (+ arity 1)))
             (else          (- (+ arity 1))))))
   (define renv.empty '())
   (define (make-renv-extend arity count)
     (and (if (< arity 0)
              (<= (- (+ arity 1)) count)
              (= arity count))
          (lambda (renv args) (cons args renv))))
   (define cenv.empty '())
   (define (cenv-ref cenv addr)
     (let loop ((j 0) (cenv.1 cenv))
       (when (null? cenv.1) (mistake 'E-eval "unbound or out-of-phase reference" addr))
       (let ((rec? (caar cenv.1)) (param*~ (cdar cenv.1)) (cenv (cdr cenv.1)))
         (let find ((i 0) (a*~ param*~))
           (cond ((pair? a*~) (let ((a (car a*~)) (a*~ (cdr a*~)))
                                (if (address=? a addr)
                                    (if rec?
                                        (lambda (renv) (unbox (list-ref (list-ref renv j) i)))
                                        (lambda (renv) (list-ref (list-ref renv j) i)))
                                    (find (+ i 1) a*~))))
                 ((and (not (null? a*~)) (address=? a*~ addr))
                  (when rec? (mistake 'E-eval "recursive frame cannot be variadic" cenv.1))
                  (lambda (renv) (list-tail (list-ref renv j) i)))
                 (else (loop (+ j 1) cenv)))))))
   (define (cenv-extend      cenv param*~)      (cenv-extend/rec? cenv param*~ #f))
   (define (cenv-extend-rec  cenv param*~)      (cenv-extend/rec? cenv param*~ #t))
   (define (cenv-extend/rec? cenv param*~ rec?) (cons (cons rec? param*~) cenv))
   (define (E-stage E cenv)
     (let loop/env ((E E) (cenv cenv))
       (define (loop E) (loop/env E cenv))
       (E-case
         E (lambda (E) (mistake 'E-eval "not an E" E))
         E:quote?        (lambda (v)           (lambda (renv) v))
         E:ref?          (lambda (addr)        (cenv-ref cenv addr))
         E:if?           (lambda (c t f)       (let ((c (loop c)) (t (loop t)) (f (loop f)))
                                                 (lambda (renv) (if (c renv) (t renv) (f renv)))))
         E:call?         (lambda (rator rand*) (let ((rator (loop rator)) (rand* (map loop rand*)))
                                                 (lambda (renv) (apply (rator renv) (map (lambda (r) (r renv)) rand*)))))
         E:apply/values? (lambda (rator vrand) (let ((rator (loop rator)) (vrand (loop vrand)))
                                                 (lambda (renv) (apply/values (rator renv) (vrand renv)))))
         E:case-lambda?  (lambda (param*~* body*)
                           (let ((k (fold-right
                                      (lambda (k param body)
                                        (let* ((cenv  (cenv-extend cenv param))
                                               (body  (loop/env body cenv))
                                               (arity (param-arity param)))
                                          (lambda (renv count args)
                                            (let ((renv-extend (make-renv-extend arity count)))
                                              (if renv-extend
                                                  (body (renv-extend renv args))
                                                  (k renv count args))))))
                                      (lambda (renv count args)
                                        (mistake 'E-eval "arity mismatch" 'given count 'expected param*~*))
                                      param*~* body*)))
                             (lambda (renv) (lambda args (k renv (length args) args)))))
         E:letrec?       (lambda (param rhs* body)
                           (let* ((arity       (param-arity param))
                                  (renv-extend (make-renv-extend arity (length param)))
                                  (body        (loop/env body (cenv-extend cenv param)))
                                  (cenv        (cenv-extend-rec cenv param))
                                  (arg*        (map (lambda (rhs) (loop/env rhs cenv)) rhs*)))
                             (lambda (renv) (let ((loc* (map (lambda (_) (box #t)) arg*)))
                                              (let ((renv (renv-extend renv loc*)))
                                                (for-each (lambda (loc arg) (set-box! loc (arg renv))) loc* arg*))
                                              (body (renv-extend renv (map unbox loc*)))))))))))
  (define (E-eval-direct E) ((E-stage E cenv.empty) renv.empty)))
