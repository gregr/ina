#lang racket/base
(provide (all-defined-out))
(require
  "../platform/racket/nscheme.rkt"
  racket/include racket/local racket/runtime-path racket/splicing (prefix-in rkt: racket/base))
(include "../src/base/misc.scm")
(include "../src/base/list.scm")
(include "../src/base/number.scm")
(include "../src/base/mvector.scm")
(include "../src/base/vector.scm")
(include "../src/base/mbytevector.scm")
(include "../src/base/bytevector.scm")
(include "../src/base/unicode.scm")
(include "../src/base/prompt.scm")
(include "../src/base/exception.scm")
(include "../src/base/coroutine.scm")
(include "../src/base/generator.scm")
(include "../src/base/port.scm")
(include "../src/base/text.scm")
(include "../src/base/platform.scm")
(include "../src/base/time.scm")
(include "../src/base/io.scm")
(include "../src/syntax.scm")
(include "../src/compiler/high-level-ir.scm")
(include "../src/compiler/backend/rkt.scm")
(include "../src/parser/stage.scm")
(include "../src/parser/parse.scm")
(include "../src/parser/minimal.scm")
(include "../src/parser/match.scm")
(include "../src/parser/program.scm")
(include "../src/parser/meta.scm")
(include "../src/posix/platform.scm")
(include "../src/posix/signal.scm")
(include "../src/posix/filesystem.scm")
(include "../src/posix/network.scm")
(include "../src/posix/process.scm")
(include "../src/posix/terminal/osc.scm")
(include "../src/posix/terminal/csi.scm")
(include "../src/posix/terminal/sgr.scm")
(include "../src/posix/terminal/tty.scm")
(include "../src/posix/terminal/text.scm")
(include "../src/bootstrap.scm")
(define-runtime-path path.here ".")
(splicing-local
  ((define path.library (path-append (rkt:path->string path.here) "../src")))
  (define library=>def* (posix-make-library=>def* path.library))
  (define library=>env  (make-library=>env/library=>def* library=>def* eval-definition*)))

(define-namespace-anchor anchor.here)
(current-posix-argument*
 (cdr (current-posix-argument*))
 (lambda ()
   (rkt:call-with-input-file
    (bytes->string/utf-8 (car (current-posix-argument*)))
    (lambda (in)
      (let ((ns (namespace-anchor->namespace anchor.here))
            (stx* (let loop ()
                    (let ((x (rkt:read in)))
                      (if (eof-object? x) '() (cons x (loop)))))))
        (with-native-signal-handling
         (lambda () (rkt:for-each (lambda (stx) (rkt:eval stx ns)) stx*))))))))
