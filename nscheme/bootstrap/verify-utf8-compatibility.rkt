#lang racket/base
(require "../platform/racket/nscheme.rkt")

(define (utf8? bv)
  (define (extra-octet? b) (= (bitwise-and b #b11000000) #b10000000))
  (let ((end (bytevector-length bv)))
    (let loop ((i 0))
      (or (= i end)
          (let ((b0 (bytevector-ref bv i)))
            (cond
              ((= (bitwise-and b0 #b10000000) #b00000000) (loop (+ i 1)))
              ((= (bitwise-and b0 #b11100000) #b11000000)
               (and (< #b11000001 b0) (< (+ i 1) end)
                    (extra-octet? (bytevector-ref bv (+ i 1)))
                    (loop (+ i 2))))
              ((= (bitwise-and b0 #b11110000) #b11100000)
               (and (< (+ i 2) end)
                    (let ((b1 (bytevector-ref bv (+ i 1)))
                          (b2 (bytevector-ref bv (+ i 2))))
                      (and (extra-octet? b1) (extra-octet? b2)
                           (let ((c (bitwise-ior (bitwise-asl (bitwise-and b0 #x0f) 12)
                                                 (bitwise-asl (bitwise-and b1 #x3f) 6)
                                                 (bitwise-and b2 #x3f))))
                             (or (< #x7ff c #xd800) (< #xdfff c)))
                           (loop (+ i 3))))))
              ((= (bitwise-and b0 #b11111000) #b11110000)
               (and (< (+ i 3) end)
                    (let ((b1 (bytevector-ref bv (+ i 1)))
                          (b2 (bytevector-ref bv (+ i 2)))
                          (b3 (bytevector-ref bv (+ i 3))))
                      (and (extra-octet? b1) (extra-octet? b2) (extra-octet? b3)
                           (let ((c (bitwise-ior (bitwise-asl (bitwise-and b0 #x0f) 18)
                                                 (bitwise-asl (bitwise-and b1 #x3f) 12)
                                                 (bitwise-asl (bitwise-and b2 #x3f) 6)
                                                 (bitwise-and b3 #x3f))))
                             (< #xffff c #x110000))
                           (loop (+ i 4))))))
              (else #f)))))))

(let ((count                0)
      (count.batch          0)
      (count.invalid        0)
      (count.false-negative 0)
      (count.false-positive 0))
  (for* ((b0 (in-range 256))
         (b1 (in-range 256))
         (b2 (in-range 256))
         (b3 (in-range 256)))
    (let ((b* (bytes b0 b1 b2 b3)))
      (cond
        ((bytes=? (string->bytes/utf-8 (bytes->string/utf-8 b* #\x)) b*)
         (unless (utf8? b*) (set! count.false-positive (+ count.false-positive 1))))
        (else
         (set! count.invalid (+ count.invalid 1))
         (when (utf8? b*) (set! count.false-negative (+ count.false-negative 1)))))
      (set! count.batch (+ count.batch 1))
      (when (eq? count.batch 5000000)
        (set! count (+ count count.batch))
        (set! count.batch 0)
        (displayln `(total: ,count invalid: ,count.invalid false-positive: ,count.false-positive false-negative: ,count.false-negative)))))
  (displayln `(total: ,(+ count count.batch) invalid: ,count.invalid false-positive: ,count.false-positive false-negative: ,count.false-negative)))
