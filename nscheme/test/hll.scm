;; racket bootstrap/run-file.rkt src/run-cli.scm test/hll.scm | tee test/hll-snapshot.txt && git diff test/hll-snapshot.txt
(include "../src/compiler/data.scm")
(include "../src/compiler/hll.scm")

;;;;;;;;;;;;;;;;;;;;;;;;
;;; VHLL for testing ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;; Expr    ::= Var
;;           | Primop
;;           | Literal
;;           | (quote <value>)
;;           | (if Expr Expr Expr)
;;           | (cond (Expr . Body) ... (else . Body))
;;           | (apply/values Expr Expr)
;;           | (case-lambda (Param* . Body) ...)
;;           | (lambda Param* . Body)
;;           | (letrec ((Param Expr) ...) . Body)
;;           | (let ((Param Expr) ...) . Body)
;;           | (case-values Expr (Param* . Body) ...)
;;           | (begin . Body)
;;           | Body  ; call
;; Body    ::= (Expr Expr ...)
;; Param*  ::= Param | (Param ...) | (Param Param ... . Param)
;; Param   ::= Var | #f
;; Var     ::= <symbol>
;; Primop  ::= <symbol>
;; Literal ::= #f | #t | <number> | <string>
(define (VHLL->HLL P name=>primop)
  (mdefine uid 0)
  (define (apply! proc x) (apply proc (syntax->list x)))
  (define (make-env n=>x) (list (box n=>x)))
  (define (env-ref/k env n kf k)
    (let loop ((env env))
      (if (null? env)
          (kf)
          (let* ((n=>x (unbox (car env))) (nx (assv n n=>x)))
            (if nx (k (cdr nx)) (loop (cdr env)))))))
  (define (env-ref? env n) (env-ref/k env n (lambda () #f) (lambda (_) #t)))
  (define (env-bind! env n x) (let* ((frame (car env)) (n=>x (unbox frame)))
                                (when (assv n n=>x) (mistake "already bound" n (uvar-note x)))
                                (set-box! frame (cons (cons n x) n=>x))))
  (define (env-extend env) (cons (box '()) env))
  (define (make-begin e*) (if (null? (cdr e*)) (car e*) (cons 'begin e*)))
  (define (annotate x note) (if (null? note) x (list 'note note x)))
  (let Expr/env ((env (make-env name=>primop)) (stx P))
    (define x (syntax-unwrap stx))
    (define (operation x default tag handle . tag&handle*)
      (operation* x default tag handle tag&handle*))
    (define (operation* x default tag handle t&h*)
      (if (pair? x)
          (let ((key (syntax-unwrap (car x))))
            (if (and (symbol? key) (not (env-ref? env key)))
                (let loop ((tag tag) (handle handle) (t&h* t&h*))
                  (cond ((eqv? key tag) (apply! handle (cdr x)))
                        ((null? t&h*) (default x))
                        (else (loop (car t&h*) (cadr t&h*) (cddr t&h*)))))
                (default x)))
          (default x)))
    (define (Expr x) (Expr/env env x))
    (define (Body/env env e*)
      (unless (pair? e*) (mistake "empty Body" stx))
      (map (lambda (e) (Expr/env env e)) e*))
    (define (Body x) (Body/env env x))
    (define (bind/k p e* k)
      (let ((env (env-extend env)))
        (define (Var stx)
          (let ((x (syntax-unwrap stx)))
            (unless (symbol? x) (mistake "not a symbol" stx))
            (let ((v (uvar x)) (note (syntax-note stx)))
              (unless (null? note) (set-uvar-note! v (syntax-note stx)))
              (set-uvar-uid! v uid)
              (set! uid (+ uid 1))
              (env-bind! env x v) v)))
        (define (Param stx) (let ((x (syntax-unwrap stx))) (if (not x) x (Var stx))))
        (define (Param* stx)
          (let ((x (syntax-unwrap stx)))
            (cond ((or (not x) (null? x)) x)
                  ((pair? x) (cons (Param (car x)) (Param* (cdr x))))
                  ((symbol? x) (Var stx))
                  (else (mistake "not a parameter list" stx)))))
        (k env (Param* p) (make-begin (Body/env env e*)))))
    (define (Lambda-rand* p&b)
      (apply! (case-lambda
                ((p . e*) (bind/k p e* (lambda (env p e) (list p e))))
                (_ (mistake "empty procedural case" stx)))
              p&b))
    (define (Let-rand*/k k)
      (case-lambda
        ((p&e* . e*) (let ((p&e* (map (lambda (p&e) (let ((p&e (syntax->list p&e)))
                                                      (unless (= (length p&e) 2)
                                                        (mistake "not a binding pair" p&e stx))
                                                      p&e))
                                      (syntax->list p&e*))))
                       (bind/k (map car p&e*) e* (lambda (env p e) (k env p (map cadr p&e*) e)))))
        (_ (mistake "operator arity mismatch" stx))))
    (define (default)
      (operation
        x (lambda (x) (cons 'call (Body (syntax->list x))))
        'quote        (case-lambda
                        ((val) (list 'quote (syntax->datum val)))
                        (_ (mistake "operator arity mismatch" stx)))
        'if           (case-lambda
                        ((c t f) (list 'if (Expr c) (Expr t) (Expr f)))
                        (_ (mistake "operator arity mismatch" stx)))
        'cond         (case-lambda
                        ((c . c*)
                         (let loop ((c c) (c* c*))
                           (if (null? c*)
                               (operation (syntax-unwrap c)
                                          (lambda (c) (mistake "missing else clause" stx))
                                          'else (lambda e* (make-begin (Body e*))))
                               (apply! (case-lambda
                                         ((e . e*) (list 'if (Expr e)
                                                         (make-begin (Body e*))
                                                         (loop (car c*) (cdr c*))))
                                         (_ (mistake "empty cond clause" stx)))
                                       c))))
                        (_ (mistake "operator arity mismatch" stx)))
        'apply/values (case-lambda
                        ((rator rand) (list 'apply/values (Expr rator) (Expr rand)))
                        (_ (mistake "operator arity mismatch" stx)))
        'case-lambda  (lambda p&b* (cons 'case-lambda (map Lambda-rand* p&b*)))
        'lambda       (lambda p&b  (list 'case-lambda (Lambda-rand* p&b)))
        'letrec       (Let-rand*/k
                        (lambda (env p* e* body)
                          (list 'let (map list p* (map (lambda (e) (Expr/env env e)) e*)) body)))
        'let          (Let-rand*/k
                        (lambda (env p* e* body) (list 'let (map list p* (map Expr e*)) body)))
        'case-values  (case-lambda
                        ((e . p&b*) (cons* 'case-values (Expr e) (map Lambda-rand* p&b*)))
                        (_ (mistake "operator arity mismatch" stx)))
        'begin        (lambda x* (Body x*))))
    (annotate
      (cond
        ((or (not x) (eqv? x #t) (number? x) (string? x)) (list 'quote x))
        ((symbol? x) (env-ref/k env x (lambda () (mistake "unbound" stx)) values))
        (else (default)))
      (syntax-note stx))))

(define name=>primop
  (map (lambda (n)
         (cons n (primop (string->symbol (string-append "#" (symbol->string n))) #f)))
       '(values null? number? symbol? string? pair? eqv? cons car cdr + - * = < <= > >=
                mvector mvector-ref mvector-set!)))

(define (HLL-pretty x)
  (let loop ((x x))
    (cond ((pair? x) (cons (loop (car x)) (loop (cdr x))))
          ((vector? x) (list->vector (map loop (vector->list x))))
          ((uvar? x) (uvar->symbol x))
          ((primop? x) (primop-name x))
          (else x))))

(define (HLL-test P)
  (displayln "HLL:")
  (pretty-write (HLL-pretty P))
  (HLL-validate P)
  (newline))

(define (VHLL-test P)
  (displayln "VHLL:")
  (pretty-write (syntax->datum P))
  (HLL-test (VHLL->HLL P name=>primop)))

(for-each
  VHLL-test
  (syntax->list
    #'(123
       (+ 1 2)
       (lambda (a b) (let ((c 3)) (+ (* a b) c)))
       (let ((not (lambda (x) (if x #f #t))))
         (letrec ((sum-to-n (lambda (n) (loop n 0)))
                  (loop (lambda (n total)
                          (if (not (= n 0))
                              (loop (- n 1) (+ total n))
                              total))))
           (sum-to-n 10)))
       (let ((not (lambda (x) (if x #f #t))))
         (letrec ((sum-to-n (lambda (n) (if (= n 0) 0 (loop n 0))))
                  (loop (lambda (n total)
                          (let ((total (+ total n))
                                (n (- n 1)))
                            (if (not (= n 0))
                                (loop n total)
                                total)))))
           (sum-to-n 100)))
       (let ((box (lambda (x) (mvector x)))
             (unbox (lambda (b) (mvector-ref b 0)))
             (set-box! (lambda (b x) (mvector-set! b 0 x))))
         (let ((sum-to-n
                 (lambda (n)
                   (let ((total (box 0)))
                     (letrec ((loop (lambda (n)
                                      (set-box! total (+ (unbox total) n))
                                      (cond ((< 0 n) (loop (- n 1)))
                                            (else (values))))))
                       (loop n)
                       (unbox total))))))
           (sum-to-n 1000)))
       (let ((list (lambda x* x*)) (^x* (lambda () (values 1 2 3))))
         (case-values (^x*)
           ((a)        (list 'one a))
           ((a b)      (list 'two a b))
           ((a b . c*) (list 'more a b c*)))))))
