(provide ast->racket-datum)

(define (~map f ~xs)
  (cond ((pair? ~xs) (cons (f (car ~xs)) (~map f (cdr ~xs))))
        ((null? ~xs) '())
        (#t (f ~xs))))

(define (ast->racket-datum ast)
  (define alen          (- (vector-length ast) 1))
  (define (@ i)         (vector-ref ast i))
  (define (@^ i)        (ast->racket-datum (@ i)))
  (define (? tag)       (equal? tag (@ 0)))
  (define (sym s)       (vector 'symbol s))
  (define (vsym p)      (sym (string-append 'v. p)))
  (define (binding n a) (list (vsym n) (ast->racket-datum a)))
  (define (body e)      (if (and (pair? e) (equal? '#(symbol begin) (car e)))
                          (cdr e) (list e)))
  ;; Assume: set! param is a name; lambda param and apply arg are lists.
  ;; TODO: simplify quote when possible.
  (cond ((? 'quote ) (list (sym 'quote) (@ 1)))
        ((? 'var   ) (vsym (@ 1)))
        ((? 'set!  ) (list (sym 'set!) (vsym (@ 1)) (@^ 2)))
        ((? 'if    ) (list (sym 'if) (@^ 1) (@^ 2) (@^ 3)))
        ((? 'apply ) (cons (@^ 1) (map ast->racket-datum (@ 2))))
        ((? 'lambda) (list* (sym 'lambda) (~map vsym (@ 1)) (body (@^ 2))))
        ((? 'begin ) (cons (sym 'begin) (append (map ast->racket-datum (@ 1))
                                                (ast->racket-datum (@ 2)))))
        ((? 'prim  ) (cons (@ 1) (map ast->racket-datum (@ 2))))
        ((? 'context)  ;; TODO: handle this more generally.
         (cond ((equal? (@ 1) 'reset)
                (list 'reset (list (ast->racket-datum (car (@ 2))))))
               ((equal? (@ 1) 'shift)
                (list 'shift 'k (list (ast->racket-datum (car (@ 2))) 'k)))
               (#t (error '"unknown context ast:" ast))))
        ((or (? 'let) (? 'letrec))
         (list* (sym (@ 0)) (map binding (@ 1) (@ 2)) (body (@^ 3))))
        (#t (error '"unknown ast:" ast))))
