((provide premodule premodule-language premodule:parse
          language language-implicit-public language-hidden-public
          language-implicit-private language-hidden-private language-bindings
          module-require module-provide module-ast module-prims
          module-foreign-prefix module-foreign-suffix
          module module:premodule module:compose
          module:prims module:foreign-prefix module:foreign-suffix
          module-apply namespace-link*)
 (require ast:quote ast:var ast:apply ast:lambda ast:let ast:list ast-eval
          rename binding:var env:empty env-extend* env-update* parse))

(define (premodule-require-public pm)  (vector-ref pm 0))
(define (premodule-provide-public pm)  (vector-ref pm 1))
(define (premodule-require-private pm) (vector-ref pm 2))
(define (premodule-provide-private pm) (vector-ref pm 3))
(define (premodule-language pm)        (vector-ref pm 4))
(define (premodule-body pm)            (vector-ref pm 5))
(define (premodule rpub ppub rpriv ppriv lang body)
  (vector rpub ppub rpriv ppriv lang body))
(define (premodule:parse language:default form)
  (define (i->r items rrns)
    (foldl (lambda (item rrns)
             (if (and (pair? item) (equal? (car item) 'rename))
               (append (reverse (cdr item)) rrns)
               (cons (list item item) rrns))) rrns items))
  (let loop ((head (car form)) (rrequired '()) (rprovided '()) (rlang '()))
    (define next (and (pair? head) (car head)))
    (cond ((null? head)
           (define rd (reverse rrequired)) (define pd (reverse rprovided))
           (define lang (if (null? rlang) language:default (reverse rlang)))
           (define rpub (map car rd)) (define rpriv (map cadr rd))
           (define ppub (map cadr pd)) (define ppriv (map car pd))
           (premodule rpub ppub rpriv ppriv lang (cdr form)))
          ((equal? (car next) 'require)
           (loop (cdr head) (i->r (cdr next) rrequired) rprovided rlang))
          ((equal? (car next) 'provide)
           (loop (cdr head) rrequired (i->r (cdr next) rprovided) rlang))
          ((equal? (car next) 'language)
           (loop (cdr head) rrequired rprovided (foldl cons rlang (cdr next))))
          (#t (error '"invalid module header:" (car form) head)))))

(define (language-implicit-public l)        (vector-ref l 0))
(define (language-hidden-public l)          (vector-ref l 1))
(define (language-implicit-private l)       (vector-ref l 2))
(define (language-hidden-private l)         (vector-ref l 3))
(define (language-bindings l)               (vector-ref l 4))
(define (language ipub hpub ipriv hpriv bs) (vector ipub hpub ipriv hpriv bs))

(define (module-require m)        (vector-ref m 0))
(define (module-provide m)        (vector-ref m 1))
(define (module-ast m)            (vector-ref m 2))
(define (module-prims m)          (vector-ref m 3))
(define (module-foreign-prefix m) (vector-ref m 4))
(define (module-foreign-suffix m) (vector-ref m 5))
(define (module r p ast prims fprefix fsuffix)
  (vector r p ast prims fprefix fsuffix))
;; TODO: check consistency of duplicate prim names.
(define (module:prims m prims) (append prims (module-prims m)))
;; TODO: key by foreign language.
(define (module:foreign-prefix m foreign) ;; Prefix appears in reverse order.
  (append foreign (module-foreign-prefix m)))
(define (module:foreign-suffix m foreign)
  (append foreign (module-foreign-suffix m)))
(define (module:premodule name=>language pm)
  (define ls (alist-ref* name=>language (premodule-language pm)))
  (define (extend/language l (env pub priv))
    (define renamed (map rename (language-implicit-private l)))
    (define bv* (map binding:var (language-implicit-private l) renamed))
    (list (env-update* (env-extend* env bv*) (language-bindings l))
          (append (language-hidden-public l)
                  (language-implicit-public l) pub)
          (append (language-hidden-private l) renamed priv)))
  (def (env:lang pub priv) (foldl extend/language (list env:empty '() '()) ls))
  (define renamed (map rename (premodule-require-private pm)))
  (define bv* (map binding:var (premodule-require-private pm) renamed))
  (define env (env-extend* env:lang bv*))
  (define public-req (append (premodule-require-public pm) pub))
  (define private-req (append renamed priv))
  (define ($list #f) (ast:lambda 'xs (ast:var 'xs)))
  (define body (if (premodule-provide-private pm)
                 (append (premodule-body pm)
                         (list (cons $list (premodule-provide-private pm))))
                 (premodule-body pm)))
  (module public-req (premodule-provide-public pm)
    (ast:lambda private-req (parse env body)) '() '() '()))
(define (module:compose become? ma mb)
  (define ast:a  (module-ast ma))
  (define req:a  (module-require ma))
  (define pro:a  (module-provide ma))
  (define prim:a (module-prims ma))
  (define fpre:a (module-foreign-prefix ma))
  (define fsuf:a (module-foreign-suffix ma))
  (define ast:b  (module-ast mb))
  (define req:b  (module-require mb))
  (define pro:b  (module-provide mb))
  (define prim:b (module-prims mb))
  (define fpre:b (module-foreign-prefix mb))
  (define fsuf:b (module-foreign-suffix mb))
  (define req  (append (filter-not (lambda (n) (member n pro:a)) req:b) req:a))
  (define pro  (append pro:b pro:a))  ;; TODO: check for duplicates.
  (define prim (append prim:b prim:a))
  (define fpre (append fpre:b fpre:a))  ;; Prefix appears in reverse order.
  (define fsuf (append fsuf:b fsuf:a))
  (define $ma          (rename 'module:a))
  (define $mb          (rename 'module:b))
  (define ast:result:a (ast:apply (ast:var $ma) (map ast:var req:a)))
  (define ast:result:b (ast:apply (ast:var $mb) (map ast:var req:b)))
  (define ast:result
    (if become? ast:result:b
      (ast:let (list pro:b) (list ast:result:b)
               (apply ast:list (map ast:var (append pro:b pro:a))))))
  (define ast:c (ast:lambda req (ast:let (list pro:a) (list ast:result:a)
                                         ast:result)))
  (define ast (ast:let (list $ma $mb) (list ast:a ast:b) ast:c))
  (module req pro ast prim fpre fsuf))

(define (module-apply m namespace)
  ;; TODO: incorporate foreign code.
  (define pro (apply (ast-eval (module-ast m))  ;; TODO: use (module-prims m)
                     (alist-ref* namespace (module-require m))))
  (if (module-provide m) (map cons (module-provide m) pro) pro))
(define (namespace-link* ns m*)  ;; TODO: check for duplicates.
  (foldl (lambda (m ns) (append (module-apply m ns) ns)) ns m*))
