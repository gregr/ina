((provide premodule premodule-language premodule:parse
          language language-implicit-public language-hidden-public
          language-implicit-private language-hidden-private language-bindings
          module-require module-provide module-ast module-prims
          module-meta module module:premodule module:compose module:ast->ast
          module:prims module:meta module-apply namespace-link*)
 (require ast:quote ast:var ast:apply* ast:lambda ast:let ast:list ast-eval
          rename binding:var env:empty env-extend* env-update* @body*))

(define (premodule-require-public pm)  (vector-ref pm 0))
(define (premodule-provide-public pm)  (vector-ref pm 1))
(define (premodule-require-private pm) (vector-ref pm 2))
(define (premodule-provide-private pm) (vector-ref pm 3))
(define (premodule-language pm)        (vector-ref pm 4))
(define (premodule-body pm)            (vector-ref pm 5))
(define (premodule rpub ppub rpriv ppriv lang body)
  (vector rpub ppub rpriv ppriv lang body))
(define (premodule:parse language:default form)
  (define (i->r items rrns)
    (foldl (lambda (item rrns)
             (if (and (pair? item) (equal? (car item) 'rename))
               (append (reverse (cdr item)) rrns)
               (cons (list item item) rrns))) rrns items))
  (let loop ((head (car form)) (rrequired '()) (rprovided '()) (rlang '()))
    (define next (and (pair? head) (car head)))
    (cond ((null? head)
           (define rd (reverse rrequired)) (define pd (reverse rprovided))
           (define lang (if (null? rlang) language:default (reverse rlang)))
           (define rpub (map car rd)) (define rpriv (map cadr rd))
           (define ppub (map cadr pd)) (define ppriv (map car pd))
           (premodule rpub ppub rpriv ppriv lang (cdr form)))
          ((equal? (car next) 'require)
           (loop (cdr head) (i->r (cdr next) rrequired) rprovided rlang))
          ((equal? (car next) 'provide)
           (loop (cdr head) rrequired (i->r (cdr next) rprovided) rlang))
          ((equal? (car next) 'language)
           (loop (cdr head) rrequired rprovided (foldl cons rlang (cdr next))))
          (#t (error '"invalid module header:" (car form) head)))))

(define (language-implicit-public l)        (vector-ref l 0))
(define (language-hidden-public l)          (vector-ref l 1))
(define (language-implicit-private l)       (vector-ref l 2))
(define (language-hidden-private l)         (vector-ref l 3))
(define (language-bindings l)               (vector-ref l 4))
(define (language ipub hpub ipriv hpriv bs) (vector ipub hpub ipriv hpriv bs))

(define (module-require m)          (vector-ref m 0))
(define (module-provide m)          (vector-ref m 1))
(define (module-ast m)              (vector-ref m 2))
(define (module-prims m)            (vector-ref m 3))
(define (module-meta m)             (vector-ref m 4))
(define (module r p ast prims meta) (vector r p ast prims meta))
(define (module:ast->ast m ast->ast)
  (module (module-require m) (module-provide m) (ast->ast (module-ast m))
    (module-prims m) (module-meta m)))
;; TODO: check consistency of duplicate prim names.
(define (module:prims m prims)
  (module (module-require m) (module-provide m) (module-ast m)
    (append prims (module-prims m)) (module-meta m)))
(define (module:meta m meta)
  (module (module-require m) (module-provide m) (module-ast m) (module-prims m)
    (env-update* (module-meta m) meta)))
(define (module:premodule name=>language pm)
  (define ls (alist-ref* name=>language (premodule-language pm)))
  (define (extend/language l (env pub priv))
    (define renamed (map rename (language-implicit-private l)))
    (define bv* (map binding:var (language-implicit-private l) renamed))
    (list (env-extend* (env-update* env (language-bindings l)) bv*)
          (append (language-hidden-public l) (language-implicit-public l) pub)
          (append (language-hidden-private l) renamed priv)))
  (def (env:lang pub priv) (foldl extend/language (list env:empty '() '()) ls))
  (define renamed (map rename (premodule-require-private pm)))
  (define bv* (map binding:var (premodule-require-private pm) renamed))
  (define env (env-extend* env:lang bv*))
  (define public-req (append (premodule-require-public pm) pub))
  (define private-req (append renamed priv))
  (define ($list #f) (ast:lambda 'xs (ast:var 'xs)))
  (define body (if (premodule-provide-private pm)
                 (append (premodule-body pm)
                         (list (cons $list (premodule-provide-private pm))))
                 (premodule-body pm)))
  (module public-req (premodule-provide-public pm)
    (ast:lambda private-req (@body* env body)) '() '()))
(define (module:compose become? ma mb)
  (define ast:a  (module-ast ma))
  (define req:a  (module-require ma))
  (define pro:a  (module-provide ma))
  (define prim:a (module-prims ma))
  (define meta:a (module-meta ma))
  (define ast:b  (module-ast mb))
  (define req:b  (module-require mb))
  (define pro:b  (module-provide mb))
  (define prim:b (module-prims mb))
  (define meta:b (module-meta mb))
  (define req  (append (filter-not (lambda (n) (member n pro:a)) req:b) req:a))
  ;; TODO: check for duplicates.
  (define pro  (if become? pro:b (append pro:b pro:a)))
  (define prim (append prim:b prim:a))
  (define meta (env-update* meta:a meta:b))
  (define $ma          (rename 'module:a))
  (define $mb          (rename 'module:b))
  (define ast:result:a (ast:apply* (ast:var $ma) (map ast:var req:a)))
  (define ast:result:b (ast:apply* (ast:var $mb) (map ast:var req:b)))
  (define ast:result
    (if become? ast:result:b
      (ast:let (list pro:b) (list ast:result:b)
               (apply ast:list (map ast:var (append pro:b pro:a))))))
  (define ast:c (ast:lambda req (ast:let (list pro:a) (list ast:result:a)
                                         ast:result)))
  (define ast (ast:let (list $ma $mb) (list ast:a ast:b) ast:c))
  (module req pro ast prim meta))

(define (module-apply m namespace)
  ;; TODO: incorporate metadata.
  (define pro (apply (ast-eval (module-ast m))  ;; TODO: use (module-prims m)
                     (alist-ref* namespace (module-require m))))
  (if (module-provide m) (map cons (module-provide m) pro) pro))
(define (namespace-link* ns m*)  ;; TODO: check for duplicates.
  (foldl (lambda (m ns) (append (module-apply m ns) ns)) ns m*))
