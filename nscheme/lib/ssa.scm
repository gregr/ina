((provide expr:variables expr:constants expr:prim expr:call expr:apply
          transfer:return transfer:jump transfer:if block
          heap:empty heap-blocks-add heap-values-add
          process:new process-state process-running-values process-step
          process-stuck-reason process-stuck-details
          uid-generator/range)
 (require alist->tmap tmap:empty tmap-union tmap-ref tmap-add))

(define (uid-generator/range start end)
  (let ((current start))
    (lambda () (cond ((and end (<= end current)) #f)
                     (#t (define uid current) (set! current (+ current 1))
                      uid)))))

(define dict:empty                     tmap:empty)
(define (alist->dict kvs)              (alist->tmap kvs))
(define (dict-ref d i)                 (tmap-ref d i))
(define (dict-add d i v)               (tmap-add d i v))

(define (value-tag v)                  (vector-ref v 0))
(define (value:vector v)               (vector 'vector v))
(define (value-vector-vector v)        (vector-ref v 1))
(define (value:mvector len)            (vector 'mvector len))
(define (value-mvector-length mv)      (vector-ref mv 1))
(define (value:closure label fv-count) (vector 'closure label fv-count))
(define (value-closure-label c)        (vector-ref c 1))
(define (value-closure-fv-count c)     (vector-ref c 2))

(define (expr-tag e)                   (vector-ref e 0))
(define (expr:variables s*)            (vector 'variables s*))
(define (expr-variables-s* e)          (vector-ref e 1))
(define (expr:constants i*)            (vector 'constants i*))
(define (expr-constants-i* e)          (vector-ref e 1))
(define (expr:prim p s*)               (vector 'prim p s*))
(define (expr-prim-name e)             (vector-ref e 1))
(define (expr-prim-args e)             (vector-ref e 2))
(define (expr:call l s*)               (vector 'call l s*))
(define (expr-call-label e)            (vector-ref e 1))
(define (expr-call-args e)             (vector-ref e 2))
(define (expr:apply sp sa)             (vector 'apply sp sa))
(define (expr-apply-proc e)            (vector-ref e 1))
(define (expr-apply-arg e)             (vector-ref e 2))

(define (transfer-tag t)               (vector-ref t 0))
(define (transfer:return e)            (vector 'return e))
(define (transfer-return-e t)          (vector-ref t 1))
(define (transfer:jump e l)            (vector 'jump e l))
(define (transfer-jump-e t)            (vector-ref t 1))
(define (transfer-jump-l t)            (vector-ref t 2))
(define (transfer:if xc lt lf)         (vector 'if xc lt lf))
(define (transfer-if-c t)              (vector-ref t 1))
(define (transfer-if-t t)              (vector-ref t 2))
(define (transfer-if-f t)              (vector-ref t 3))

(define (block i* expr transfer)       (vector i* expr transfer))
(define (block-ids b)                  (vector-ref b 0))
(define (block-expr b)                 (vector-ref b 1))
(define (block-transfer b)             (vector-ref b 2))

(define blocks:empty                   dict:empty)
(define values:empty                   dict:empty)
(define store:empty                    dict:empty)

;; TODO: garbage collection and targeted removal of heap components.
(define (heap blocks values store)     (vector blocks values store))
(define (heap-blocks h)                (vector-ref h 0))
(define (heap-values h)                (vector-ref h 1))
(define (heap-store h)                 (vector-ref h 2))
(define (heap-blocks-ref h l)          (dict-ref (heap-blocks h) l))
(define (heap-blocks-add h l b)
  (heap (dict-add (heap-blocks h) l b) (heap-values h) (heap-store h)))
(define (heap-values-ref h i)          (dict-ref (heap-values h) i))
(define (heap-values-add h i v)
  (heap (heap-blocks h) (dict-add (heap-values h) i v) (heap-store h)))
(define (heap-store-add h i size)
  (define m (alist->dict (map (lambda (i) (cons i #t)) (range size))))
  (heap (heap-blocks h) (heap-values h)
        (dict-add (heap-store h) i (cons size m))))
(define (heap-store-ref h i j)  (let ((m (dict-ref (heap-store h) i)))
                                  (and (<= 0 j) (< j (car m)) m)))
(define (heap-store-read h i j) (let ((m (heap-store-ref h i j)))
                                  (and m (dict-ref m j))))
(define (heap-store-write h i j v)
  (define m (heap-store-ref h i j))
  (and m (heap (heap-blocks h) (heap-values h)
               (dict-add (heap-store h) i (dict-add m j v)))))
(define heap:empty (heap blocks:empty values:empty store:empty))

(define env:empty     dict:empty)
(define (env-ref e i) (dict-ref e i))
(define (env-extend e bindings)
  (tmap-union (lambda (a b) b) e (alist->dict bindings)))

;; TODO: define process:io.
(define (process-state p)              (vector-ref p 0))
(define (process:stuck reason details) (vector 'stuck reason details))
(define (process-stuck-reason p)       (vector-ref p 1))
(define (process-stuck-details p)      (vector-ref p 2))
(define (process:running i* r*)        (vector 'running i* r*))
(define (process-running-values p)     (vector-ref p 1))
(define (process-running-returns p)    (vector-ref p 2))
(define (process:new l args) (process:running args (list (cons l env:empty))))
(define (process-step p h)
  (define returns
    (and (equal? 'running (process-state p)) (process-running-returns p)))
  (and (pair? returns)
       (let* ((r        (car returns))
              (b        (heap-blocks-ref h (car r)))
              (bindings (map cons (block-ids b) (process-running-values p)))
              (env      (env-extend (cdr r) bindings)))
         (step h (cdr returns) env (block-expr b) (block-transfer b)))))

(define (step h r* env t)
  (define (err msg)    (error msg (vector h r* env t)))
  (define (stuck msg)  (process:stuck msg (vector h r* env t)))
  (define (var->id v)  (env-ref env v))
  (define (id->val id) (heap-values-ref h id))
  (define (step/expr x r*)
    (define (step/prim pname args)
      (define (?p name) (equal? name pname))
      ;; TODO: return process:stuck when args are mistyped.
      ;; Categorize primitives?
      ;; type-check, compare, allocate/convert, access, compute, mset, mref, io
      (cond ;((?p ) )
            (#t (err '"invalid primitive name"))))
    (define xt (expr-tag x)) (define (?x tag) (equal? xt tag))
    (cond ((?x 'variables)
           (cons h (process:running (map var->id (expr-variables-s* x)) r*)))
          ((?x 'constants)
           (cons h (process:running (expr-constants-i* x) r*)))
          ((?x 'prim)
           (step/prim (expr-prim-name x) (map var->id (expr-prim-args x))))
          ((?x 'call)
           (define args (map var->id (expr-call-args x)))
           (define l    (expr-call-label x))
           (cons h (process:running args (cons (cons l env:empty) r*))))
          ((?x 'apply)
           (define proc     (var->id (expr-apply-proc x)))
           (define arg      (var->id (expr-apply-arg x)))
           (define proc-val (id->val proc))
           (define p
             (if (equal? 'closure (value-tag proc-val))
               (process:running
                 (list proc arg)
                 (cons (cons (value-closure-label proc-val) env:empty) r*))
               (stuck '"applied non-procedure")))
           (cons h p))
          (#t (err '"invalid expression"))))
  (define tt (transfer-tag t)) (define (?t tag) (equal? tt tag))
  (cond ((?t 'return) (step/expr (transfer-return-e t) r*))
        ((?t 'jump)   (step/expr (transfer-jump-e t)
                                 (cons (cons (transfer-jump-l t) env) r*)))
        ((?t 'if)     (define l (if (id->val (var->id (transfer-if-c t)))
                                  (transfer-if-t t) (transfer-if-f t)))
                      (process:running '() (cons (cons l env) r*)))
        (#t (err '"invalid transfer"))))

;; TODO:
;; provenance
;; ssa->graph w/ dataflow framework
