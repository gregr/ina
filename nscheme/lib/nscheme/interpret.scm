(provide interpret env-ref-prop ncons param-names param-bind
         defst:empty defst-env defst-names defst-actions
         defst-env-set defst-names-add defst-actions-add defst-run
         @begin/define @def)
(require env-extend* @quote @apply @set! @true)

(define (env-ref-prop env id property default)
  (alist-ref (alist-ref env id '()) property default))

;; Formal parameters
(define (ncons name names)
  (when (member name names) (error '"duplicate name:" name names))
  (cons name names))
(define (param-names param)
  (let loop ((p param) (ns '()))
    (cond ((pair? p)   (loop (cdr p) (loop (car p) ns)))
          ((vector? p) (loop (vector->list p) ns))
          ((string? p) (ncons p ns))
          ((null? p)   ns)
          ((not p)     ns)
          (else (error '"invalid parameter:" p param)))))
(define (param-bind param arg)
  (let loop ((p param) (a arg))
    (cond ((and (pair? p) (pair? a)) (append (loop (car p) (car a))
                                             (loop (cdr p) (cdr a))))
          ((and (vector? p) (vector? a))
           (loop (vector->list p) (vector->list a)))
          ((string? p)               (list (cons p a)))
          ((and (null? p) (null? a)) '())
          ((not p)                   '())
          (else (error '"parameter/argument mismatch:" param arg p a)))))

;; Generalized interpreter: useable for both parsing and evaluation.
(define (interpret env form)
  (cond ((pair? form)
         (let ((op (and (string? (car form))
                        (env-ref-prop env (car form) '"operate" #f))))
           (if op (op env (car form) (cdr form))
             (@apply (interpret env (car form))
                     (map (lambda (a) (interpret env a)) (cdr form))))))
        ((string? form) ((or (env-ref-prop env form '"ref" #f)
                             (error '"unbound variable:" form))))
        ((or (boolean? form) (number? form)) (@quote env form))
        ((procedure? form)                   (form env))
        (#t                                  (error '"invalid syntax:" form))))

;; Definition contexts
(define (defst:empty env)  (vector env '() '()))
(define (defst-env st)     (vector-ref st 0))
(define (defst-names st)   (vector-ref st 1))
(define (defst-actions st) (vector-ref st 2))
(define (defst-env-set st env)
  (vector env (defst-names st) (defst-actions st)))
(define (defst-names-add st names)
  (define new (foldl ncons (defst-names st) names))
  (vector (defst-env st) new (defst-actions st)))
(define (defst-actions-add st action)
  (vector (defst-env st) (defst-names st) (cons action (defst-actions st))))
(define (defst-run st combine finish)
  (define env (defst-env st))
  (finish (foldl (lambda (action actions) (combine (action env) actions))
                 @true (reverse (defst-actions st)))))
(define (@begin/define st . forms)
  (foldl (lambda (form st)
           (define $define
             (and (pair? form) (string? (car form))
                  (env-ref-prop (defst-env st) (car form) '"define" #f)))
           (if $define (apply $define (cons st (cdr form)))
             (defst-actions-add st (lambda (env) (interpret env form)))))
         st forms))
(define (@def st param expr)
  (define names (param-names param))
  (defst-actions-add
    (defst-env-set (defst-names-add st names)
                   (env-extend* (alist-remove* (defst-env st) names)
                                (map (lambda (n) (cons n @true)) names)))
    (lambda (env) (@set! env param (interpret env expr)))))
