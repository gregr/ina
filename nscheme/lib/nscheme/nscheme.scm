(provide nscheme:expand env:base)

(require box tagged-vector? tagged-vector?!
         primitive-ops
         ast:quote ast:var ast:set! ast:if ast:apply ast:lambda
         ast:reset ast:shift ast:primitive-op)

;; Syntactic environments
(define (name? n) (string? n))
(define (fresh-uid name) (box name))
(define ctx:var  'variable)
(define ctx:set! 'set!)
(define ctx:op   'operator)
(define ctx:def  'definition)
(define (binding name ctx uid value) (vector name ctx uid value))
(define (binding-name b)             (vector-ref b 0))
(define (binding-context b)          (vector-ref b 1))
(define (binding-uid b)              (vector-ref b 2))
(define (binding-value b)            (vector-ref b 3))
(define (binding:var name uid)  (binding name ctx:var uid ast:var))
(define (binding:set! name uid) (binding name ctx:set! uid ast:set!))

(define env:empty            '())
(define (env-extend* env b*) (append b* env))
(define (env-ref env ctx* n)
  (define b*? (memf (lambda (b) (and (equal? (binding-name b) n)
                                     (member (binding-context b) ctx*))) env))
  (or (and b*? (car b*?)) (binding n (car ctx*) n #f)))
(define (env-ref? env ctx* n)
  (define b (env-ref env ctx* n))
  (and (equal? (binding-context b) (car ctx*)) (binding-value b) b))

(define (env-extend*/var env b?*)
  (foldl (lambda (b* env) (env-extend* env b*)) env
         (map (lambda (b) (list (binding:set! (car b) (cdr b))
                                (binding:var (car b) (cdr b))))
              (filter (lambda (b?) (car b?)) b?*))))
(define (env-extend*/syntax env ctx b*)
  (env-extend*
    env (map (lambda (b) (define n (car b)) (define parse (cdr b))
               (binding n ctx (fresh-uid n) parse)) b*)))
(define (env-freeze env)
  (filter-not (lambda (b) (equal? (binding-context b) ctx:set!)) env))
(define (env-alias env ctx n aliased)
  (define b (env-ref env (list ctx) aliased))
  (env-extend* env (list (binding n ctx (binding-uid b) (binding-value b)))))
(define (env-hide* env ctx n*)
  (env-extend* env (map (lambda (n) (binding n ctx (fresh-uid n) #f)) n*)))

(define (make-syntax=? context env-a env-b)
  (define (=? a b)
    (cond ((and (pair? a) (pair? b)) (and (=? (car a) (car b))
                                          (=? (cdr a) (cdr b))))
          ((and (name? a) (name? b))
           (equal? (binding-uid (env-ref env-a (list context) a))
                   (binding-uid (env-ref env-b (list context) b))))
          (else (equal? a b))))
  =?)

(define (parse:var env n)
  (define b (or (env-ref? env (list ctx:var) n)
                (error '"unbound variable:" n)))
  ((binding-value b) (binding-uid b)))
(define (parse:set! env n $rhs)
  (define b (or (env-ref? env (list ctx:set! ctx:var) n)
                (error '"cannot set! variable:" n)))
  ((binding-value b) (binding-uid b) $rhs))
(define (parse:op? env form)
  (let* ((n (and (pair? form) (car form)))
         (b (and (name? n) (env-ref? env (list ctx:op ctx:var) n))))
    (and b ((binding-value b) env form))))
(define (parse:def? st form)
  (let* ((n (and (pair? form) (car form)))
         (b (and (name? n) (env-ref? (defst-env st)
                                     (list ctx:def ctx:op ctx:var) n))))
    (and b ((binding-value b) st form))))

;; Pattern matching
(define (~length ~xs)        (if (pair? ~xs) (+ 1 (~length (cdr ~xs))) 0))
(define (~length=? len ~xs)  (= (~length ~xs) len))
(define (~length>=? len ~xs) (>= (~length ~xs) len))
(define (length=? len xs)    (and (list? xs) (~length=? len xs)))
(define (length>=? len xs)   (and (list? xs) (~length>=? len xs)))

;; Expansion
(define expander:tag    (box 'expander))
(define (expander proc) (vector expander:tag proc))
(define (expander? d)   (tagged-vector? expander:tag '(proc) d))
(define (literal? d)    (or (boolean? d) (number? d)))
(define (expand:apply env proc a*)
  ($apply* (expand env proc) (map (lambda (a) (expand env a)) a*)))
(define (expand env form)
  (let loop ((form form))
    (cond ((parse:op? env form))
          ((expander? form) => (import->lambda (import (proc) (proc env))))
          ((literal? form)     (ast:quote form))
          ((name? form)        (parse:var env form))
          ((length>=? 1 form)  (expand:apply
                                 env (list-ref form 0) (list-tail form 1)))
          (else                (error '"invalid syntax:" form)))))
(define (expand* env form*) (map (lambda (f) (expand env f)) form*))

;; Parameters
(define (improper-list? d)
  (and (not (null? d)) (or (not (pair? d)) (improper-list? (cdr d)))))
(define (~list->list d)
  (cond ((null? d) '())
        ((pair? d) (cons (car d) (~list->list (cdr d))))
        (else (list d))))
(define (param? p) (or (not p) (name? p)))
(define (param*?! p*)
  (unless (andmap param? p*) (error '"invalid parameter list:" p*))
  (define n* (filter name? p*))
  (unless (= (length n*) (length (remove-duplicates n*)))
    (error '"parameter list contains duplicate names:" p*)))
(define (bpair*?! b*)
  (define (bpair? b) (and (list? b) (= 2 (length b))
                            (or (not (car b)) (name? (car b)))))
  (unless (and (list? b*) (andmap bpair? b*))
    (error '"invalid binding list:" b*)))
(define (param*->addr* n*)
  (map (lambda (n) (and (name? n) (fresh-uid n))) n*))

;; High-level AST construction
(define $null (ast:quote '()))
(define $true (ast:quote #t))
(define $false (ast:quote #f))
(define ($cons a d)  (ast:primitive-op 'cons (list a d)))
(define ($pair? x)   (ast:primitive-op 'pair? (list x)))
(define ($car x)     (ast:primitive-op 'car (list x)))
(define ($cdr x)     (ast:primitive-op 'cdr (list x)))
(define ($vector? x) (ast:primitive-op 'vector? (list x)))
(define ($list . xs) (foldr $cons $null xs))
(define ($error . a*) (ast:apply (ast:quote 'error) (apply $list a*)))
(define ($apply* $proc $a*) (ast:apply $proc (apply $list $a*)))
(define ($lambda variadic? p?* b?*->body)
  (define a?* (param*->addr* p?*))
  (ast:lambda variadic? a?* (b?*->body (map cons p?* a?*))))
(define ($thunk body) (ast:lambda #f '() body))
(define ($lambda/temp temp $temp->body)
  (define (body b*) ($temp->body (expand (env-extend*/var env:empty b*) temp)))
  ($lambda #f (list temp) body))
(define ($let/temp temp-name $v $temp->body)
  ($apply* ($lambda/temp temp-name $temp->body) (list $v)))
(define ($let p?* v* b?*->body) ($apply* ($lambda #f p?* b?*->body) v*))
(define ($begin body-initial* body-final)
  (cond ((null? body-initial*) body-final)
        (else ($let '(#f) (list (car body-initial*))
                    (lambda (_) ($begin (cdr body-initial*) body-final))))))
(define ($letrec p?* b?*->v*&body)
  (define uninitialized* (map (lambda (_) $true) p?*))
  (define (b?*->body b?*)
    (let* ((v*b (b?*->v*&body b?*)) (v* (car v*b)) (body (cdr v*b)))
      (define a?* (map cdr b?*))
      ($begin (map (lambda (a? v) (if a? (ast:set! a? v) v)) a?* v*) body)))
  ($let p?* uninitialized* b?*->body))

;; High-level expansion
(define (b?*->expand:body* env body*)
  (lambda (b?*) (expand:body* (env-extend*/var env b?*) body*)))
(define (expand:lambda env ~p?* body*)
  (define p* (~list->list ~p?*)) (param*?! p*)
  ($lambda (improper-list? ~p?*) p* (b?*->expand:body* env body*)))
(define (expand:let env p?* e* body*)
  ($let p?* (expand* env e*) (b?*->expand:body* env body*)))
(define (expand:let/temp temp-name env e $temp->body)
  ($let/temp temp-name (expand env e) $temp->body))
(define (expand:letrec env p?* e* env->body)
  (define (b?*->v*&body b?*)
    (let ((env (env-extend*/var env b?*)))
      (cons (expand* env e*) (env->body env))))
  ($letrec p?* b?*->v*&body))

(define (defst:empty env) (vector env '()))
(define (defst-env st)    (vector-ref st 0))
(define (defst-rdef* st)  (vector-ref st 1))
(define ($define st n def-body)
  (vector (defst-env st) (cons (cons n def-body) (defst-rdef* st))))
;; TODO: $define-syntax ?
(define (expand:definition* st form*)
  (foldl (lambda (form st)
           (cond ((parse:def? st form))
                 (else ($define st #f form)))) st form*))
(define (parse:begin st form)
  (cond ((length>=? 1 form) (expand:definition* st (list-tail form 1)))
        (else               (error '"invalid begin:" form))))
(define (parse:define st form)
  (define (@ i) (list-ref form i)) (define (@. i) (list-tail form i))
  (cond ((and (length=? 3 form) (param? (@ 1))) ($define st (@ 1) (@ 2)))
        ((and (~length>=? 3 form) (pair? (@ 1)) (name? (car (@ 1))))
         (define (edef env) (expand:lambda env (cdr (@ 1)) (@. 2)))
         ($define st (car (@ 1)) (expander edef)))
        (else (error '"invalid define:" form))))

(define (expand:body* env body*)
  (define ($define n def-body rdef*) (cons (cons n def-body) rdef*))
  (unless (list? body*) (error '"body must be a list:" body*))
  (define rdef* (defst-rdef* (expand:definition* (defst:empty env) body*)))
  (when (null? rdef*) (error '"body cannot be empty:" body*))
  (define p?e* (reverse (cdr rdef*)))
  (define final-def (car rdef*))
  (define body-final (cdr final-def))
  (when (car final-def) (error '"body cannot end with a definition:" body*))
  (expand:letrec env (map car p?e*) (map cdr p?e*)
                 (lambda (env) (expand env body-final))))
(define (expand:error env a*) (apply $error (expand* env a*)))
(define (expand:and* env e*)
  (define re* (reverse e*))
  (if (null? re*) $true
    (foldr (lambda (e r) (ast:if (expand env e) r $false))
           (expand env (car re*)) (reverse (cdr re*)))))
(define (expand:or2 env e $rest)
  (expand:let/temp 'temp env e (lambda ($temp) (ast:if $temp $temp $rest))))

;; Bindings for variables
(define primitive-op-procs
  (map (lambda (po-desc)
         (define (x i) (string-append 'x (number->string i)))
         (define p* (map x (range (length (cadr po-desc)))))
         (list (car po-desc) (list 'lambda p* (cons (car po-desc) p*))))
       primitive-ops))

(define derived-op-procs
  '((error (lambda args ('error args)))
    (not (lambda (b) (if b #f #t)))
    (list->vector (lambda (xs)
                    (define result (make-mvector (length xs) #t))
                    (foldl (lambda (x i) (mvector-set! result i x) (+ i 1))
                           0 xs)
                    (mvector->vector result)))
    (vector->list (lambda (v)
                    (let loop ((i (- (vector-length v) 1)) (xs '()))
                      (if (< i 0) xs
                        (loop (- i 1) (cons (vector-ref v i) xs))))))
    (equal? (lambda (a b)
              (cond ((pair? a)   (and (pair? b) (equal? (car a) (car b))
                                      (equal? (cdr a) (cdr b))))
                    ((vector? a) (and (vector? b) (equal? (vector->list a)
                                                          (vector->list b))))
                    ((boolean? a)   (and (boolean? b)   (boolean=? a b)))
                    ((string?  a)   (and (string?  b)   (string=?  a b)))
                    ((number?  a)   (and (number?  b)   (number=?  a b)))
                    ((mvector? a)   (and (mvector? b)   (mvector=? a b)))
                    ((procedure? a) (and (procedure? b) (procedure=? a b)))
                    ((null? a)      (null? b)))))
    (vector (lambda xs (list->vector xs)))
    (list?  (lambda (v) (or (and (pair? v) (list? (cdr v))) (null? v))))
    (list   (lambda xs xs))
    (list*  (lambda (x . xs) (cons* x xs)))
    (foldl  (lambda (f acc xs) (if (null? xs) acc
                                 (foldl f (f (car xs) acc) (cdr xs)))))
    (foldr  (lambda (f acc xs) (if (null? xs) acc
                                 (f (car xs) (foldr f acc (cdr xs))))))
    (map (lambda (f xs . xss)
           (define (map1 f xs) (if (null? xs) '()
                                 (cons (f (car xs)) (map1 f (cdr xs)))))
           (cond ((null? xs) '())
                 (else (cons (apply f (car xs) (map1 car xss))
                             (apply map f (cdr xs) (map1 cdr xss)))))))
    (andmap (lambda (f xs . xss)
              (let loop ((last #t) (xs xs) (xss xss))
                (and last (if (null? xs) last
                            (loop (apply f (car xs) (map car xss))
                                  (cdr xs) (map cdr xss)))))))
    (ormap (lambda (f xs . xss)
             (cond ((null? xs) #f)
                   ((apply f (car xs) (map car xss)) => (lambda (y) y))
                   (else (apply ormap f (cdr xs) (map cdr xss))))))
    (filter (lambda (p? xs)
              (cond ((null? xs) '())
                    ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
                    (else (filter p? (cdr xs))))))
    (filter-not (lambda (p? xs) (filter (lambda (x) (not (p? x))) xs)))
    (length (lambda (xs) (foldl (lambda (_ l) (+ 1 l)) 0 xs)))
    (append (lambda xss (foldr (lambda (xs yss) (foldr cons yss xs)) '() xss)))
    (reverse-append (lambda (xs ys) (foldl cons ys xs)))
    (reverse (lambda (xs) (reverse-append xs '())))

    (range (lambda (n)
             (let loop ((i 0)) (if (= i n) '() (cons i (loop (+ i 1)))))))
    (take (lambda (xs n) (if (= 0 n) '()
                           (cons (car xs) (take (cdr xs) (- n 1))))))
    (drop (lambda (xs n) (if (= 0 n) xs (drop (cdr xs) (- n 1)))))
    (member (lambda (v xs) (cond ((null? xs) #f)
                                 ((equal? v (car xs)) xs)
                                 (else (member v (cdr xs))))))
    (caar (lambda (v) (car (car v))))
    (assoc (lambda (k xs) (cond ((null? xs) #f)
                                ((equal? k (caar xs)) (car xs))
                                (else (assoc k (cdr xs))))))
    (remove-duplicates
      (lambda (xs)
        (define (ucons x acc) (if (member x acc) acc (cons x acc)))
        (reverse (foldl ucons '() xs))))))

,(
;; Parsers for primitive syntax (no var dependencies)
(define parsers:primitive
  '((apply ((length=? 3 form) (ast:apply (ex (@ 1)) (ex (@ 2)))))
    (quote ((length=? 2 form) (ast:quote (@ 1))))
    (if    ((length=? 4 form) (ast:if (ex (@ 1)) (ex (@ 2)) (ex (@ 3)))))
    (set!  ((and (length=? 3 form) (name? (@ 1)))
            (parse:set! env (@ 1) (ex (@ 2)))))
    (reset ((length>=? 2 form) (ast:reset (expand:body* env (@. 1)))))
    (shift ((length>=? 3 form)
            (ast:shift ($lambda #f (list (@ 1))
                                (b?*->expand:body* env (@. 2))))))
    (lambda ((length>=? 3 form) (expand:lambda env (@ 1) (@. 2))))
    (letrec ((length>=? 3 form)
             (bpair*?! (@ 1))
             (expand:letrec env (map car (@ 1)) (map cadr (@ 1))
                            (lambda (env) (expand:body* env (@. 2))))))
    (let ((and (length>=? 4 form) (name? (@ 1)))
          (bpair*?! (@ 2))
          (define (ex-proc env) (expand:lambda env (map car (@ 2)) (@. 3)))
          (expand:letrec env (list (@ 1)) (list (expander ex-proc))
                         (lambda (env)
                           (expand:apply env (@ 1) (map cadr (@ 2))))))
      ((length>=? 3 form)
       (bpair*?! (@ 1))
       (expand:let env (map car (@ 1)) (map cadr (@ 1)) (@. 2))))
    (let* ((length>=? 3 form)
           (bpair*?! (@ 1))
           (let loop ((b* (@ 1)) (env env))
             (define (next b?*) (loop (cdr b*) (env-extend*/var env b?*)))
             (cond ((null? b*) (expand:body* env (@. 2)))
                   ((pair? b*) ($let (list (caar b*))
                                     (list (expand env (cadar b*))) next))))))
    (begin ((length>=? 2 form) (define rb* (reverse (map ex (@. 1))))
                               ($begin (reverse (cdr rb*)) (car rb*))))
    (cond
      ((length>=? 2 form)
       (define =? (make-syntax=? ctx:var env:primitive-syntax env))
       (unless (length>=? 1 (@. 1)) (error '"invalid cond:" form))
       (let loop ((c* (@. 1)))
         (cond
           ((null? c*) ($error (ast:quote '"no matching cond clause:")
                               (ast:quote form)))
           ((not (length>=? 1 (car c*))) (error '"invalid cond:" form))
           ((and (=? 'else (caar c*)) (length=? 1 c*))
            (expand:body* env (cdar c*)))
           (else
             (let* (($* (loop (cdr c*))) (c0 (caar c*)) (c. (cdar c*)))
               (cond ((=? 'else c0) (error '"invalid else in cond:" form))
                     ((null? c.) (expand:or2 env c0 $*))
                     ((and (=? '=> (car c.)) (length=? 1 (cdr c.)))
                      (define ($t->body $t)
                        (ast:if $t ($apply* (ex (cadr c.)) (list $t)) $*))
                      (expand:let/temp 'temp env c0 $t->body))
                     (else (ast:if (ex c0) (expand:body* env c.) $*)))))))))
    (and ((length>=? 1 form) (expand:and* env (@. 1))))
    (or ((length>=? 1 form)
         (foldr (lambda (e r) (expand:or2 env e r)) $false (@. 1))))
    (when ((length>=? 3 form)
           (ast:if (ex (@ 1)) (expand:body* env (@. 2)) $true)))
    (unless ((length>=? 3 form)
             (ast:if (ex (@ 1)) $true (expand:body* env (@. 2)))))))

(define (parser-descs->b* qenv descs)
  (cons 'list
        (map (lambda (name&clause*)
               (list 'cons (list 'quote (car name&clause*))
                     (list 'lambda '(env form)
                           '(define (ex form) (expand env form))
                           '(define (@ i) (list-ref form i))
                           '(define (@. i) (list-tail form i))
                           (cons 'cond (append
                                         (cdr name&clause*)
                                         '((else (error '"invalid syntax:"
                                                        form))))))))
             descs)))

;; Environment construction
(append
  (list
    'begin
    (list
      'define 'env:primitive-syntax
      (list 'env-extend*/syntax
        (list 'env-extend*/syntax
              (list 'env-extend*/syntax 'env:empty 'ctx:op
                    (parser-descs->b*
                      'env:primitive-syntax parsers:primitive))
              'ctx:def '(list (cons 'begin parse:begin)
                              (cons 'define parse:define)))
        'ctx:op
        '(map (lambda (po-desc)
                (define name (car po-desc))
                (cons name
                      (lambda (env form)
                        (cond ((length=? (+ (length (cadr po-desc)) 1) form)
                               (ast:primitive-op
                                 name (expand* env (list-tail form 1))))
                              (else (error '"invalid primitive op:"
                                           po-desc form))))))
              primitive-ops))))

 '((define env:base #t)
   (define nscheme:expand
     (reset (expand
              env:primitive-syntax
              (list 'let primitive-op-procs
                    (list 'letrec
                          '((cons* (lambda (x xs)
                                     (if (null? xs) x
                                       (cons x (cons* (car xs) (cdr xs)))))))
                          (list 'let '((apply (lambda (f x . xs)
                                                (apply f (cons* x xs)))))
                                (list 'letrec derived-op-procs
                                      (expander
                                        (lambda (env)
                                          (set! env:base (env-freeze env))
                                          (define form (shift k k))
                                          (expand env:base form))))))))))))
)
