(provide eval env:base test!)

(require length>=? param?! bpair*?! param-names param-bind
         ctx:var ctx:set! ctx:op ctx:def
         env-get-prop env-pre-extend* env-extend*
         defstate:empty defstate-env defstate-actions
         defstate-env-set defstate-names-add defstate-actions-add)

(define (env-extend*/var env b*)
  (param?! (map car b*))
  (define (b->rib b)
    (let* ((cell (make-mvector 1 (cdr b)))
           (get (lambda ()  (mvector-ref  cell 0)))
           (set (lambda (v) (mvector-set! cell 0 v))))
      (cons (car b) (list (cons ctx:var get) (cons ctx:set! set)))))
  (env-extend* (map b->rib b*) env))

;; Evaluation
(define (eval env form)
  (cond ((pair? form)
         (let* ((p (car form)) (a* (cdr form)) (proc (eval env p)))
           (if (and (string? p) (env-get-prop env p ctx:op #f))
             (apply proc env a*) (apply proc (eval* env a*)))))
        ((string? form) ((or (env-get-prop env form ctx:var #f)
                             (error '"unbound variable:" form))))
        ((or (boolean? form) (number? form)) form)
        ((procedure? form)                   (form env))
        (#t                                  (error '"invalid syntax:" form))))
(define (eval* env form*) (map (lambda (f) (eval env f)) form*))

(define (@lambda env param . body)
  (let ((cenv (env-pre-extend* env (param-names param))))
    (lambda a (@body* (env-extend*/var cenv (param-bind param a)) body))))
(define (@quote env d) d)
(define (@if env c t f) (if (eval env c) (eval env t) (eval env f)))
(define (@reset env . body) (reset (@body* env body)))
(define (@shift env p . body)
  (shift k (apply @let env (list (list p (lambda (_) k))) body)))
(define (@set! env param arg)
  (for-each (lambda (b) ((or (env-get-prop env (car b) ctx:set! #f)
                             (error '"identifier cannot be set!:" (car b)))
                         (cdr b)))
            (param-bind param (eval env arg))) #t)
(define (@letrec env b* . body)
  (bpair*?! b*)
  (define (k env) (begin (for-each (lambda (b) (apply @set! env b)) b*)
                         (apply @let env '() body)))
  (@let env (map (lambda (b) (list (car b) #t)) b*) k))
(define (@let/ env b* . body)
  (apply (apply @lambda env (map car b*) body) (eval* env (map cadr b*))))
(define (@let/name env name b* . body)
  (define p (lambda (env) (apply @lambda env (map car b*) body)))
  (apply (@letrec env (list (list name p)) name) (eval* env (map cadr b*))))
(define (@let* env b* . body)
  (let loop ((b* b*) (env env))
    (if (null? b*) (@body* env body)
      (@let/ env (list (car b*)) (lambda (env) (loop (cdr b*) env))))))
(define (@let env . tail)
  (cond ((and (length>=? 2 tail) (string? (car tail)) (bpair*?! (cadr tail)))
         (apply @let/name env tail))
        (#t (bpair*?! (car tail)) (apply @let/ env tail))))
(define (@begin env . body) (foldl (lambda (form _) (eval env form)) #t body))
(define (@and env . body)
  (foldl (lambda (form v) (and v (eval env form))) #t body))
(define (@or env . body)
  (foldl (lambda (form v) (or v (eval env form))) #f body))
(define (@when env c . body)   (if (eval env c) (@body* env body) #t))
(define (@unless env c . body) (if (eval env c) #t (@body* env body)))
(define (@cond env . clauses)
  (if (null? clauses) #t
    (let ((? (eval env (caar clauses))))
      (if ? (if (null? (cdar clauses)) ? (@body* env (cdar clauses)))
        (apply @cond env (cdr clauses))))))

(define (defstate-actions-add-expr st form)
  (defstate-actions-add st (lambda (env) (eval env form))))
(define (defstate-run st)
  (define env (defstate-env st))
  (foldl (lambda (act _) (act env)) #t (reverse (defstate-actions st))))
(define (@begin/define st . forms)
  (foldl (lambda (form st)
           (let* ((n (and (pair? form) (string? (car form)) (car form)))
                  ($def (and n (env-get-prop (defstate-env st) n ctx:def #f))))
             (if $def (apply $def st (cdr form))
               (defstate-actions-add-expr st form)))) st forms))
(define (@def st param arg)
  (define names (param-names param))
  (defstate-actions-add
    (defstate-env-set
      (defstate-names-add st names)
      (env-extend*/var (env-pre-extend* (defstate-env st) names)
                       (map (lambda (n) (cons n #t)) names)))
    (lambda (env) (@set! env param arg))))
(define (@define st param . body)
  (if (pair? param)
    (@define st (car param) (lambda (e) (apply @lambda e (cdr param) body)))
    (@def st param (car body))))
(define (@body* env body)
  (defstate-run (apply @begin/define (defstate:empty env) body)))

;; Base environment construction
(define (ref-proc p) (cons ctx:var (lambda () p)))

(define env:primitive
  (append
    (map (lambda (b) (cons (car b) (list (ref-proc (cdr b))
                                         (cons ctx:op #t))))
         (list (cons 'if     @if)
               (cons 'reset  @reset)
               (cons 'shift  @shift)
               (cons 'lambda @lambda)
               (cons '$ (lambda (env rator . rands)
                          (apply (eval env rator) (cons env rands))))))
    (map (lambda (b) (cons (car b) (list (ref-proc (cdr b)))))
         (list (cons 'eval        eval)
               (cons 'apply       apply)
               (cons 'procedure?  procedure?)
               (cons 'mvector?    mvector?)
               (cons 'vector?     vector?)
               (cons 'pair?       pair?)
               (cons 'null?       null?)
               (cons 'boolean?    boolean?)
               (cons 'string?     string?)
               (cons 'number?     number?)
               (cons 'integer?    integer?)
               (cons 'fixnum?     fixnum?)
               (cons 'flonum?     flonum?)
               (cons 'boolean=?   boolean=?)
               (cons 'number=?    number=?)
               (cons 'string=?    string=?)
               (cons 'mvector=?   mvector=?)
               (cons 'procedure=? procedure=?)
               (cons 'string->vector string->vector)
               (cons 'vector->string vector->string)
               (cons 'cons cons)
               (cons 'car  car)
               (cons 'cdr  cdr)
               (cons 'vector-ref    vector-ref)
               (cons 'vector-length vector-length)
               (cons 'make-mvector    make-mvector)
               (cons 'mvector->vector mvector->vector)
               (cons 'mvector-set!    mvector-set!)
               (cons 'mvector-ref     mvector-ref)
               (cons 'mvector-length  mvector-length)
               (cons 'string<?        string<?)
               (cons 'string>?        string>?)
               (cons '=  =)
               (cons '<= <=)
               (cons '<  <)
               (cons '>= >=)
               (cons '>  >)
               (cons '+  +)
               (cons '*  *)
               (cons '-  -)
               (cons '/  /)
               ;; TODO: these and others?
               ;bitwise-and
               ;bitwise-ior
               ;bitwise-xor
               ;bitwise-not
               ;bitwise-bit-set?
               ;bitwise-bit-field
               ;arithmetic-shift
               ;integer-length
               ;round
               ;quotient
               ;remainder
               ))
    ;; These don't have to be primitive, but are provided for convenience.
    (list (cons 'define (list (cons 'define @define)))
          (cons 'def    (list (cons 'define @def)))
          (cons 'begin  (list (ref-proc @begin) (cons ctx:op #t)
                              (cons 'define @begin/define))))
    (map (lambda (b) (cons (car b) (list (ref-proc (cdr b)) (cons ctx:op #t))))
         (list (cons 'quote  @quote)
               (cons 'set!   @set!)
               (cons 'let    @let)
               (cons 'let*   @let*)
               (cons 'letrec @letrec)
               (cons 'and    @and)
               (cons 'or     @or)
               (cons 'when   @when)
               (cons 'unless @unless)
               (cons 'cond   @cond)))))

(define derived-ops
  '((error (lambda args ('error args)))
    (not (lambda (b) (if b #f #t)))
    (caar (lambda (v) (car (car v))))
    (cadr  (lambda (xs) (car (cdr xs))))
    (cdar (lambda (v) (cdr (car v))))
    (cadar (lambda (v) (cadr (car v))))
    (caddr (lambda (xs) (cadr (cdr xs))))
    (list-tail (lambda (xs i) (if (= 0 i) xs (list-tail (cdr xs) (- i 1)))))
    (list-ref  (lambda (xs i) (car (list-tail xs i))))
    (list->vector (lambda (xs)
                    (define result (make-mvector (length xs) #t))
                    (foldl (lambda (x i) (mvector-set! result i x) (+ i 1))
                           0 xs)
                    (mvector->vector result)))
    (vector->list (lambda (v)
                    (let loop ((i (- (vector-length v) 1)) (xs '()))
                      (if (< i 0) xs
                        (loop (- i 1) (cons (vector-ref v i) xs))))))
    (equal? (lambda (a b)
              (cond ((pair? a)   (and (pair? b) (equal? (car a) (car b))
                                      (equal? (cdr a) (cdr b))))
                    ((vector? a) (and (vector? b) (equal? (vector->list a)
                                                          (vector->list b))))
                    ((boolean? a)   (and (boolean? b)   (boolean=? a b)))
                    ((string?  a)   (and (string?  b)   (string=?  a b)))
                    ((number?  a)   (and (number?  b)   (number=?  a b)))
                    ((mvector? a)   (and (mvector? b)   (mvector=? a b)))
                    ((procedure? a) (and (procedure? b) (procedure=? a b)))
                    ((null? a)      (null? b)))))
    (vector (lambda xs (list->vector xs)))
    (list?  (lambda (v) (or (and (pair? v) (list? (cdr v))) (null? v))))
    (list   (lambda xs xs))
    (list*  (lambda (x . xs) (if (null? xs) x (cons x (apply list* xs)))))
    (foldl  (lambda (f acc xs) (if (null? xs) acc
                                 (foldl f (f (car xs) acc) (cdr xs)))))
    (foldr  (lambda (f acc xs) (if (null? xs) acc
                                 (f (car xs) (foldr f acc (cdr xs))))))
    (map (lambda (f xs . xss)
           (define (map1 f xs) (if (null? xs) '()
                                 (cons (f (car xs)) (map1 f (cdr xs)))))
           (cond ((null? xs) '())
                 (#t (cons (apply f (car xs) (map1 car xss))
                           (apply map f (cdr xs) (map1 cdr xss)))))))
    (for-each (lambda args (apply map args) #t))
    (andmap (lambda (f xs . xss)
              (let loop ((last #t) (xs xs) (xss xss))
                (and last (if (null? xs) last
                            (loop (apply f (car xs) (map car xss))
                                  (cdr xs) (map cdr xss)))))))
    (ormap (lambda (f xs . xss)
             (cond ((null? xs) #f)
                   ((apply f (car xs) (map car xss)))
                   (#t (apply ormap f (cdr xs) (map cdr xss))))))
    (filter (lambda (p? xs)
              (cond ((null? xs) '())
                    ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
                    (#t (filter p? (cdr xs))))))
    (filter-not (lambda (p? xs) (filter (lambda (x) (not (p? x))) xs)))
    (remf (lambda (p? xs)
            (cond ((null? xs)    '())
                  ((p? (car xs)) (cdr xs))
                  (#t (cons (car xs) (remf p? (cdr xs)))))))
    (remove (lambda (v xs) (remf (lambda (x) (equal? x v)) xs)))
    (length (lambda (xs) (foldl (lambda (_ l) (+ 1 l)) 0 xs)))
    (append (lambda xss (foldr (lambda (xs yss) (foldr cons yss xs)) '() xss)))
    (reverse-append (lambda (xs ys) (foldl cons ys xs)))
    (reverse (lambda (xs) (reverse-append xs '())))
    (range (lambda (n)
             (let loop ((i 0)) (if (= i n) '() (cons i (loop (+ i 1)))))))
    (take (lambda (xs n) (if (= 0 n) '()
                           (cons (car xs) (take (cdr xs) (- n 1))))))
    (drop (lambda (xs n) (if (= 0 n) xs (drop (cdr xs) (- n 1)))))
    (memf (lambda (? xs) (cond ((null? xs) #f)
                               ((? (car xs)) xs)
                               (#t (memf ? (cdr xs))))))
    (member (lambda (v xs) (memf (lambda (x) (equal? x v)) xs)))
    (assoc (lambda (k xs) (cond ((null? xs) #f)
                                ((equal? k (caar xs)) (car xs))
                                (#t (assoc k (cdr xs))))))
    (alist-get (lambda (rs key default) (let ((rib (assoc key rs)))
                                          (if rib (cdr rib) default))))
    (alist-remove* (lambda (rs keys)
                     (filter (lambda (rib) (not (member (car rib) keys))) rs)))
    (string-append (lambda ss
                     (define css (map vector->list (map string->vector ss)))
                     (vector->string (list->vector (apply append css)))))
    ))

(define env:base
  (eval env:primitive
        (list 'let '((apply (lambda (f arg . args)
                              (define (cons* x xs)
                                (if (null? xs) x
                                  (cons x (cons* (car xs) (cdr xs)))))
                              (apply f (cons* arg args)))))
              (list 'letrec derived-ops '($ (lambda (env) env))))))

(define (test! test)
  (define (ev code) (eval env:base code))

  (test '$-1 ;; $ applies a procedure with current environment and raw syntax.
    (ev '($ (lambda (env . tree) tree) 4 5))
    '(4 5))
  (test '$-2 ;; We can even apply such procedures with improper argument lists.
    (ev '($ (lambda (env . tree) tree) 4 . 5))
    '(4 . 5))
  (test '$-3
    (ev '($ (lambda (env) (((cdr (assoc 'ref (cdr (assoc 'vector env)))))
                           1 2 3))))
    '#(1 2 3))

  (test 'apply-lambda-1
    (ev '((apply lambda (cons '()        ;; empty env
                              '(_ 5))))) ;; quote is unbound
    5)
  (test 'apply-lambda-2
    (ev (list (list 'apply 'lambda
                    (list 'cons (lambda (env) env) ;; spliced evaluator
                          ''(_ '5)))))             ;; quote is bound
    5)
  (test 'apply-lambda-3
    (ev '((apply lambda (cons ($ (lambda (env) env)) ;; evaluator via $
                              '(_ '5)))))            ;; quote is bound
    5)
  (test 'apply-lambda-4
    (ev '((((lambda (x) x) lambda) ;; another applicative lambda example
           ($ (lambda (env) env)) '_ ''5)))
    5))
