(provide stage env:primitive base:stage base:library base:program)

(require length=? length>=? param?! bpair*?! param-map param-names
         ctx:var ctx:set! ctx:op ctx:def
         env:empty env-ref env-get-prop env-extend*
         defstate:empty defstate-env defstate-names defstate-actions
         defstate-env-set defstate-names-add defstate-actions-add
         ast:quote ast:var ast:set! ast:if ast:apply ast:lambda
         ast:prim ast:context primitive-op-descriptions)

(define (env-extend*/var env n*)
  (param?! n*)
  (define (bind n)
    (define rn (make-mvector 1 n))
    (cons n (list (cons ctx:var rn) (cons ctx:set! rn))))
  (env-extend* env (map bind n*)))
(define (env-extend*/syntax env ctx b*)
  (define (bind b) (let ((n (car b)))
                     (cons n (cons (cons ctx (cdr b)) (env-ref env n)))))
  (env-extend* env (map bind b*)))
(define (env-freeze env)
  (map (lambda (b) (cons (car b) (alist-remove* (cdr b) (list ctx:set!))))
       env))
(define (param/renamings env param)
  (param-map (lambda (n) (env-get-prop env n ctx:var #f)) param))

;; High-level AST construction
(define ast:null        (ast:quote '()))
(define ast:true        (ast:quote #t))
(define ast:false       (ast:quote #f))
(define (ast:cons a d)  (ast:prim 'cons (list a d)))
(define (ast:list . xs) (foldr ast:cons ast:null xs))
(define (ast:vector . xs)
  (define vargs (list (ast:quote (length xs)) ast:true))
  (define $mv (ast:var 'mv))
  (define (! i x) (ast:prim 'mvector-set! (list $mv (ast:quote i) x)))
  (ast:let '(mv) (list (ast:prim 'make-mvector vargs))
           (ast:begin (append (map ! (range (length xs)) xs)
                              (list (ast:prim 'mvector->vector (list $mv)))))))
(define (ast:apply* $proc $a*) (ast:apply $proc (apply ast:list $a*)))
(define (ast:let p* v* body)   (ast:apply* (ast:lambda p* body) v*))
(define (ast:begin a*)
  (define ra* (reverse (cons ast:true a*)))
  (foldl (lambda (a rest) (ast:let '(#f) (list a) rest)) (car ra*) (cdr ra*)))
(define (ast:shift proc) (ast:context 'shift (list proc)))
(define (ast:reset body) (ast:context 'reset (list (ast:lambda '() body))))

;; Staging
(define (stage env form)
  (cond ((pair? form)
         (let ((p (car form)) (a* (cdr form)))
           (let ((op (and (string? p) (env-get-prop env p ctx:op #f))))
             (if op (apply op env a*)
               (ast:apply* (stage env p) (stage* env a*))))))
        ((string? form) (ast:var (or (env-get-prop env form ctx:var #f)
                                     (error '"unbound variable:" form))))
        ((or (boolean? form) (number? form)) (ast:quote form))
        ((procedure? form)                   (form env))
        (#t                                  (error '"invalid syntax:" form))))
(define (stage* env form*) (map (lambda (f) (stage env f)) form*))

(define (@apply env proc arg) (ast:apply (stage env proc) (stage env arg)))
(define (@quote env datum)    (ast:quote datum))
(define (@reset env . body)   (ast:reset (@body* env body)))
(define (@shift env k . body) (ast:shift (apply @lambda env (list k) body)))
(define (@set! env param arg)
  (define (setter n) (or (env-get-prop env n ctx:set! #f)
                         (error '"cannot set! variable:" n)))
  (ast:set! (param-map setter param) (stage env arg)))
(define (@if env c t f) (ast:if (stage env c) (stage env t) (stage env f)))
(define (@lambda env param . body)
  (define benv (env-extend*/var env (param-names param)))
  (ast:lambda (param/renamings benv param) (@body* benv body)))
(define (@let/ env b* . body)
  (bpair*?! b*)
  (ast:apply* (apply @lambda env (map car b*) body)
              (stage* env (map cadr b*))))
(define (@let/name env n b* . body)
  (bpair*?! b*)
  (define (p env) (apply @lambda env (map car b*) body))
  (ast:apply* (@letrec env (list (list n p)) n) (stage* env (map cadr b*))))
(define (@let env . tail)
  (cond ((and (length>=? 2 tail) (string? (car tail)) (bpair*?! (cadr tail)))
         (apply @let/name env tail))
        (#t (bpair*?! (car tail)) (apply @let/ env tail))))
(define (@letrec env b* . body)
  (bpair*?! b*)
  (define (k env) (ast:begin (append (map (lambda (b) (apply @set! env b)) b*)
                                     (list (apply @let env '() body)))))
  (@let env (map (lambda (b) (list (car b) #t)) b*) k))
(define (@let* env b* . body)
  (bpair*?! b*)
  (let loop ((b* b*) (env env))
    (if (null? b*) (@body* env body)
      (@let/ env (list (car b*)) (lambda (env) (loop (cdr b*) env))))))
(define (@and env . args)
  (define ra* (reverse (cons #t args)))
  (foldl (lambda (a rest) (@if env a (lambda (_) rest) #f))
         (stage env (car ra*)) (cdr ra*)))
(define (@or env . args)
  (foldr (lambda (arg rest)
           (@let env (list (list 'temp arg))
                 (lambda (env) (@if env 'temp 'temp (lambda (_) rest)))))
         ast:false args))
(define (@cond env . clauses)
  (foldr (lambda (c rest)
           (unless (length>=? 1 c) (error '"invalid cond clause:" c))
           (if (null? (cdr c)) (@or env (car c) (lambda (_) rest))
             (@if env (car c) (lambda (env) (@body* env (cdr c)))
                  (lambda (_) rest)))) ast:true clauses))
(define (@begin env . body)    (ast:begin (stage* env body)))
(define (@when env c . body)   (@if env c (lambda (env) (@body* env body)) #t))
(define (@unless env c . body) (@if env c #t (lambda (env) (@body* env body))))

(define (defstate-actions-add-expr st form)
  (defstate-actions-add st (lambda (env) (stage env form))))
(define (defstate-run st)
  (let ((actions (reverse (defstate-actions st)))
        (env (defstate-env st)) (names (defstate-names st)))
    (ast:let (param/renamings env names) (map (lambda (_) ast:true) names)
             (ast:begin (map (lambda (act) (act env)) actions)))))
(define (@begin/define st . forms)
  (foldl (lambda (form st)
           (let* ((n (and (pair? form) (string? (car form)) (car form)))
                  ($def (and n (env-get-prop (defstate-env st) n ctx:def #f))))
             (if $def (apply $def st (cdr form))
               (defstate-actions-add-expr st form)))) st forms))
(define (@def st param arg)
  (define names (param-names param))
  (define env (env-extend*/var (defstate-env st) names))
  (defstate-actions-add (defstate-env-set (defstate-names-add st names) env)
                        (lambda (env) (@set! env param arg))))
(define (@define st param . body)
  (if (pair? param)
    (@define st (car param)
             (lambda (env) (apply @lambda env (cdr param) body)))
    (apply @def st param body)))
(define (@body* env body*)
  (defstate-run (apply @begin/define (defstate:empty env) body*)))

;; Primitive language definition
(define (stager:primitive-syntax name proc arity exact?)
  (cons name (lambda (env . tail)
               (unless ((if exact? length=? length>=?) arity tail)
                 (error '"invalid syntax arity:" arity (cons name tail)))
               (apply proc env tail))))
(define primitive-syntax-bindings
  (append
    (map (lambda (desc) (apply stager:primitive-syntax desc))
         (list (list 'apply  @apply  2 #t)
               (list 'quote  @quote  1 #t)
               (list 'if     @if     3 #t)
               (list 'set!   @set!   2 #t)
               (list 'reset  @reset  0 #f)
               (list 'shift  @shift  1 #f)
               (list 'lambda @lambda 1 #f)
               (list 'letrec @letrec 1 #f)
               (list 'let    @let    1 #f)
               (list 'let*   @let*   1 #f)
               (list 'begin  @begin  0 #f)
               (list 'cond   @cond   0 #f)
               (list 'and    @and    0 #f)
               (list 'or     @or     0 #f)
               (list 'when   @when   1 #f)
               (list 'unless @unless 1 #f)))
    (map (lambda (po-desc)
           (cons (car po-desc)
                 (lambda (env . tail)
                   (unless (length=? (length (cadr po-desc)) tail)
                     (error '"invalid primitive op:" po-desc tail))
                   (ast:prim (car po-desc) (stage* env tail)))))
         primitive-op-descriptions)))

(define env:primitive
  (env-extend*/syntax
    (env-extend*/syntax env:empty ctx:op primitive-syntax-bindings)
    ctx:def (list (cons 'begin  @begin/define)
                  (cons 'define @define)
                  (cons 'def    @def))))

;; Base library definition
(define primitive-op-procs
  (map (lambda (po-desc)
         (define (x i) (vector-ref '#(x0 x1 x2 x3 x4) i))
         (define p* (map x (range (length (cadr po-desc)))))
         (list (car po-desc) (list 'lambda p* (cons (car po-desc) p*))))
       primitive-op-descriptions))

(define derived-op-procs
  '((error (lambda args ('error args)))
    (not (lambda (b) (if b #f #t)))
    (caar (lambda (v) (car (car v))))
    (cadr  (lambda (xs) (car (cdr xs))))
    (cdar (lambda (v) (cdr (car v))))
    (cadar (lambda (v) (cadr (car v))))
    (caddr (lambda (xs) (cadr (cdr xs))))
    (list-tail (lambda (xs i) (if (= 0 i) xs (list-tail (cdr xs) (- i 1)))))
    (list-ref  (lambda (xs i) (car (list-tail xs i))))
    (list->vector (lambda (xs)
                    (define result (make-mvector (length xs) #t))
                    (foldl (lambda (x i) (mvector-set! result i x) (+ i 1))
                           0 xs)
                    (mvector->vector result)))
    (vector->list (lambda (v)
                    (let loop ((i (- (vector-length v) 1)) (xs '()))
                      (if (< i 0) xs
                        (loop (- i 1) (cons (vector-ref v i) xs))))))
    (equal? (lambda (a b)
              (cond ((pair? a)   (and (pair? b) (equal? (car a) (car b))
                                      (equal? (cdr a) (cdr b))))
                    ((vector? a) (and (vector? b) (equal? (vector->list a)
                                                          (vector->list b))))
                    ((boolean? a)   (and (boolean? b)   (boolean=? a b)))
                    ((string?  a)   (and (string?  b)   (string=?  a b)))
                    ((number?  a)   (and (number?  b)   (number=?  a b)))
                    ((mvector? a)   (and (mvector? b)   (mvector=? a b)))
                    ((procedure? a) (and (procedure? b) (procedure=? a b)))
                    ((null? a)      (null? b)))))
    (vector (lambda xs (list->vector xs)))
    (list?  (lambda (v) (or (and (pair? v) (list? (cdr v))) (null? v))))
    (list   (lambda xs xs))
    (list*  (lambda (x . xs) (if (null? xs) x (cons x (apply list* xs)))))
    ;; TODO: n-ary versions of foldl, foldr.
    (foldl  (lambda (f acc xs) (if (null? xs) acc
                                 (foldl f (f (car xs) acc) (cdr xs)))))
    (foldr  (lambda (f acc xs) (if (null? xs) acc
                                 (f (car xs) (foldr f acc (cdr xs))))))
    (map (lambda (f xs . xss)
           (define (map1 f xs) (if (null? xs) '()
                                 (cons (f (car xs)) (map1 f (cdr xs)))))
           (cond ((null? xs) '())
                 (#t (cons (apply f (car xs) (map1 car xss))
                           (apply map f (cdr xs) (map1 cdr xss)))))))
    (for-each (lambda args (apply map args) #t))
    (andmap (lambda (f xs . xss)
              (let loop ((last #t) (xs xs) (xss xss))
                (and last (if (null? xs) last
                            (loop (apply f (car xs) (map car xss))
                                  (cdr xs) (map cdr xss)))))))
    (ormap (lambda (f xs . xss)
             (cond ((null? xs) #f)
                   ((apply f (car xs) (map car xss)))
                   (#t (apply ormap f (cdr xs) (map cdr xss))))))
    (filter (lambda (p? xs)
              (cond ((null? xs) '())
                    ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
                    (#t (filter p? (cdr xs))))))
    (filter-not (lambda (p? xs) (filter (lambda (x) (not (p? x))) xs)))
    (remf (lambda (p? xs)
            (cond ((null? xs)    '())
                  ((p? (car xs)) (cdr xs))
                  (#t (cons (car xs) (remf p? (cdr xs)))))))
    (remove (lambda (v xs) (remf (lambda (x) (equal? x v)) xs)))
    (length (lambda (xs) (foldl (lambda (_ l) (+ 1 l)) 0 xs)))
    (append (lambda xss (foldr (lambda (xs yss) (foldr cons yss xs)) '() xss)))
    (reverse-append (lambda (xs ys) (foldl cons ys xs)))
    (reverse (lambda (xs) (reverse-append xs '())))
    (range (lambda (n)
             (let loop ((i 0)) (if (= i n) '() (cons i (loop (+ i 1)))))))
    (take (lambda (xs n) (if (= 0 n) '()
                           (cons (car xs) (take (cdr xs) (- n 1))))))
    (drop (lambda (xs n) (if (= 0 n) xs (drop (cdr xs) (- n 1)))))
    (memf (lambda (? xs) (cond ((null? xs) #f)
                               ((? (car xs)) xs)
                               (#t (memf ? (cdr xs))))))
    (member (lambda (v xs) (memf (lambda (x) (equal? x v)) xs)))
    (assoc (lambda (k xs) (cond ((null? xs) #f)
                                ((equal? k (caar xs)) (car xs))
                                (#t (assoc k (cdr xs))))))
    (alist-get (lambda (rs key default) (let ((rib (assoc key rs)))
                                          (if rib (cdr rib) default))))
    (alist-remove* (lambda (rs keys)
                     (filter (lambda (rib) (not (member (car rib) keys))) rs)))
    (string-append (lambda ss
                     (define css (map vector->list (map string->vector ss)))
                     (vector->string (list->vector (apply append css)))))
    ))

(define base:library-names #t)
(define (base:linker env)
  (set! base:library-names
    (map car (filter (lambda (rib) (alist-get (cdr rib) ctx:var #f)) env)))
  (@lambda env '(f) (cons 'f base:library-names)))
(define base:library
  (stage env:primitive
         (list 'let primitive-op-procs
               (list 'let '((apply (lambda (f arg . args)
                                     (define (cons* x xs)
                                       (if (null? xs) x
                                         (cons x (cons* (car xs) (cdr xs)))))
                                     (apply f (cons* arg args)))))
                     (list 'letrec derived-op-procs base:linker)))))

;; Program construction
(define (base:program form)
  (@lambda env:primitive base:library-names
           (lambda (env) (stage (env-freeze env) form))))
(define (base:stage form) (ast:apply* base:library (list (base:program form))))
