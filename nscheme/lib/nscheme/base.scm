(provide lang:base parse env-reify)

(require ast:quote ast:var ast:set! ast:if ast:apply ast:lambda
         ast:reset ast:shift ast:prim primitive-ops)

;; Pattern matching
(define (length=? len xs)  (and (list? xs) (= (length xs) len)))
(define (length>=? len xs) (and (list? xs) (>= (length xs) len)))

;; Syntactic environments
(define (name? n) (string? n))
(define (fresh-uid name) (make-mvector 1 name))
(define ctx:var  'variable)
(define ctx:set! 'set!)
(define ctx:op   'operator)
(define ctx:def  'definition)
(define (binding name ctx uid value) (vector name ctx uid value))
(define (binding-name b)             (vector-ref b 0))
(define (binding-context b)          (vector-ref b 1))
(define (binding-uid b)              (vector-ref b 2))
(define (binding-value b)            (vector-ref b 3))
(define (binding:var name uid)  (binding name ctx:var uid ast:var))
(define (binding:set! name uid) (binding name ctx:set! uid ast:set!))

(define env:empty            '())
(define (env-extend* env b*) (append b* env))
(define (env-ref env ctx* n)
  (define b*? (memf (lambda (b) (and (equal? (binding-name b) n)
                                     (member (binding-context b) ctx*))) env))
  (or (and b*? (car b*?)) (binding n (car ctx*) n #f)))
(define (env-ref? env ctx* n)
  (define b (env-ref env ctx* n))
  (and (equal? (binding-context b) (car ctx*)) (binding-value b) b))
(define (env-extend*/var env b?*)
  (foldl (lambda (b* env) (env-extend* env b*)) env
         (map (lambda (b) (list (binding:set! (car b) (cdr b))
                                (binding:var (car b) (cdr b))))
              (filter (lambda (b?) (car b?)) b?*))))
(define (env-extend*/syntax env ctx b*)
  (env-extend* env (map (lambda (b) (define n (car b)) (define parse (cdr b))
                          (binding n ctx (fresh-uid n) parse)) b*)))
(define (env-freeze env)
  (filter-not (lambda (b) (equal? (binding-context b) ctx:set!)) env))

;; Parameters
(define (param? p) (or (not p) (name? p)))
(define (bpair*?! b*)
  (define (? b) (and (length=? 2 b) (param? (car b))))
  (unless (and (list? b*) (andmap ? b*)) (error '"invalid binding list:" b*)))

;; High-level AST construction
(define $null               (ast:quote '()))
(define $true               (ast:quote #t))
(define $false              (ast:quote #f))
(define ($cons a d)         (ast:prim 'cons (list a d)))
(define ($list . xs)        (foldr $cons $null xs))
(define ($vector . xs)
  ($let '(mv) (list (ast:prim 'make-mvector
                              (list (ast:quote (length xs)) $true)))
        (lambda (b*)
          (define $mv (b*-var b* 'mv))
          (define (! i x) (ast:prim 'mvector-set! (list $mv (ast:quote i) x)))
          ($begin (map ! (range (length xs)) xs)
                  (ast:prim 'mvector->vector (list $mv))))))
(define ($error . a*)       (ast:apply (ast:quote 'error) (apply $list a*)))
(define ($apply* $proc $a*) (ast:apply $proc (apply $list $a*)))
(define ($lambda ~ps b?*->body)
  (let loop ((~p?* ~ps) (p* '()) (a* '()) (b* '()))
    (cond ((pair? ~p?*)
           (define p (car ~p?*))
           (unless (param? p) (error '"invalid parameters:" ~ps))
           (when (and p (member p p*)) (error '"duplicate parameters:" ~ps))
           (define a (and p (fresh-uid p)))
           (loop (cdr ~p?*) (if p p* (cons p p*)) (cons a a*)
                 (cons (cons p a) b*)))
          (#t (define a (if (null? ~p?*) '() (and ~p?* (fresh-uid ~p?*))))
           (define b?* (reverse (if (null? a) b* (cons (cons ~p?* a) b*))))
           (ast:lambda (reverse-append a* a) (b?*->body b?*))))))
(define ($let p?* v* b?*->body) ($apply* ($lambda p?* b?*->body) v*))
(define ($begin body-initial* body-final)
  (cond ((null? body-initial*) body-final)
        (#t ($let '(#f) (list (car body-initial*))
                  (lambda (_) ($begin (cdr body-initial*) body-final))))))

;; Parsing
(define expander:tag      'expander)
(define (expander proc)   (vector expander:tag proc))
(define (expander-proc d) (vector-ref d 1))
(define (expander? d)     (and (vector? d) (= (vector-length d) 2)
                               (equal? (vector-ref d 0) expander:tag)))
(define (parse env form)
  (let loop ((form form))
    (cond ((or (boolean? form) (number? form)) (ast:quote form))
          ((parse:op? env form))
          ((expander? form)    ((expander-proc form) env))
          ((name? form)        (parse:var env form))
          ((length>=? 1 form)  (parse:apply env (car form) (cdr form)))
          (#t                  (error '"invalid syntax:" form)))))
(define (parse* env form*) (map (lambda (f) (parse env f)) form*))

(define (parse:var env n)
  (define b (or (env-ref? env (list ctx:var) n)
                (error '"unbound variable:" n)))
  ((binding-value b) (binding-uid b)))
(define (parse:set! env n $rhs)
  (define b (or (env-ref? env (list ctx:set! ctx:var) n)
                (error '"cannot set! variable:" n)))
  ((binding-value b) (binding-uid b) $rhs))
(define (parse:op? env form)
  (let* ((n (and (pair? form) (car form)))
         (b (and (name? n) (env-ref? env (list ctx:op ctx:var) n))))
    (and b ((binding-value b) env form))))
(define (parse:def? st form)
  (let* ((n (and (pair? form) (car form)))
         (b (and (name? n) (env-ref? (defst-env st)
                                     (list ctx:def ctx:op ctx:var) n))))
    (and b ((binding-value b) st form))))
(define (b*-var b* name) (parse (env-extend*/var env:empty b*) name))

(define (parse:apply env p a*) ($apply* (parse env p) (parse* env a*)))
(define (b?*->parse:body* env body*)
  (lambda (b?*) (parse:body* (env-extend*/var env b?*) body*)))
(define (parse:lambda env ~p?* body*)
  ($lambda ~p?* (b?*->parse:body* env body*)))
(define (parse:let env p?* e* body*)
  ($let p?* (parse* env e*) (b?*->parse:body* env body*)))
(define (parse:letrec env p?* e* env->body)
  (define uninitialized* (map (lambda (_) $true) p?*))
  (define (b?*->body b?*)
    (let* ((env (env-extend*/var env b?*))
           (v* (parse* env e*)) (a?* (map cdr b?*)) (body (env->body env)))
      ($begin (map (lambda (a? v) (if a? (ast:set! a? v) v)) a?* v*) body)))
  ($let p?* uninitialized* b?*->body))

(define (defst:empty env) (vector env '()))
(define (defst-env st)    (vector-ref st 0))
(define (defst-rdef* st)  (vector-ref st 1))
(define ($define st n def-body)
  (vector (defst-env st) (cons (cons n def-body) (defst-rdef* st))))
;; TODO: $define-syntax ?
(define (parse:definition* st form*)
  (foldl (lambda (form st) (cond ((parse:def? st form))
                                 (#t ($define st #f form)))) st form*))
(define (parse:begin st form)
  (cond ((length>=? 1 form) (parse:definition* st (list-tail form 1)))
        (#t                 (error '"invalid begin:" form))))
(define (parse:define st form)
  (define (@ i) (list-ref form i)) (define (@. i) (list-tail form i))
  (cond ((and (length=? 3 form) (param? (@ 1))) ($define st (@ 1) (@ 2)))
        ((and (length>=? 3 form) (pair? (@ 1)) (name? (car (@ 1))))
         (define (edef env) (parse:lambda env (cdr (@ 1)) (@. 2)))
         ($define st (car (@ 1)) (expander edef)))
        (#t (error '"invalid define:" form))))

(define (parse:body* env body*)
  (define ($define n def-body rdef*) (cons (cons n def-body) rdef*))
  (unless (list? body*) (error '"body must be a list:" body*))
  (define rdef* (defst-rdef* (parse:definition* (defst:empty env) body*)))
  (when (null? rdef*) (error '"body cannot be empty:" body*))
  (define p?e* (reverse (cdr rdef*)))
  (define final-def (car rdef*))
  (define body-final (cdr final-def))
  (when (car final-def) (error '"body cannot end with a definition:" body*))
  (parse:letrec env (map car p?e*) (map cdr p?e*)
                (lambda (env) (parse env body-final))))
(define (parse:and* env e*)
  (define re* (reverse e*))
  (if (null? re*) $true
    (foldr (lambda (e r) (ast:if (parse env e) r $false))
           (parse env (car re*)) (reverse (cdr re*)))))
(define (parse:or2 env e $rest)
  (define (body b*) (let (($tmp (b*-var b* 'tmp))) (ast:if $tmp $tmp $rest)))
  ($apply* ($lambda (list 'tmp) body) (list (parse env e))))

(define (env-reify env)
  (define (uids c)
    (map binding-uid (filter (lambda (b) (equal? (binding-context b) c)) env)))
  (define dup-uids (foldr append '() (map uids (list ctx:set! ctx:var))))
  (define (env-uid ctx uid)
    (define b*? (memf (lambda (b) (and (equal? (binding-uid b) uid)
                                       (equal? (binding-context b) ctx))) env))
    (and b*? (car b*?)))
  (define (uid-caps uid)
    (define b@ (env-uid ctx:var uid))
    (define b! (env-uid ctx:set! uid))
    (define (get _)  (if b@ ((binding-value b@) uid) $true))
    (define (set b*) (if b! ((binding-value b!) uid (b*-var b* 'v)) $true))
    ($cons (ast:quote uid) ($cons ($lambda '() get) ($lambda '(v) set))))
  (define renv (map uid-caps (remove-duplicates dup-uids)))
  ($vector (apply $list renv) (ast:quote env)))

,(
;; Parsers for primitive syntax (no var dependencies)
(define parsers:primitive
  '((apply ((length=? 3 form) (ast:apply (loop (@ 1)) (loop (@ 2)))))
    (quote ((length=? 2 form) (ast:quote (@ 1))))
    (if    ((length=? 4 form) (ast:if (loop (@ 1)) (loop (@ 2)) (loop (@ 3)))))
    (set!  ((and (length=? 3 form) (name? (@ 1)))
            (parse:set! env (@ 1) (loop (@ 2)))))
    (reset ((length>=? 2 form) (ast:reset (parse:body* env (@. 1)))))
    (shift ((length>=? 3 form)
            (ast:shift ($lambda (list (@ 1)) (b?*->parse:body* env (@. 2))))))
    (lambda ((length>=? 3 form) (parse:lambda env (@ 1) (@. 2))))
    (letrec ((and (length>=? 3 form) (bpair*?! (@ 1)))
             (parse:letrec env (map car (@ 1)) (map cadr (@ 1))
                           (lambda (env) (parse:body* env (@. 2))))))
    (let . (((and (length>=? 4 form) (name? (@ 1)) (bpair*?! (@ 2)))
             (define (ex-proc env) (parse:lambda env (map car (@ 2)) (@. 3)))
             (parse:letrec env (list (@ 1)) (list (expander ex-proc))
                           (lambda (env)
                             (parse:apply env (@ 1) (map cadr (@ 2))))))
            ((and (length>=? 3 form) (bpair*?! (@ 1)))
             (parse:let env (map car (@ 1)) (map cadr (@ 1)) (@. 2)))))
    (let* ((and (length>=? 3 form) (bpair*?! (@ 1)))
           (let loop ((b* (@ 1)) (env env))
             (define (next b?*) (loop (cdr b*) (env-extend*/var env b?*)))
             (cond ((null? b*) (parse:body* env (@. 2)))
                   ((pair? b*) ($let (list (caar b*))
                                     (list (parse env (cadar b*))) next))))))
    (begin ((length>=? 2 form) (define rb* (reverse (map loop (@. 1))))
                               ($begin (reverse (cdr rb*)) (car rb*))))
    (cond ((and (length>=? 2 form)
                (andmap (lambda (c) (length>=? 1 c)) (@. 1)))
           (foldr (lambda (c $*)
                    (if (null? (cdr c)) (parse:or2 env (car c) $*)
                      (ast:if (loop (car c)) (parse:body* env (cdr c)) $*)))
                  ($error (ast:quote '"no matching cond clause:")
                          (ast:quote form)) (@. 1))))
    (and ((length>=? 1 form) (parse:and* env (@. 1))))
    (or  ((length>=? 1 form)
          (foldr (lambda (e r) (parse:or2 env e r)) $false (@. 1))))
    (when   ((length>=? 3 form)
             (ast:if (loop (@ 1)) (parse:body* env (@. 2)) $true)))
    (unless ((length>=? 3 form)
             (ast:if (loop (@ 1)) $true (parse:body* env (@. 2)))))))

;; Primitive language definition
(define code:syntax
  (map (lambda (name&clause*)
         (list 'cons (list 'quote (car name&clause*))
               (list 'lambda '(env form)
                     '(define (loop form) (parse env form))
                     '(define (@ i) (list-ref form i))
                     '(define (@. i) (list-tail form i))
                     (cons 'cond (append (cdr name&clause*)
                                         '((#t (error '"invalid syntax:"
                                                      form))))))))
       parsers:primitive))
(define code:prims
  '(map (lambda (po-desc)
          (define name (car po-desc))
          (cons name
                (lambda (env form)
                  (cond ((length=? (+ (length (cadr po-desc)) 1) form)
                         (ast:prim name (parse* env (list-tail form 1))))
                        (#t (error '"invalid primitive op:"
                                   po-desc form))))))
        primitive-ops))
(define code:ops (cons 'list* (append code:syntax (list code:prims))))
(define code:env:primitive
  (list 'env-extend*/syntax
        (list 'env-extend*/syntax 'env:empty 'ctx:op code:ops)
        'ctx:def '(list (cons 'begin parse:begin)
                        (cons 'define parse:define))))
(list 'begin (list 'define 'env:primitive code:env:primitive)
      '(define (lang:primitive form) (parse env:primitive form)))
)

;; Base language definition
(define primitive-op-procs
  (map (lambda (po-desc)
         (define (x i) (string-append 'x (number->string i)))
         (define p* (map x (range (length (cadr po-desc)))))
         (list (car po-desc) (list 'lambda p* (cons (car po-desc) p*))))
       primitive-ops))

(define derived-op-procs
  '((error (lambda args ('error args)))
    (not (lambda (b) (if b #f #t)))
    (list->vector (lambda (xs)
                    (define result (make-mvector (length xs) #t))
                    (foldl (lambda (x i) (mvector-set! result i x) (+ i 1))
                           0 xs)
                    (mvector->vector result)))
    (vector->list (lambda (v)
                    (let loop ((i (- (vector-length v) 1)) (xs '()))
                      (if (< i 0) xs
                        (loop (- i 1) (cons (vector-ref v i) xs))))))
    (equal? (lambda (a b)
              (cond ((pair? a)   (and (pair? b) (equal? (car a) (car b))
                                      (equal? (cdr a) (cdr b))))
                    ((vector? a) (and (vector? b) (equal? (vector->list a)
                                                          (vector->list b))))
                    ((boolean? a)   (and (boolean? b)   (boolean=? a b)))
                    ((string?  a)   (and (string?  b)   (string=?  a b)))
                    ((number?  a)   (and (number?  b)   (number=?  a b)))
                    ((mvector? a)   (and (mvector? b)   (mvector=? a b)))
                    ((procedure? a) (and (procedure? b) (procedure=? a b)))
                    ((null? a)      (null? b)))))
    (vector (lambda xs (list->vector xs)))
    (list?  (lambda (v) (or (and (pair? v) (list? (cdr v))) (null? v))))
    (list   (lambda xs xs))
    (list*  (lambda (x . xs) (cons* x xs)))
    (foldl  (lambda (f acc xs) (if (null? xs) acc
                                 (foldl f (f (car xs) acc) (cdr xs)))))
    (foldr  (lambda (f acc xs) (if (null? xs) acc
                                 (f (car xs) (foldr f acc (cdr xs))))))
    (map (lambda (f xs . xss)
           (define (map1 f xs) (if (null? xs) '()
                                 (cons (f (car xs)) (map1 f (cdr xs)))))
           (cond ((null? xs) '())
                 (#t (cons (apply f (car xs) (map1 car xss))
                           (apply map f (cdr xs) (map1 cdr xss)))))))
    (andmap (lambda (f xs . xss)
              (let loop ((last #t) (xs xs) (xss xss))
                (and last (if (null? xs) last
                            (loop (apply f (car xs) (map car xss))
                                  (cdr xs) (map cdr xss)))))))
    (ormap (lambda (f xs . xss)
             (cond ((null? xs) #f)
                   ((apply f (car xs) (map car xss)))
                   (#t (apply ormap f (cdr xs) (map cdr xss))))))
    (filter (lambda (p? xs)
              (cond ((null? xs) '())
                    ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
                    (#t (filter p? (cdr xs))))))
    (filter-not (lambda (p? xs) (filter (lambda (x) (not (p? x))) xs)))
    (length (lambda (xs) (foldl (lambda (_ l) (+ 1 l)) 0 xs)))
    (append (lambda xss (foldr (lambda (xs yss) (foldr cons yss xs)) '() xss)))
    (reverse-append (lambda (xs ys) (foldl cons ys xs)))
    (reverse (lambda (xs) (reverse-append xs '())))

    (range (lambda (n)
             (let loop ((i 0)) (if (= i n) '() (cons i (loop (+ i 1)))))))
    (take (lambda (xs n) (if (= 0 n) '()
                           (cons (car xs) (take (cdr xs) (- n 1))))))
    (drop (lambda (xs n) (if (= 0 n) xs (drop (cdr xs) (- n 1)))))
    (memf (lambda (? xs) (cond ((null? xs) #f)
                               ((? (car xs)) xs)
                               (#t (memf ? (cdr xs))))))
    (member (lambda (v xs) (memf (lambda (x) (equal? x v)) xs)))
    (caar (lambda (v) (car (car v))))
    (assoc (lambda (k xs) (cond ((null? xs) #f)
                                ((equal? k (caar xs)) (car xs))
                                (#t (assoc k (cdr xs))))))
    (remove-duplicates
      (lambda (xs)
        (define (ucons x acc) (if (member x acc) acc (cons x acc)))
        (reverse (foldl ucons '() xs))))))

(define code:cons*
  '((cons* (lambda (x xs) (if (null? xs) x
                            (cons x (cons* (car xs) (cdr xs))))))))
(define code:apply '((apply (lambda (f x . xs) (apply f (cons* x xs))))))
(define expander:base (expander (lambda (env)
                                  (define env:base (env-freeze env))
                                  (define form (shift k k))
                                  (parse env:base form))))
(define code (list 'let primitive-op-procs
                   (list 'letrec code:cons*
                         (list 'let code:apply (list 'letrec derived-op-procs
                                                     expander:base)))))
(define lang:base (reset (lang:primitive code)))
