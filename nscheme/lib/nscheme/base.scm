(provide lang:base stage)

(require length=? length>=? ctx:var ctx:set! ctx:op ctx:def
         env:empty env-ref env-ref-prop
         param? bpair*?! ncons param-names
         ast:quote ast:var ast:set! ast:if ast:apply ast:lambda
         ast:reset ast:shift ast:prim primitive-op-descriptions)

(define (env-extend*/var env n*)
  (define (bind n) (cons n (list (cons ctx:var  (lambda ()  (ast:var n)))
                                 (cons ctx:set! (lambda (v) (ast:set! n v))))))
  (append (map bind n*) env))
(define (env-extend*/syntax env ctx b*)
  (define (bind b) (let ((n (car b)))
                     (cons n (cons (cons ctx (cdr b)) (env-ref env n)))))
  (append (map bind b*) (alist-remove* env (map car b*))))
(define (env-freeze env)
  (map (lambda (b) (cons (car b) (alist-remove* (cdr b) (list ctx:set!))))
       env))

;; High-level AST construction
(define ast:null        (ast:quote '()))
(define ast:true        (ast:quote #t))
(define ast:false       (ast:quote #f))
(define (ast:cons a d)  (ast:prim 'cons (list a d)))
(define (ast:list . xs) (foldr ast:cons ast:null xs))
(define (ast:vector . xs)
  (define vargs (list (ast:quote (length xs)) ast:true))
  (define $mv (ast:var 'mv))
  (define (! i x) (ast:prim 'mvector-set! (list $mv (ast:quote i) x)))
  (ast:let '(mv) (list (ast:prim 'make-mvector vargs))
           (ast:begin (map ! (range (length xs)) xs)
                      (ast:prim 'mvector->vector (list $mv)))))
(define (ast:apply* $proc $a*) (ast:apply $proc (apply ast:list $a*)))
(define (ast:let p?* v* body)  (ast:apply* (ast:lambda p?* body) v*))
(define (ast:begin body-initial* body-final)
  (cond ((null? body-initial*) body-final)
        (#t (ast:let '(#f) (list (car body-initial*))
                     (ast:begin (cdr body-initial*) body-final)))))

;; Staging
(define (stage env form)
  (cond ((pair? form)
         (let ((p (car form)) (a* (cdr form)))
           (let ((op (and (string? p) (env-ref-prop env p ctx:op #f))))
             (if op (op env a*) (@apply* env p a*)))))
        ((string? form) ((or (env-ref-prop env form ctx:var #f)
                             (error '"unbound variable:" form))))
        ((or (boolean? form) (number? form)) (ast:quote form))
        ((procedure? form)                   (form env))
        (#t                                  (error '"invalid syntax:" form))))
(define (stage* env form*) (map (lambda (f) (stage env f)) form*))

(define (@apply* env p a*) (ast:apply* (stage env p) (stage* env a*)))
(define (@lambda env param body*)
  (let* ((n* (param-names param)) (env (alist-remove* env n*)))
    (ast:lambda param (@body* (env-extend*/var env n*) body*))))
(define (@let env p?* e* body*)
  (ast:apply* (@lambda env p?* body*) (stage* env e*)))
(define (@letrec env p?* e* body*)
  (define (continue env)
    (ast:begin (map (lambda (p v) (if p (ast:set! p v) v)) p?* (stage* env e*))
               (@let env p?* p?* body*)))
  (@let env p?* (map (lambda (_) #t) p?*) (list continue)))

(define (defst:empty env) (vector env '()))
(define (defst-env st)    (vector-ref st 0))
(define (defst-rdef* st)  (vector-ref st 1))
(define (@@define st n def-body)
  (vector (defst-env st) (cons (cons n def-body) (defst-rdef* st))))
;; TODO: $define-syntax ?
(define (@definition* st form*)
  (foldl (lambda (form st)
           (let* ((n (and (pair? form) (string? (car form)) (car form)))
                  ($define (and n (env-ref-prop (defst-env st) n ctx:def #f))))
             (cond ($define ($define st (cdr form)))
                   (#t (@@define st #f form))))) st form*))
(define (@begin st tail)
  (cond ((list? tail) (@definition* st tail))
        (#t           (error '"invalid begin:" tail))))
(define (@define st tail)
  (define (@ i) (list-ref tail i)) (define (@. i) (list-tail tail i))
  (cond ((and (length=? 2 tail) (param? (@ 0))) (@@define st (@ 0) (@ 1)))
        ((and (length>=? 2 tail) (pair? (@ 0)) (string? (car (@ 0))))
         (define (edef env) (@lambda env (cdr (@ 0)) (@. 1)))
         (@@define st (car (@ 0)) edef))
        (#t (error '"invalid define:" tail))))

(define (@body* env body*)
  (unless (list? body*) (error '"body must be a list:" body*))
  (define rdef* (defst-rdef* (@definition* (defst:empty env) body*)))
  (when (null? rdef*) (error '"body cannot be empty:" body*))
  (define p?e* (reverse (cdr rdef*)))
  (define final-def (car rdef*))
  (define body-final (cdr final-def))
  (when (car final-def) (error '"body cannot end with a definition:" body*))
  (if (null? p?e*) (stage env body-final)
    (@letrec env (map car p?e*) (map cdr p?e*) (list body-final))))
(define (@and* env e*)
  (define re* (reverse e*))
  (if (null? re*) ast:true
    (foldr (lambda (e r) (ast:if (stage env e) r ast:false))
           (stage env (car re*)) (reverse (cdr re*)))))
(define (@or2 env e $rest)
  (define body (let (($tmp (ast:var 'tmp))) (ast:if $tmp $tmp $rest)))
  (ast:apply* (ast:lambda (list 'tmp) body) (list (stage env e))))

,(
;; Stagers for primitive syntax
(define stagers:primitive
  '((apply ((length=? 2 tail) (ast:apply (loop (@ 0)) (loop (@ 1)))))
    (quote ((length=? 1 tail) (ast:quote (@ 0))))
    (if    ((length=? 3 tail) (ast:if (loop (@ 0)) (loop (@ 1)) (loop (@ 2)))))
    ;; TODO: support generalized parameters.
    (set!  ((and (length=? 2 tail) (string? (@ 0)))
            ((or (env-ref-prop env (@ 0) ctx:set! #f)
                 (error '"cannot set! variable:" (@ 0))) (loop (@ 1)))))
    (reset ((length>=? 1 tail) (ast:reset (@body* env tail))))
    (shift ((length>=? 2 tail)
            (ast:shift (@lambda env (list (@ 0)) (@. 1)))))
    (lambda ((length>=? 2 tail) (@lambda env (@ 0) (@. 1))))
    (letrec ((and (length>=? 2 tail) (bpair*?! (@ 0)))
             (@letrec env (map car (@ 0)) (map cadr (@ 0)) (@. 1))))
    (let . (((and (length>=? 3 tail) (string? (@ 0)) (bpair*?! (@ 1)))
             (define (p env) (@lambda env (map car (@ 1)) (@. 2)))
             (ast:apply* (@letrec env (list (@ 0)) (list p) (list (@ 0)))
                         (stage* env (map cadr (@ 1)))))
            ((and (length>=? 2 tail) (bpair*?! (@ 0)))
             (@let env (map car (@ 0)) (map cadr (@ 0)) (@. 1)))))
    (let* ((and (length>=? 2 tail) (bpair*?! (@ 0)))
           (let loop ((b* (@ 0)) (env env))
             (define (next env) (loop (cdr b*) env))
             (cond ((null? b*) (@body* env (@. 1)))
                   ((pair? b*) (@let env (list (caar b*))
                                          (list (cadar b*)) (list next)))))))
    (begin ((length>=? 1 tail) (define rb* (reverse (map loop tail)))
                               (ast:begin (reverse (cdr rb*)) (car rb*))))
    (cond ((and (list? tail) (andmap (lambda (c) (length>=? 1 c)) tail))
           (define (ast:clause c $*)
             (if (null? (cdr c)) (@or2 env (car c) $*)
               (ast:if (loop (car c)) (@body* env (cdr c)) $*)))
           (foldr ast:clause ast:true tail)))
    (and ((list? tail) (@and* env tail)))
    (or  ((list? tail)
          (foldr (lambda (e r) (@or2 env e r)) ast:false tail)))
    (when   ((length>=? 2 tail)
             (ast:if (loop (@ 0)) (@body* env (@. 1)) ast:true)))
    (unless ((length>=? 2 tail)
             (ast:if (loop (@ 0)) ast:true (@body* env (@. 1)))))))

;; Primitive language definition
(define code:syntax
  (map (lambda (name&clause*)
         (list 'cons (list 'quote (car name&clause*))
               (list 'lambda '(env tail)
                     '(define (loop tail) (stage env tail))
                     '(define (@ i) (list-ref tail i))
                     '(define (@. i) (list-tail tail i))
                     (cons 'cond (append (cdr name&clause*)
                                         '((#t (error '"invalid syntax:"
                                                      tail))))))))
       stagers:primitive))
(define code:prims
  '(map (lambda (po-desc)
          (define name (car po-desc))
          (cons name
                (lambda (env tail)
                  (cond ((length=? (length (cadr po-desc)) tail)
                         (ast:prim name (stage* env tail)))
                        (#t (error '"invalid primitive op:" po-desc tail))))))
        primitive-op-descriptions))
(define code:ops (cons 'list* (append code:syntax (list code:prims))))
(define code:env:primitive
  (list 'env-extend*/syntax
        (list 'env-extend*/syntax 'env:empty 'ctx:op code:ops)
        'ctx:def '(list (cons 'begin @begin)
                        (cons 'define @define))))
(list 'begin (list 'define 'env:primitive code:env:primitive)
      '(define (lang:primitive form) (stage env:primitive form)))
)

;; Base language definition
(define primitive-op-procs
  (map (lambda (po-desc)
         (define (x i) (vector-ref '#(x0 x1 x2 x3 x4) i))
         (define p* (map x (range (length (cadr po-desc)))))
         (list (car po-desc) (list 'lambda p* (cons (car po-desc) p*))))
       primitive-op-descriptions))

(define derived-op-procs
  '((error (lambda args ('error args)))
    (not (lambda (b) (if b #f #t)))
    (caar (lambda (v) (car (car v))))
    (cadr  (lambda (xs) (car (cdr xs))))
    (cadar (lambda (v) (cadr (car v))))
    (caddr (lambda (xs) (cadr (cdr xs))))
    (list-tail (lambda (xs i) (if (= 0 i) xs (list-tail (cdr xs) (- i 1)))))
    (list-ref  (lambda (xs i) (car (list-tail xs i))))
    (list->vector (lambda (xs)
                    (define result (make-mvector (length xs) #t))
                    (foldl (lambda (x i) (mvector-set! result i x) (+ i 1))
                           0 xs)
                    (mvector->vector result)))
    (vector->list (lambda (v)
                    (let loop ((i (- (vector-length v) 1)) (xs '()))
                      (if (< i 0) xs
                        (loop (- i 1) (cons (vector-ref v i) xs))))))
    (equal? (lambda (a b)
              (cond ((pair? a)   (and (pair? b) (equal? (car a) (car b))
                                      (equal? (cdr a) (cdr b))))
                    ((vector? a) (and (vector? b) (equal? (vector->list a)
                                                          (vector->list b))))
                    ((boolean? a)   (and (boolean? b)   (boolean=? a b)))
                    ((string?  a)   (and (string?  b)   (string=?  a b)))
                    ((number?  a)   (and (number?  b)   (number=?  a b)))
                    ((mvector? a)   (and (mvector? b)   (mvector=? a b)))
                    ((procedure? a) (and (procedure? b) (procedure=? a b)))
                    ((null? a)      (null? b)))))
    (vector (lambda xs (list->vector xs)))
    (list?  (lambda (v) (or (and (pair? v) (list? (cdr v))) (null? v))))
    (list   (lambda xs xs))
    (list*  (lambda (x . xs) (if (null? xs) x (cons x (apply list* xs)))))
    (foldl  (lambda (f acc xs) (if (null? xs) acc
                                 (foldl f (f (car xs) acc) (cdr xs)))))
    (foldr  (lambda (f acc xs) (if (null? xs) acc
                                 (f (car xs) (foldr f acc (cdr xs))))))
    (map (lambda (f xs . xss)
           (define (map1 f xs) (if (null? xs) '()
                                 (cons (f (car xs)) (map1 f (cdr xs)))))
           (cond ((null? xs) '())
                 (#t (cons (apply f (car xs) (map1 car xss))
                           (apply map f (cdr xs) (map1 cdr xss)))))))
    (for-each (lambda args (apply map args) #t))
    (andmap (lambda (f xs . xss)
              (let loop ((last #t) (xs xs) (xss xss))
                (and last (if (null? xs) last
                            (loop (apply f (car xs) (map car xss))
                                  (cdr xs) (map cdr xss)))))))
    (ormap (lambda (f xs . xss)
             (cond ((null? xs) #f)
                   ((apply f (car xs) (map car xss)))
                   (#t (apply ormap f (cdr xs) (map cdr xss))))))
    (filter (lambda (p? xs)
              (cond ((null? xs) '())
                    ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
                    (#t (filter p? (cdr xs))))))
    (filter-not (lambda (p? xs) (filter (lambda (x) (not (p? x))) xs)))
    (remf (lambda (p? xs)
            (cond ((null? xs)    '())
                  ((p? (car xs)) (cdr xs))
                  (#t (cons (car xs) (remf p? (cdr xs)))))))
    (remove (lambda (v xs) (remf (lambda (x) (equal? x v)) xs)))
    (length (lambda (xs) (foldl (lambda (_ l) (+ 1 l)) 0 xs)))
    (append (lambda xss (foldr (lambda (xs yss) (foldr cons yss xs)) '() xss)))
    (reverse-append (lambda (xs ys) (foldl cons ys xs)))
    (reverse (lambda (xs) (reverse-append xs '())))

    (range (lambda (n)
             (let loop ((i 0)) (if (= i n) '() (cons i (loop (+ i 1)))))))
    (take (lambda (xs n) (if (= 0 n) '()
                           (cons (car xs) (take (cdr xs) (- n 1))))))
    (drop (lambda (xs n) (if (= 0 n) xs (drop (cdr xs) (- n 1)))))
    (memf (lambda (? xs) (cond ((null? xs) #f)
                               ((? (car xs)) xs)
                               (#t (memf ? (cdr xs))))))
    (member (lambda (v xs) (memf (lambda (x) (equal? x v)) xs)))
    (assoc (lambda (k xs) (cond ((null? xs) #f)
                                ((equal? k (caar xs)) (car xs))
                                (#t (assoc k (cdr xs))))))
    (alist-ref (lambda (rs key default) (let ((rib (assoc key rs)))
                                          (if rib (cdr rib) default))))
    (alist-remove* (lambda (rs keys)
                     (filter (lambda (rib) (not (member (car rib) keys))) rs)))
    (string-append (lambda ss
                     (define css (map vector->list (map string->vector ss)))
                     (vector->string (list->vector (apply append css)))))
    ))

(define code:cons*
  '((cons* (lambda (x xs) (if (null? xs) x
                            (cons x (cons* (car xs) (cdr xs))))))))
(define code:apply '((apply (lambda (f x . xs) (apply f (cons* x xs))))))
(define expander:base (lambda (env)
                        (define env:base (env-freeze env))
                        (define form (shift k k))
                        (stage env:base form)))
(define code (list 'let primitive-op-procs
                   (list 'letrec code:cons*
                         (list 'let code:apply (list 'letrec derived-op-procs
                                                     expander:base)))))
(define lang:base (reset (lang:primitive code)))
