<!DOCTYPE html>
<div>test</div>
<script>
'use strict';

// TODO: handle unicode issues.
// String#normalize('NFC') all inputs
// test using:
//   i18n = 'IÃ±tÃ«rnÃ¢tiÃ´nÃ lizÃ¦tiÃ¸nâ˜ƒðŸ’©'
//   marks = 'ZÍ‘Í«ÍƒÍªÌ‚Í«Ì½ÍÌ´Ì™Ì¤ÌžÍ‰ÍšÌ¯ÌžÌ ÍAÍ«Í—Ì´Í¢ÌµÌœÌ°Í”LÍ¨Í§Í©Í˜Ì GÌ‘Í—ÌŽÌ…Í›ÍÌ´Ì»ÍˆÍÍ”Ì¹OÍ‚ÌŒÌŒÍ˜Ì¨ÌµÌ¹Ì»ÌÌ³!Ì¿Ì‹Í¥Í¥Ì‚Í£ÌÌÌÍžÍœÍ–Ì¬Ì°Ì™Ì—'
//   hangul = 'á„á…¡á†¨'
//   jamo = ['á„', 'á…¡', 'á†¨']

function cc_of(ch) { return ch.codePointAt(0); }
function cc_at(src, i) { return cc_of(src[i]); }
function cc_digit_decimal(cc) { return cc >= 48 && cc <= 57; }
function cc_digit_octal(cc) { return cc >= 48 && cc <= 55; }
function cc_digit_hex_alpha_upper(cc) { return cc >= 65 && cc <= 70; }
function cc_digit_hex_alpha_lower(cc) { return cc >= 97 && cc <= 102; }
function cc_digit_hexadecimal(cc) {
  return cc_digit_decimal(cc) ||
    cc_digit_hex_alpha_lower(cc) || cc_digit_hex_alpha_upper(cc);
  }
function cc_digit_binary(cc) { return cc === 48 || cc === 49; }
function cc_hspace(cc) {
  return cc === 32 || cc === 9 || cc === 160 || cc >= 0x2000 && cc <= 0x200A;
}
function cc_vspace(cc) {
  return cc >= 10 && cc <= 13 || cc === 133 || cc === 0x2028 || cc === 0x02029;
}
function cc_space(cc) { return cc_hspace(cc) || cc_vspace(cc); }
function cc_nonprintable(cc) {
  // TODO: anything non-graphical and non-blank.  So, anything not in these:
  // http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BL%7D%7C%5Cp%7BN%7D%7C%5Cp%7BS%7D%7C%5Cp%7BP%7D%7C%5Cp%7BZs%7D&abb=on&c=on&esc=on&g=&i=
  //   hblank:         Zs, \t
  //   alphabetic,  L: Ll, Lm, Lo, Lt, Lu
  //   numeric,     N: Nd, Nl, No
  //   symbolic,    S: Sc, Sk, Sm, So
  //   punctuation, P: Pc, Pd, Pe, Pf, Pi, Po, Ps
  //   mark,        M: Mc, Me, Mn
  // This is a hack.
  return (cc < 9 || (cc > 13 && cc < 32) || (cc >= 127 && cc < 160)
      || (cc >= 0xfff9 && cc <= 0xffff));
}
function ch_boundary(ch) {
  switch (ch) {
    case '(': case '[': case '{': case ')': case ']': case '}':
    case "'": case '`': case ',': case ';': return true;
    default: return cc_space(ch.codePointAt(0));
  }
}

function token_numeric(src, i, len) {
  return (cc_digit_decimal(cc_at(src, i)) ||
          ((src[i] === '-' || src[i] === '+') && i+1 < len &&
           (cc_digit_decimal(cc_at(src, i+1)) || src[i+1] === '.')));
}

function token_dot(src, i, len) {
  return (src[i] === '.' && (i+1 >= len || ch_boundary(src[i+1])));
}

function hex_digit_cc_to_int(cc) {
  if (cc_digit_decimal(cc))              { return cc - 48; }
  else if (cc_digit_hex_alpha_upper(cc)) { return cc - 65 + 10; }
  else if (cc_digit_hex_alpha_lower(cc)) { return cc - 97 + 10; }
}
function hex_to_int(hex) {
  var len = hex.length;
  var result = 0;
  for (var i = 0; i < len; ++i) {
    var cc = cc_at(hex, i);
    if (!cc_digit_hexadecimal(cc)) { throw ['invalid hexadecimal', orig]; }
    result = (result * 16) + hex_digit_cc_to_int(cc);
  }
  return result;
}
function hex_to_str(hex) { return String.fromCodePoint(hex_to_int(hex)); }

var bad_leading = ['#'];
var bad_anywhere = ['\\',"'",'`',',',';','"','(',')','[',']','{','}','\0','\b'];
function ch_in(ch, xs) {
  for (var j = xs.length-1; j >= 0; --j) { if (ch === xs[j]) { return true; } }
  return false;
}
function text_should_quote(text) {
  var s = Array.from(text);
  var len = s.length;
  if ((len === 0) || (token_numeric(s, 0, len) || token_dot(s, 0, len))
      || (ch_in(s[0], bad_leading))) { return true; }
  for (var i = 0; i < len; ++i) {
    if (cc_nonprintable(cc_at(s, i)) || cc_space(cc_at(s, i))
        || ch_in(s[i], bad_anywhere)) { return true; }
  }
  return false;
}
function text_repeat(text, count) {
  var result = text;
  for (var i = 1; i < count; ++i) { result += text; }
  return result;
}
function encode_char(ch) {
  switch (ch) {
    case '\0': return '\\0';
    case '\b': return '\\b';
    case '\t': return '\\t';
    case '\n': return '\\n';
    case '\v': return '\\v';
    case '\f': return '\\f';
    case '\r': return '\\r';
    case '"':  return '\\"';
    default:
      var cc = ch.codePointAt(0);
      if (cc === 7) { return '\\a'; }
      else if (cc === 27) { return '\\e'; }
      else if (cc_nonprintable(cc) || (cc !== 32 && cc_space(cc))) {
        return '\\u{' + cc.toString(16) + '}';
      }
      return;
  }
}
function text_quoted(text) {
  var s = Array.from(text);
  var quoted = '"', len = s.length, h = 0, i = 0;
  for (; i < len; ++i) {
    var ch = encode_char(s[i]);
    if (ch !== undefined) {
      quoted += s.slice(h, i).join('') + ch;
      h = i+1;
    }
  }
  quoted += text.slice(h, i) + '"';
  return quoted;
}

// TODO: manage token count.
function stream(source) {
  return {src: Array.from(source), token: 0, pos: 0, line: 0, col: 0, msg: ''};
}
function stream_finish(ss) { ss.pos = ss.src.length; }
function stream_finished(ss) { return ss.pos === ss.src.length; }
function stream_unexpected(ss, str) { ss.msg = 'unexpected `'+str+'`'; }
function stream_expected(ss, str) { ss.msg = 'expected `'+str+'`'; }
function stream_skip_whitespace(ss) {
  var src = ss.src, i = ss.pos, len = src.length;
  for (; i < len; ++i) {
    var cc = cc_at(src, i);
    if (cc_vspace(cc)) { ++ss.line; ss.col = 0; }
    else if (cc_hspace(cc)) { ++ss.col; }
    else { break; }
  }
  ss.pos = i; return i;
}

// TODO:
// base due to #x #d #o #b
// -+ checking should happen externally
// [-,+][nan,inf]
function read_stream_number(base, ss) {
  var src = ss.src, i = ss.pos, len = src.length, needs_digits = true;
  var whole = 0, fraction = 0, exponent = 0, esign = 1;
  var cc_digit;
  switch (base) {
    case 2: cc_digit = cc_digit_binary; break;
    case 8: cc_digit = cc_digit_octal; break;
    case 10: cc_digit = cc_digit_decimal; break;
    case 16: cc_digit = cc_digit_hexadecimal; break;
    default: throw ['invalid base', base];
  }
  var decode = function() {
    if (needs_digits || (i < len && !ch_boundary(src[i]))) {
      ss.msg = 'invalid number'; return;
    }
    ss.col += i - ss.pos;
    ss.pos = i;
    return (whole + fraction) * Math.pow(base, esign * exponent);
  }
  for (; i < len; ++i) {
    var cc = cc_at(src, i);
    if (!cc_digit(cc)) { break; }
    needs_digits = false;
    whole = (whole * base) + hex_digit_cc_to_int(cc);
  }
  if (i === len) { return decode(); }
  if (src[i] === '.') {
    var divisor = base;
    for (++i; i < len; ++i) {
      var cc = cc_at(src, i);
      if (!cc_digit(cc)) { break; }
      needs_digits = false;
      fraction += hex_digit_cc_to_int(cc) / divisor;
      divisor *= base;
    }
  }
  if (i === len) { return decode(); }
  switch (src[i]) {
    case 'e': case 'E': case 'l': case 'L':
      needs_digits = true; if (++i === len) { return decode(); }
      var ch = src[i]; if ((ch === '-') || (ch === '+')) { ++i; }
      if (ch === '-') { esign = -1; }
      for (; i < len; ++i) {
        var cc = cc_at(src, i);
        if (!cc_digit(cc)) { break; }
        needs_digits = false;
        exponent = (exponent * base) + hex_digit_cc_to_int(cc);
      }
  }
  return decode();
}

function read_stream_text_codepoint(ss) {
  var src = ss.src, i = ss.pos, len = src.length, code = [];
  if (i >= len || src[i] !== '{') { return stream_expected(ss, '{'); }
  for (++i; i < len; ++i) {
    var ch = src[i];
    if (ch === '}') {
      ss.col += i - ss.pos; ss.pos = i; return hex_to_str(code);
    }
    else if (!cc_digit_hexadecimal(cc_of(ch))) {
      ss.col += i - ss.pos; ss.pos = i; return stream_unexpected(ss, ch);
    } else { code.push(ch); }
  }
  ss.col += i - ss.pos; ss.pos = i; return stream_expected(ss, '}');
}
function read_stream_text_escaped(ss) {
  var prefix = ss.src[ss.pos]; ++ss.pos; ++ss.col;
  switch (prefix) {
    case '0': return '\0';
    case 'a': return String.fromCodePoint(7);
    case 'b': return '\b';
    case 't': return '\t';
    case 'n': return '\n';
    case 'v': return '\v';
    case 'f': return '\f';
    case 'r': return '\r';
    case 'e': return String.fromCodePoint(27);
    case 'u': return read_stream_text_codepoint(ss);
    default: return prefix;
  }
}
function read_stream_text(ss) {
  var src = ss.src, i = ss.pos, len = src.length, text = [], quoted = false;
  for (; i < len; ++i) {
    var ch = src[i];
    if (ch === '"') { quoted = !quoted; continue; }
    if (!quoted && ch_boundary(ch)) { break; }
    else if (ch === '\\') {
      if (++i < len) {
        if (src[i] === '\n') { ++ss.line; ss.col = 0; }
        else {
          ++ss.col; ss.pos = i;
          ch = read_stream_text_escaped(ss); i = ss.pos;
          if (ch === undefined) { return; }
          text.push(ch);
        }
      } else { ss.pos = i; return stream_unexpected(ss, 'end-of-stream'); }
    } else { text.push(ch); ++ss.col; }
  }
  ss.pos = i;
  if (quoted) { return stream_unexpected(ss, 'end-of-stream'); }
  return text.join('');
}

// TODO: read, wrapping read_stream

// TODO: write

// TODO:
// ,@ unquote-splicing
// #' syntax
// #` quasisyntax
// #, unsyntax
// #,@ unsyntax-splicing

// TODO: comments
// ; #||# #;

function is_nil(datum) { return datum === null; }
function is_closure(datum) { return typeof datum === 'function'; }
function is_boolean(datum) { return typeof datum === 'boolean'; }
function is_text(datum) { return typeof datum === 'string'; }
function is_number(datum) { return typeof datum === 'number'; }
function is_int32(datum) {
  return (typeof datum === 'number') && (datum === (datum | 0));
}
function is_pair(datum) {
  return (typeof datum === 'object') && (datum !== null);
}

function env_extend(env, datum) { return [datum, env]; }
function env_ref(env, idx) {
  for (; idx > 0; --idx) { env = env[1]; }
  return env[0];
}
function env_find(env, found) {
  var index = 0;
  for (; env !== null; ++index) {
    if (found(env[0])) { return index; }
    env = env[1];
  }
  return undefined;
}
function env_find_name(env, name) {
  var index = env_find(env, function(b){return (name === b[0]);});
  if (index === undefined) { throw ['unbound variable', name]; }
  return index;
}
function env_lookup(env, name) {
  var index = env_find_name(env, name);
  return env_ref(env, index)[1];
}

// TODO: Expect annotated syntax.
function syntax_list_of_length(len, xs, err) {
  var result = [];
  for (; len > 0; --len) {
    if (!is_pair(xs)) { throw err; }
    result.push(xs[0]);
    xs = xs[1];
  }
  if (!is_nil(xs)) { throw err; }
  return result;
}
function syntax_list(xs, err) {
  var result = [];
  while (is_pair(xs)) {
    result.push(xs[0]);
    xs = xs[1];
  }
  if (!is_nil(xs)) { throw err; }
  return result;
}
function array_to_list(xs) {
  var i = xs.length - 1;
  var result = null;
  for (; i >= 0; --i) { result = [xs[i], result]; }
  return result;
}
function array_map(f, xs) {
  var i = xs.length - 1;
  var result = [];
  result.length = xs.length;
  for (; i >= 0; --i) { result[i] = f(xs[i]); }
  return result;
}

function evaluate(stx) {
  // TODO: It may be better to pass these registers around in an explicit
  // context rather than capturing them in closures.  It may also be more
  // efficient to represent continuations as tagged data structures.
  var result, env = null, ks = [function(){return null;}];

  function unwind(res) { result = res; return ks.pop(); }

  function denote_literal(datum) {
    return function() { return unwind(datum); };
  }
  function denote_var(senv, name) {
    var index = env_find_name(senv, name);
    if (env_ref(senv, index)[1] !== false) { throw ['invalid syntax', name]; }
    return function() { return unwind(env_ref(env, index)); };
  }

  function build_app(senv, dp, as) {
    if (is_nil(as)) { return dp; }
    var da = denote(senv, as[0]);
    var dapp = function(){
      var kenv = env;
      ks.push(function() {
        var proc = result;
        if (!is_closure(proc)) { throw ['cannot apply non-procedure', proc]; }
        ks.push(function() { return proc(result); });
        env = kenv;
        return da;
      });
      return dp;
    };
    return build_app(senv, dapp, as[1]);
  }
  function denote_app(senv, stx) {
    var err = ['invalid application', stx];
    if (!is_pair(stx)) { throw err; }
    syntax_list(stx[1], err);
    return build_app(senv, denote(senv, stx[0]), stx[1]);
  }

  function denote(senv, stx) {
    if (is_nil(stx) || is_boolean(stx) || is_number(stx)) {
      return denote_literal(stx);
    } else if (is_text(stx)) {
      return denote_var(senv, stx);
    } else if (is_pair(stx)) {
      if (is_text(stx[0])) {
        var special = env_lookup(senv, stx[0]);
        if (typeof special === 'function') { return special(senv, stx[1]); }
      }
      return denote_app(senv, stx);
    } else { throw ['unknown syntax', stx]; }
  }

  function build_lambda(senv, params, body) {
    if (is_nil(params)) { return denote(senv, body); }
    senv = env_extend(senv, [params[0], false]);
    var dl = build_lambda(senv, params[1], body);
    return function() {
      var clo_env = env;
      return unwind(function(arg) {
          env = env_extend(clo_env, arg);
          return dl;
          });
    };
  }
  function denote_lambda(senv, stx) {
    var err = ['invalid lambda', stx];
    stx = syntax_list_of_length(2, stx, err);
    var params = stx[0], body = stx[1];
    if (!is_pair(params)) { throw err; }
    array_map(function(p){ if (!is_text(p)) { throw err; } },
              syntax_list(params, err));
    return build_lambda(senv, params, body);
  }
  function denote_if(senv, stx) {
    stx = syntax_list_of_length(3, stx, ['invalid if', stx]);
    var dc = denote(senv, stx[0]);
    var dt = denote(senv, stx[1]);
    var df = denote(senv, stx[2]);
    return function() {
      var kenv = env;
      ks.push(function(){
        env = kenv;
        if (result === false) { return df; } else { return dt; }
      });
      return dc;
    };
  }
  function denote_quote(senv, stx) {
    stx = syntax_list_of_length(1, stx, ['invalid quote', stx]);
    return denote_literal(stx[0]);
  }
  function denote_qq(senv, stx) {
    // TODO:
  }
  function denote_let(senv, stx) {
    var err = ['invalid let', stx];
    stx = syntax_list_of_length(2, stx, err);
    var bindings = array_map(function(b) {
      return syntax_list_of_length(2, b, err);
    }, syntax_list(stx[0], err));
    var params = array_map(function(b) {
      if (!is_text(b[0])) { throw err; } return b[0];
    }, bindings);
    var args = array_map(function(b) { return b[1]; }, bindings);
    var body = stx[1];
    var dp = build_lambda(senv, array_to_list(params), body);
    return build_app(senv, dp, array_to_list(args));
  }

  var operatives = [
    ['let', denote_let],
    ['quasiquote', denote_qq],
    ['quote', denote_quote],
    ['if', denote_if],
    ['lambda', denote_lambda]];

  function native_procedure_huh(datum) {
    return unwind(is_closure(datum));
  }
  function native_boolean_huh(datum) {
    return unwind(is_boolean(datum));
  }
  function native_pair_huh(datum) { return unwind(is_pair(datum)); }
  function native_nil_huh(datum) { return unwind(is_nil(datum)); }
  function native_text_huh(datum) { return unwind(is_text(datum)); }
  function native_number_huh(datum) { return unwind(is_number(datum)); }
  function native_int32_huh(datum) { return unwind(is_int32(datum)); }
  function make_eq(name, is_x) {
    return function(x0) {
      if (!is_x(x0)) { throw ["invalid argument to '"+name+"'", x0]; }
      return unwind(function(x1) {
          if (!is_x(x1)) { throw ["invalid argument to '"+name+"'", x1]; }
          return unwind(x0 === x1);
          });
    };
  }
  var native_text_eq = make_eq('text=?', is_text);
  var native_number_eq = make_eq('number=?', is_number);
  var native_int32_eq = make_eq('int32=?', is_int32);
  function make_lt(name, is_x) {
    return function(x0) {
      if (!is_x(x0)) { throw ["invalid argument to '"+name+"'", x0]; }
      return unwind(function(x1) {
          if (!is_x(x1)) { throw ["invalid argument to '"+name+"'", x1]; }
          return unwind(x0 < x1);
          });
    };
  }
  var native_text_lt = make_lt('text<?', is_text);
  var native_number_lt = make_lt('number<?', is_number);
  var native_int32_lt = make_lt('int32<?', is_int32);
  function native_pair(h) {
    return unwind(function(t) { return unwind([h, t]); });
  }
  function native_pair_head(p) {
    if (!is_pair(p)) { throw ['cannot take head of non-pair', p]; }
    return unwind(p[0]);
  }
  function native_pair_tail(p) {
    if (!is_pair(p)) { throw ['cannot take tail of non-pair', p]; }
    return unwind(p[1]);
  }

  function native_text_concat(t0) {
    if (!is_text(t0)) { throw ['cannot text-concat non-text', t0]; }
    return unwind(function(t1) {
        if (!is_text(t1)) { throw ['cannot text-concat non-text', t1]; }
        return unwind(t0.concat(t1));
        });
  }
  function native_text_to_chars(txt) {
    if (!is_text(txt)) { throw ['cannot text->chars non-text', txt]; }
    var txt = Array.from(txt);
    var answer = null;
    for (var i = txt.length-1; i >= 0; --i) { answer = [txt[i], answer]; }
    return unwind(answer);
  }
  function native_char_to_code(ch) {
    if (!is_text(ch)) { throw ['cannot char->code with non-char', ch]; }
    var txt = Array.from(ch);
    if (txt.length !== 1) { throw ['char->code expects one character', ch]; }
    return unwind(cc_at(txt, 0));
  }
  function native_char_from_code(code) {
    if (!is_int32(code)) { throw ['invalid text code', code]; }
    return unwind(String.fromCodePoint(code));
  }

  function native_nadd(n0) {
    if (!is_number(n0)) { throw ['cannot add non-number', n0]; }
    return unwind(function(n1) {
        if (!is_number(n1)) { throw ['cannot add non-number', n1]; }
        return unwind(n0 + n1);
        });
  }
  function native_nsub(n0) {
    if (!is_number(n0)) { throw ['cannot subtract non-number', n0]; }
    return unwind(function(n1) {
        if (!is_number(n1)) { throw ['cannot subtract non-number', n1]; }
        return unwind(n0 - n1);
        });
  }
  function native_nmul(n0) {
    if (!is_number(n0)) { throw ['cannot multiply non-number', n0]; }
    return unwind(function(n1) {
        if (!is_number(n1)) { throw ['cannot multiply non-number', n1]; }
        return unwind(n0 * n1);
        });
  }
  function native_ndiv(n0) {
    if (!is_number(n0)) { throw ['cannot divide non-number', n0]; }
    return unwind(function(n1) {
        if (!is_number(n1)) { throw ['cannot divide non-number', n1]; }
        return unwind(n0 / n1);
        });
  }
  function native_nmod(n0) {
    if (!is_number(n0)) { throw ['cannot modulo non-number', n0]; }
    return unwind(function(n1) {
        if (!is_number(n1)) { throw ['cannot modulo non-number', n1]; }
        return unwind(n0 % n1);
        });
  }

  // TODO: More text and/or numerical operations?
  var applicatives = [
    ['procedure?', native_procedure_huh],
    ['pair?', native_pair_huh],
    ['nil?', native_nil_huh],
    ['boolean?', native_boolean_huh],
    ['text?', native_text_huh],
    ['number?', native_number_huh],
    ['int32?', native_int32_huh],
    ['text=?', native_text_eq],
    ['text<?', native_text_lt],
    ['number=?', native_number_eq],
    ['number<?', native_number_lt],
    ['int32=?', native_int32_eq],
    ['int32<?', native_int32_lt],
    ['pair', native_pair],
    ['head', native_pair_head],
    ['tail', native_pair_tail],
    ['text-concat', native_text_concat],
    ['text->chars', native_text_to_chars],
    ['char->code', native_char_to_code],
    ['char<-code', native_char_from_code],
    ['+', native_nadd],
    ['-', native_nsub],
    ['*', native_nmul],
    ['/', native_ndiv],
    ['%', native_nmod]];

  var initial_senv =
    array_to_list(
      array_map(function(binding){return [binding[0],false];},
                applicatives).concat(operatives));

  var initial_env =
    array_to_list(
      array_map(function(binding){return binding[1];}, applicatives).concat(
        array_map(function(binding){return binding[1];}, operatives)));

  env = initial_env;
  var k = denote(initial_senv, stx);
  while (k !== null) { k = k(); }
  return result;
}

function deep_equal(a, b) {
  if (a === b) { return true; }
  if (is_closure(a) || is_closure(b)) {
    throw ['procedure equality checking is not supported', a, b];
  }
  if (is_pair(a) && is_pair(b)) {
    return deep_equal(a[0], b[0]) && deep_equal(a[1], b[1]);
  }
  return false;
}

var test_ctx = {verbose: false, passed: 0, total: 0, log: []};
function check_equal(name, actual, expected) {
  ++(test_ctx.total);
  if (deep_equal(actual, expected)) {
    ++(test_ctx.passed);
    if (test_ctx.verbose) { test_ctx.log.push([name, actual]); }
  } else {
    test_ctx.log.push(
        ['FAILED', name, 'ACTUAL', actual, 'EXPECTED', expected]);
  }
}
function test_log() {
  var log = test_ctx.log, l = log.length;
  for (var i = 0; i < l; ++i) { console.log.apply(this, log[i]); }
  console.log(test_ctx.passed, 'out of', test_ctx.total, 'tests passed.');
}

function test() {
  check_equal('literals',
      [evaluate(null), evaluate(true), evaluate(4)], [null, true, 4]);
  check_equal('lambda app 1',
      evaluate([['lambda', [['x', ['y', null]],
        ['x', null]]],
        [5, [6, null]]]), 5);
  check_equal('lambda app 2',
      evaluate([['lambda', [['x', ['y', null]],
        ['y', null]]],
        [5, [6, null]]]), 6);
  check_equal('lambda app 2',
      evaluate([['lambda', [['x', ['y', null]],
        [['pair', ['y', ['x', null]]], null]]],
        [5, [6, null]]]), [6, 5]);
  check_equal('if 1',
      evaluate(['if', [['head', [['quote', [[true, false], null]], null]],
        [['quote', ['yes', null]],
        [['quote', ['no', null]], null]]]]), 'yes');
  check_equal('if 2',
      evaluate(['if', [['tail', [['quote', [[true, false], null]], null]],
        [['quote', ['yes', null]],
        [['quote', ['no', null]], null]]]]), 'no');
  check_equal('let 1',
      evaluate(['let', [[['x', [8, null]], null],
        ['x', null]]]), 8);
  check_equal('let 2',
      evaluate(['let', [[['x', [9, null]], null],
        [['let', [[['x', [20, null]], null],
        ['x', null]]], null]]]), 20);
  check_equal('let 3',
      evaluate(['let', [[['x', [9, null]], null],
        [['let', [[['y', [20, null]], null],
        ['x', null]]], null]]]), 9);
  test_log();
}

test();
</script>
